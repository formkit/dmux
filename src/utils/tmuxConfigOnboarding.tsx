import { execSync } from 'child_process';
import fs from 'fs/promises';
import os from 'os';
import path from 'path';
import React, { useState } from 'react';
import { Box, Text, render, useApp, useInput } from 'ink';
import { LogService } from '../services/LogService.js';

export type TmuxPresetTheme = 'dark' | 'light';

type OnboardingOutcome = 'existing-config' | 'install-dark' | 'install-light' | 'skip';

interface OnboardingState {
  tmuxConfigOnboarding?: {
    completed: boolean;
    completedAt: string;
    outcome: OnboardingOutcome;
    configPath?: string;
  };
}

const ONBOARDING_STATE_RELATIVE_PATH = path.join('.dmux', 'onboarding.json');

/**
 * Candidate config locations used by tmux on modern systems.
 * We only offer onboarding when none of these contain a meaningful config.
 */
export function getTmuxConfigCandidatePaths(homeDir: string): string[] {
  return [
    path.join(homeDir, '.tmux.conf'),
    path.join(homeDir, '.config', 'tmux', 'tmux.conf'),
  ];
}

/**
 * Returns true if the user already has tmux configuration in a known location.
 * A non-empty file is treated as "configured" to avoid overwriting user intent.
 */
export async function hasMeaningfulTmuxConfig(homeDir: string): Promise<boolean> {
  const candidatePaths = getTmuxConfigCandidatePaths(homeDir);

  for (const configPath of candidatePaths) {
    try {
      const stats = await fs.stat(configPath);
      if (stats.isFile() && stats.size > 0) {
        return true;
      }
    } catch {
      // Expected when config file does not exist
    }
  }

  return false;
}

export function buildRecommendedTmuxConfig(theme: TmuxPresetTheme): string {
  const palette = theme === 'dark'
    ? {
      windowStyle: "set -g window-style 'fg=colour247,bg=colour236'",
      activeWindowStyle: "set -g window-active-style 'fg=default,bg=colour234'",
      paneBorderStyle: 'set -g pane-border-style "fg=colour238 bg=default"',
      activePaneBorderStyle: 'set -g pane-active-border-style "fg=colour39 bg=default"',
      statusStyle: "set -g status-style 'fg=colour252,bg=colour236'",
    }
    : {
      windowStyle: "set -g window-style 'fg=colour238,bg=colour255'",
      activeWindowStyle: "set -g window-active-style 'fg=colour232,bg=colour252'",
      paneBorderStyle: 'set -g pane-border-style "fg=colour250 bg=default"',
      activePaneBorderStyle: 'set -g pane-active-border-style "fg=colour27 bg=default"',
      statusStyle: "set -g status-style 'fg=colour238,bg=colour254'",
    };

  return [
    '# =============================================',
    '# dmux recommended tmux config',
    `# Theme: ${theme}`,
    '# Generated by dmux onboarding',
    '# =============================================',
    '',
    '# Better support for Ctrl+Shift arrow bindings on newer tmux versions',
    'set -gq extended-keys on',
    '',
    '# Pane visuals',
    "set -g pane-border-format ' #[bold]#P #[default]#{?pane_title,#{pane_title},#{pane_current_command}} '",
    'set -g pane-border-status top',
    palette.windowStyle,
    palette.activeWindowStyle,
    palette.paneBorderStyle,
    palette.activePaneBorderStyle,
    '',
    '# Status bar',
    palette.statusStyle,
    '',
    '# Fast pane navigation',
    'bind -n C-S-Left select-pane -L',
    'bind -n C-S-Right select-pane -R',
    'bind -n C-S-Up select-pane -U',
    'bind -n C-S-Down select-pane -D',
    '',
    '# Mouse + clipboard quality-of-life',
    'set -g mouse on',
    'set -g set-clipboard on',
    'set -gq allow-passthrough all',
    '',
    '# Copy selected text to system clipboard (best effort by platform)',
    `if-shell "command -v pbcopy >/dev/null 2>&1" "bind-key -T copy-mode MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel 'pbcopy'"`,
    `if-shell "command -v pbcopy >/dev/null 2>&1" "bind-key -T copy-mode-vi MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel 'pbcopy'"`,
    `if-shell "command -v wl-copy >/dev/null 2>&1" "bind-key -T copy-mode MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel 'wl-copy'"`,
    `if-shell "command -v wl-copy >/dev/null 2>&1" "bind-key -T copy-mode-vi MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel 'wl-copy'"`,
    `if-shell "command -v xclip >/dev/null 2>&1" "bind-key -T copy-mode MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel 'xclip -selection clipboard -in'"`,
    `if-shell "command -v xclip >/dev/null 2>&1" "bind-key -T copy-mode-vi MouseDragEnd1Pane send-keys -X copy-pipe-and-cancel 'xclip -selection clipboard -in'"`,
    '',
    '# Terminal passthrough improvements (Ghostty/kitty)',
    "set -ga terminal-overrides ',xterm-256color:Ms=\\E]52;c;%p2%s\\007'",
    "set -ga terminal-overrides ',*:Ss=\\E[%p1%d q:Se=\\E[2 q'",
    '',
    '# Preserve terminal program info inside tmux',
    'set -ga update-environment "TERM_PROGRAM"',
    '',
  ].join('\n');
}

function shellQuote(value: string): string {
  return `'${value.replace(/'/g, `'\\''`)}'`;
}

async function readOnboardingState(statePath: string): Promise<OnboardingState> {
  try {
    const raw = await fs.readFile(statePath, 'utf-8');
    const parsed = JSON.parse(raw) as OnboardingState;
    if (parsed && typeof parsed === 'object') {
      return parsed;
    }
  } catch {
    // Expected when state file does not exist
  }

  return {};
}

async function writeOnboardingState(
  homeDir: string,
  outcome: OnboardingOutcome,
  configPath?: string
): Promise<void> {
  const statePath = path.join(homeDir, ONBOARDING_STATE_RELATIVE_PATH);
  const currentState = await readOnboardingState(statePath);
  const nextState: OnboardingState = {
    ...currentState,
    tmuxConfigOnboarding: {
      completed: true,
      completedAt: new Date().toISOString(),
      outcome,
      ...(configPath ? { configPath } : {}),
    },
  };

  await fs.mkdir(path.dirname(statePath), { recursive: true });
  await fs.writeFile(statePath, JSON.stringify(nextState, null, 2), 'utf-8');
}

async function writeRecommendedTmuxConfig(
  homeDir: string,
  theme: TmuxPresetTheme
): Promise<string> {
  const configPath = path.join(homeDir, '.tmux.conf');
  const configContent = buildRecommendedTmuxConfig(theme);

  await fs.writeFile(configPath, configContent, 'utf-8');
  return configPath;
}

function sourceTmuxConfig(configPath: string): void {
  try {
    execSync(`tmux source-file ${shellQuote(configPath)}`, { stdio: 'pipe' });
  } catch {
    // Best effort only - server may not be running yet
  }
}

function promptForTmuxConfigSetup(): Promise<OnboardingOutcome> {
  return new Promise((resolve) => {
    let resolved = false;

    const settle = (outcome: OnboardingOutcome): void => {
      if (resolved) {
        return;
      }
      resolved = true;
      resolve(outcome);
    };

    const app = render(
      <TmuxConfigOnboardingPrompt onComplete={settle} />,
      { exitOnCtrlC: false }
    );

    app.waitUntilExit()
      .then(() => settle('skip'))
      .catch(() => settle('skip'));
  });
}

interface TmuxConfigOnboardingPromptProps {
  onComplete: (outcome: OnboardingOutcome) => void;
}

const TmuxConfigOnboardingPrompt: React.FC<TmuxConfigOnboardingPromptProps> = ({ onComplete }) => {
  const { exit } = useApp();
  const [step, setStep] = useState<'offer' | 'theme'>('offer');
  const [offerIndex, setOfferIndex] = useState(0);
  const [themeIndex, setThemeIndex] = useState(0);

  const finish = (outcome: OnboardingOutcome) => {
    onComplete(outcome);
    exit();
  };

  useInput((input, key) => {
    if (key.ctrl && input.toLowerCase() === 'c') {
      finish('skip');
      return;
    }

    if (step === 'offer') {
      if (input.toLowerCase() === 'y') {
        setStep('theme');
        return;
      }

      if (input.toLowerCase() === 'n' || key.escape) {
        finish('skip');
        return;
      }

      if (key.upArrow || key.leftArrow) {
        setOfferIndex(prev => Math.max(0, prev - 1));
        return;
      }

      if (key.downArrow || key.rightArrow) {
        setOfferIndex(prev => Math.min(1, prev + 1));
        return;
      }

      if (key.return) {
        if (offerIndex === 0) {
          setStep('theme');
        } else {
          finish('skip');
        }
      }

      return;
    }

    if (input.toLowerCase() === 'd') {
      finish('install-dark');
      return;
    }

    if (input.toLowerCase() === 'l') {
      finish('install-light');
      return;
    }

    if (key.leftArrow || key.upArrow) {
      setThemeIndex(prev => Math.max(0, prev - 1));
      return;
    }

    if (key.rightArrow || key.downArrow) {
      setThemeIndex(prev => Math.min(1, prev + 1));
      return;
    }

    if (key.escape) {
      setStep('offer');
      return;
    }

    if (key.return) {
      finish(themeIndex === 0 ? 'install-dark' : 'install-light');
    }
  });

  return (
    <Box flexDirection="column" borderStyle="round" borderColor="cyan" paddingX={1} marginTop={1}>
      <Text bold color="cyan">Welcome to dmux</Text>
      <Box marginTop={1} flexDirection="column">
        <Text>No tmux config was found in:</Text>
        <Text dimColor>~/.tmux.conf or ~/.config/tmux/tmux.conf</Text>
      </Box>
      <Box marginTop={1} flexDirection="column">
        <Text>dmux works best with a few tmux settings for pane borders, navigation, and clipboard behavior.</Text>
      </Box>

      {step === 'offer' ? (
        <Box marginTop={1} flexDirection="column">
          <Text bold>Install a recommended tmux config?</Text>
          <Box marginTop={1} flexDirection="column">
            <Text color={offerIndex === 0 ? 'green' : 'white'} bold={offerIndex === 0}>
              {offerIndex === 0 ? '> ' : '  '}Yes (recommended)
            </Text>
            <Text color={offerIndex === 1 ? 'yellow' : 'white'} bold={offerIndex === 1}>
              {offerIndex === 1 ? '> ' : '  '}No, skip this
            </Text>
          </Box>
          <Box marginTop={1}>
            <Text dimColor>up/down to navigate | Enter to select | y/n shortcuts</Text>
          </Box>
        </Box>
      ) : (
        <Box marginTop={1} flexDirection="column">
          <Text bold>Choose a theme:</Text>
          <Box marginTop={1} flexDirection="column">
            <Text color={themeIndex === 0 ? 'green' : 'white'} bold={themeIndex === 0}>
              {themeIndex === 0 ? '> ' : '  '}Dark mode preset
            </Text>
            <Text color={themeIndex === 1 ? 'green' : 'white'} bold={themeIndex === 1}>
              {themeIndex === 1 ? '> ' : '  '}Light mode preset
            </Text>
          </Box>
          <Box marginTop={1}>
            <Text dimColor>left/right or up/down to switch | Enter to install | Esc to go back</Text>
          </Box>
        </Box>
      )}
    </Box>
  );
};

/**
 * First-run onboarding for tmux config presets.
 * - If user already has tmux config, mark onboarding complete and continue.
 * - If no config, ask once and optionally install a recommended preset.
 */
export async function runTmuxConfigOnboardingIfNeeded(): Promise<void> {
  const logger = LogService.getInstance();

  try {
    const homeDir = process.env.HOME || os.homedir();
    if (!homeDir) {
      return;
    }

    const statePath = path.join(homeDir, ONBOARDING_STATE_RELATIVE_PATH);
    const onboardingState = await readOnboardingState(statePath);

    if (onboardingState.tmuxConfigOnboarding?.completed) {
      return;
    }

    const hasTmuxConfig = await hasMeaningfulTmuxConfig(homeDir);
    if (hasTmuxConfig) {
      await writeOnboardingState(homeDir, 'existing-config');
      return;
    }

    if (!process.stdin.isTTY || !process.stdout.isTTY) {
      logger.debug(
        'Skipping tmux onboarding prompt because terminal is non-interactive',
        'onboarding'
      );
      return;
    }

    const outcome = await promptForTmuxConfigSetup();
    if (outcome === 'install-dark' || outcome === 'install-light') {
      const theme: TmuxPresetTheme = outcome === 'install-dark' ? 'dark' : 'light';
      const configPath = await writeRecommendedTmuxConfig(homeDir, theme);
      sourceTmuxConfig(configPath);
      await writeOnboardingState(homeDir, outcome, configPath);
      logger.info(`Installed ${theme} tmux preset at ${configPath}`, 'onboarding');
      return;
    }

    await writeOnboardingState(homeDir, 'skip');
  } catch (error) {
    logger.warn(
      `Tmux onboarding failed: ${error instanceof Error ? error.message : String(error)}`,
      'onboarding'
    );
  }
}
