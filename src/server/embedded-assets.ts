/**
 * Auto-generated embedded assets from frontend/dist
 * DO NOT EDIT MANUALLY - Generated by scripts/embed-assets.js
 */

export interface EmbeddedAsset {
  content: string;
  mimeType: string;
  size: number;
}

export const embeddedAssets: Record<string, EmbeddedAsset> = {
  'AutoUpdater.js': {
    content: `import { execSync } from 'child_process';
import fs from 'fs/promises';
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const packageJson = require('../package.json');
export class AutoUpdater {
    configFile;
    checkIntervalMs = 24 * 60 * 60 * 1000; // 24 hours
    constructor(configFile) {
        this.configFile = configFile;
    }
    async loadSettings() {
        try {
            const content = await fs.readFile(this.configFile, 'utf-8');
            const config = JSON.parse(content);
            return config.updateSettings || {
                checkIntervalHours: 24,
                autoUpdateEnabled: true
            };
        }
        catch {
            return {
                checkIntervalHours: 24,
                autoUpdateEnabled: true
            };
        }
    }
    async saveSettings(settings) {
        let config = {};
        try {
            const content = await fs.readFile(this.configFile, 'utf-8');
            config = JSON.parse(content);
        }
        catch { }
        config.updateSettings = settings;
        config.lastUpdated = new Date().toISOString();
        await fs.writeFile(this.configFile, JSON.stringify(config, null, 2));
    }
    async shouldCheckForUpdates() {
        const settings = await this.loadSettings();
        const now = Date.now();
        if (!settings.lastCheckTime) {
            return true;
        }
        const intervalMs = (settings.checkIntervalHours || 24) * 60 * 60 * 1000;
        return now - settings.lastCheckTime > intervalMs;
    }
    async getLatestVersion() {
        try {
            // First try using npm view which is usually faster
            const result = execSync(\`npm view \${packageJson.name} version\`, {
                encoding: 'utf-8',
                stdio: 'pipe',
                timeout: 10000
            }).trim();
            if (result && this.isValidVersion(result)) {
                return result;
            }
        }
        catch {
            // Fallback to npm registry API
            try {
                const response = await fetch(\`https://registry.npmjs.org/\${packageJson.name}/latest\`, {
                    method: 'GET',
                    headers: {
                        'User-Agent': \`\${packageJson.name}/\${packageJson.version}\`
                    }
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.version && this.isValidVersion(data.version)) {
                        return data.version;
                    }
                }
            }
            catch {
                // Network error or API unavailable
            }
        }
        return null;
    }
    isValidVersion(version) {
        return /^\\d+\\.\\d+\\.\\d+/.test(version);
    }
    compareVersions(current, latest) {
        const currentParts = current.split('.').map(n => parseInt(n));
        const latestParts = latest.split('.').map(n => parseInt(n));
        for (let i = 0; i < Math.max(currentParts.length, latestParts.length); i++) {
            const currentPart = currentParts[i] || 0;
            const latestPart = latestParts[i] || 0;
            if (latestPart > currentPart)
                return true;
            if (latestPart < currentPart)
                return false;
        }
        return false;
    }
    async detectInstallMethod() {
        try {
            // Check if dmux is globally installed and how
            // Method 1: Check npm global packages
            try {
                const npmGlobals = execSync('npm list -g --depth=0', {
                    encoding: 'utf-8',
                    stdio: 'pipe'
                });
                if (npmGlobals.includes(\`\${packageJson.name}@\`)) {
                    return { packageManager: 'npm', installMethod: 'global' };
                }
            }
            catch { }
            // Method 2: Check pnpm global packages
            try {
                const pnpmGlobals = execSync('pnpm list -g --depth=0', {
                    encoding: 'utf-8',
                    stdio: 'pipe'
                });
                if (pnpmGlobals.includes(\`\${packageJson.name}@\`)) {
                    return { packageManager: 'pnpm', installMethod: 'global' };
                }
            }
            catch { }
            // Method 3: Check yarn global packages
            try {
                const yarnGlobals = execSync('yarn global list --depth=0', {
                    encoding: 'utf-8',
                    stdio: 'pipe'
                });
                if (yarnGlobals.includes(\`\${packageJson.name}@\`)) {
                    return { packageManager: 'yarn', installMethod: 'global' };
                }
            }
            catch { }
            // Method 4: Check where dmux is installed by looking at the executable path
            try {
                const dmuxPath = execSync('which dmux', {
                    encoding: 'utf-8',
                    stdio: 'pipe'
                }).trim();
                if (dmuxPath.includes('/.npm/') || dmuxPath.includes('/npm/')) {
                    return { packageManager: 'npm', installMethod: 'global' };
                }
                else if (dmuxPath.includes('/.pnpm/')) {
                    return { packageManager: 'pnpm', installMethod: 'global' };
                }
                else if (dmuxPath.includes('/.yarn/')) {
                    return { packageManager: 'yarn', installMethod: 'global' };
                }
                else if (dmuxPath.includes('/node_modules/.bin/')) {
                    // Local installation
                    return { packageManager: null, installMethod: 'local' };
                }
            }
            catch { }
            return { packageManager: null, installMethod: 'unknown' };
        }
        catch {
            return { packageManager: null, installMethod: 'unknown' };
        }
    }
    async checkForUpdates() {
        const latestVersion = await this.getLatestVersion();
        const currentVersion = packageJson.version;
        const { packageManager, installMethod } = await this.detectInstallMethod();
        const hasUpdate = latestVersion ? this.compareVersions(currentVersion, latestVersion) : false;
        // Update last check time
        const settings = await this.loadSettings();
        settings.lastCheckTime = Date.now();
        await this.saveSettings(settings);
        return {
            currentVersion,
            latestVersion: latestVersion || 'unknown',
            hasUpdate,
            packageManager,
            installMethod
        };
    }
    async performUpdate(updateInfo) {
        if (!updateInfo.hasUpdate || !updateInfo.packageManager || updateInfo.installMethod !== 'global') {
            return false;
        }
        try {
            let updateCommand;
            switch (updateInfo.packageManager) {
                case 'npm':
                    updateCommand = \`npm update -g \${packageJson.name}\`;
                    break;
                case 'pnpm':
                    updateCommand = \`pnpm update -g \${packageJson.name}\`;
                    break;
                case 'yarn':
                    updateCommand = \`yarn global upgrade \${packageJson.name}\`;
                    break;
                default:
                    return false;
            }
            // Run the update command with a timeout
            execSync(updateCommand, {
                stdio: 'pipe',
                timeout: 60000 // 1 minute timeout
            });
            // Verify the update was successful
            const newUpdateInfo = await this.checkForUpdates();
            return newUpdateInfo.currentVersion === updateInfo.latestVersion;
        }
        catch {
            return false;
        }
    }
    async skipVersion(version) {
        const settings = await this.loadSettings();
        settings.skipVersion = version;
        await this.saveSettings(settings);
    }
    async shouldShowUpdateNotification(updateInfo) {
        if (!updateInfo.hasUpdate) {
            return false;
        }
        const settings = await this.loadSettings();
        // Don't show if user has disabled auto-updates
        if (settings.autoUpdateEnabled === false) {
            return false;
        }
        // Don't show if user has skipped this version
        if (settings.skipVersion === updateInfo.latestVersion) {
            return false;
        }
        return true;
    }
    async setAutoUpdateEnabled(enabled) {
        const settings = await this.loadSettings();
        settings.autoUpdateEnabled = enabled;
        await this.saveSettings(settings);
    }
}
//# sourceMappingURL=AutoUpdater.js.map`,
    mimeType: 'application/javascript',
    size: 8790
  },
  'BetterTextInput.js': {
    content: `import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useFocus } from 'ink';
import TextInput from 'ink-text-input';
const BetterTextInput = ({ value, onChange, onSubmit, placeholder = 'Type your message...' }) => {
    const { isFocused } = useFocus({ autoFocus: true });
    const [isMultiline, setIsMultiline] = useState(false);
    const [cursorPosition, setCursorPosition] = useState(value.length);
    // Update multiline state based on content
    useEffect(() => {
        setIsMultiline(value.includes('\\n'));
        if (cursorPosition > value.length) {
            setCursorPosition(value.length);
        }
    }, [value, cursorPosition]);
    useInput((input, key) => {
        if (!isFocused)
            return;
        // Handle Enter in single-line mode to switch to multiline
        if (!isMultiline && key.return && !key.shift) {
            const before = value.slice(0, cursorPosition);
            const after = value.slice(cursorPosition);
            onChange(before + '\\n' + after);
            setCursorPosition(cursorPosition + 1);
            return;
        }
        // Rest of handlers only for multiline mode
        if (!isMultiline)
            return;
        // Handle escape
        if (key.escape) {
            onChange('');
            setCursorPosition(0);
            return;
        }
        // Handle submit
        if (key.return && key.shift) {
            onSubmit?.();
            return;
        }
        // Handle enter (new line)
        if (key.return) {
            const before = value.slice(0, cursorPosition);
            const after = value.slice(cursorPosition);
            onChange(before + '\\n' + after);
            setCursorPosition(cursorPosition + 1);
            return;
        }
        // Handle backspace - delete character BEFORE cursor
        if (key.backspace) {
            if (cursorPosition > 0) {
                const before = value.slice(0, cursorPosition - 1);
                const after = value.slice(cursorPosition);
                const newValue = before + after;
                onChange(newValue);
                setCursorPosition(cursorPosition - 1);
                // Debug logging
                if (process.env.DEBUG_DMUX) {
                    console.error('Backspace debug:', {
                        oldValue: value,
                        newValue,
                        cursorPos: cursorPosition,
                        newCursorPos: cursorPosition - 1,
                        deletedChar: value[cursorPosition - 1]
                    });
                }
            }
            return;
        }
        // Handle delete - delete character AT cursor
        if (key.delete) {
            if (cursorPosition < value.length) {
                const before = value.slice(0, cursorPosition);
                const after = value.slice(cursorPosition + 1);
                onChange(before + after);
                // cursor stays same
            }
            return;
        }
        // Handle arrows
        if (key.leftArrow) {
            setCursorPosition(Math.max(0, cursorPosition - 1));
            return;
        }
        if (key.rightArrow) {
            setCursorPosition(Math.min(value.length, cursorPosition + 1));
            return;
        }
        if (key.upArrow || key.downArrow) {
            const lines = value.split('\\n');
            let pos = 0;
            let lineIdx = 0;
            let col = 0;
            // Find current line and column
            for (let i = 0; i < lines.length; i++) {
                if (pos + lines[i].length >= cursorPosition) {
                    lineIdx = i;
                    col = cursorPosition - pos;
                    break;
                }
                pos += lines[i].length + 1;
            }
            if (key.upArrow && lineIdx > 0) {
                // Move to previous line
                const targetLine = lineIdx - 1;
                const targetCol = Math.min(col, lines[targetLine].length);
                let newPos = 0;
                for (let i = 0; i < targetLine; i++) {
                    newPos += lines[i].length + 1;
                }
                newPos += targetCol;
                setCursorPosition(newPos);
            }
            else if (key.downArrow && lineIdx < lines.length - 1) {
                // Move to next line
                const targetLine = lineIdx + 1;
                const targetCol = Math.min(col, lines[targetLine].length);
                let newPos = 0;
                for (let i = 0; i < targetLine; i++) {
                    newPos += lines[i].length + 1;
                }
                newPos += targetCol;
                setCursorPosition(newPos);
            }
            return;
        }
        // Handle text input
        if (input && !key.ctrl && !key.meta) {
            const before = value.slice(0, cursorPosition);
            const after = value.slice(cursorPosition);
            onChange(before + input + after);
            setCursorPosition(cursorPosition + input.length);
        }
    });
    // For single line, use standard TextInput but handle Enter ourselves
    if (!isMultiline) {
        return (React.createElement(Box, null,
            React.createElement(Text, null, '> '),
            React.createElement(TextInput, { value: value, onChange: (newValue) => {
                    onChange(newValue);
                    setCursorPosition(newValue.length);
                }, onSubmit: onSubmit, placeholder: placeholder, showCursor: true })));
    }
    // For multiline, render custom display
    const lines = value.split('\\n');
    let pos = 0;
    let cursorLine = 0;
    let cursorCol = 0;
    // Find cursor position in lines
    for (let i = 0; i < lines.length; i++) {
        const lineLength = lines[i].length;
        if (pos + lineLength >= cursorPosition) {
            cursorLine = i;
            cursorCol = cursorPosition - pos;
            break;
        }
        pos += lineLength + 1; // +1 for newline
    }
    return (React.createElement(Box, { flexDirection: "column" }, lines.map((line, idx) => {
        const isFirst = idx === 0;
        const hasCursor = idx === cursorLine;
        if (hasCursor) {
            const before = line.slice(0, cursorCol);
            const at = line[cursorCol] || ' ';
            const after = line.slice(cursorCol + 1);
            return (React.createElement(Box, { key: idx },
                React.createElement(Text, null, isFirst ? '> ' : '  '),
                React.createElement(Text, null, before),
                React.createElement(Text, { inverse: true }, at),
                React.createElement(Text, null, after)));
        }
        return (React.createElement(Box, { key: idx },
            React.createElement(Text, null, isFirst ? '> ' : '  '),
            React.createElement(Text, null, line || ' ')));
    })));
};
export default BetterTextInput;
//# sourceMappingURL=BetterTextInput.js.map`,
    mimeType: 'application/javascript',
    size: 6992
  },
  'CleanTextInput.js': {
    content: `import React, { useState, useEffect, useMemo } from 'react';
import { Box, Text, useInput, useFocus, useStdout } from 'ink';
const CleanTextInput = ({ value, onChange, onSubmit, placeholder = '' }) => {
    const { isFocused } = useFocus({ autoFocus: true });
    const [cursor, setCursor] = useState(value.length);
    const { stdout } = useStdout();
    const [pastedItems, setPastedItems] = useState(new Map());
    const [nextPasteId, setNextPasteId] = useState(1);
    const [isProcessingPaste, setIsProcessingPaste] = useState(false);
    // Only ignore first input in production (not in tests)
    // Check for common test environment indicators
    const isTestEnvironment = process.env.NODE_ENV === 'test' ||
        process.env.VITEST === 'true' ||
        typeof process.env.VITEST !== 'undefined';
    const [ignoreNextInput, setIgnoreNextInput] = useState(!isTestEnvironment);
    // Paste buffering state
    const [pasteBuffer, setPasteBuffer] = useState('');
    const [isPasting, setIsPasting] = useState(false);
    const [pasteTimeout, setPasteTimeout] = useState(null);
    const [inBracketedPaste, setInBracketedPaste] = useState(false);
    // Calculate available width for text (terminal width - borders - padding - prompt)
    // Subtract 2 for borders, 2 for padding, 2 for "> " prompt = 6 total
    // The prompt is always rendered separately, so we need to account for it
    // Use process.stdout.columns as fallback since useStdout might not update
    const terminalWidth = process.stdout.columns || (stdout ? stdout.columns : 80);
    // Reduce by 1 more to prevent edge case where text exactly fills width
    const maxWidth = Math.max(20, terminalWidth - 7);
    // Keep cursor in bounds
    useEffect(() => {
        if (cursor > value.length) {
            setCursor(value.length);
        }
        else if (cursor < 0) {
            setCursor(0);
        }
    }, [value.length, cursor]);
    // Enable bracketed paste mode with small delay to avoid blocking UI
    useEffect(() => {
        let bracketedPasteTimer = null;
        if (isFocused) {
            // Small delay to let UI settle before enabling bracketed paste
            bracketedPasteTimer = setTimeout(() => {
                process.stdout.write('\\x1b[?2004h');
            }, 10);
            // Clear the ignore flag after a short delay to allow normal input
            // In tests, the flag is already false, so no need to clear it
            if (!isTestEnvironment) {
                setTimeout(() => {
                    setIgnoreNextInput(false);
                }, 50);
            }
        }
        return () => {
            if (bracketedPasteTimer) {
                clearTimeout(bracketedPasteTimer);
            }
            process.stdout.write('\\x1b[?2004l');
            // Clean up paste timeout if component unmounts
            if (pasteTimeout) {
                clearTimeout(pasteTimeout);
            }
        };
    }, [isFocused, pasteTimeout]);
    // Preprocess pasted content to remove formatting artifacts
    const preprocessPastedContent = (input) => {
        // Remove ANSI escape sequences (colors, cursor movements, etc)
        let cleaned = input.replace(/\\x1b\\[[0-9;]*m/g, ''); // Remove color codes
        cleaned = cleaned.replace(/\\x1b\\[[\\d;]*[A-Za-z]/g, ''); // Remove cursor movements
        // Normalize line endings
        cleaned = cleaned.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');
        // Check if this looks like code/JSON (has braces, brackets, or consistent indentation)
        const looksLikeCode = cleaned.match(/[{}\\[\\]]/) ||
            cleaned.split('\\n').some(line => line.startsWith('  ') || line.startsWith('\\t'));
        if (looksLikeCode) {
            // For code/JSON, preserve formatting exactly
            return cleaned;
        }
        // For regular text, do more aggressive cleaning
        // Remove box drawing characters
        const boxChars = /[╭╮╰╯│─┌┐└┘├┤┬┴┼━┃┏┓┗┛┣┫┳┻╋]/g;
        cleaned = cleaned.replace(boxChars, '');
        // Split into lines for processing
        let lines = cleaned.split('\\n');
        // Remove common prompt patterns and clean each line
        lines = lines.map(line => {
            // Remove leading prompt indicators
            line = line.replace(/^[>$#]\\s+/, '');
            // Trim whitespace
            return line.trim();
        });
        // Remove empty lines at start and end
        while (lines.length > 0 && lines[0] === '')
            lines.shift();
        while (lines.length > 0 && lines[lines.length - 1] === '')
            lines.pop();
        // Handle wrapped lines (lines that were split by terminal width)
        const unwrappedLines = [];
        for (let i = 0; i < lines.length; i++) {
            const currentLine = lines[i];
            const nextLine = lines[i + 1];
            // If current line doesn't end with punctuation and next line starts lowercase,
            // it's likely a wrapped line
            if (nextLine &&
                currentLine.length > 0 &&
                !currentLine.match(/[.!?;:,]$/) &&
                nextLine[0] &&
                nextLine[0] === nextLine[0].toLowerCase()) {
                // Join wrapped lines
                unwrappedLines.push(currentLine + ' ' + nextLine);
                i++; // Skip next line since we merged it
            }
            else {
                unwrappedLines.push(currentLine);
            }
        }
        return unwrappedLines.join('\\n');
    };
    // Expand paste references to their actual content
    const expandPasteReferences = (text) => {
        let expanded = text;
        const tagPattern = /\\[#(\\d+) Pasted, \\d+ lines?\\]/g;
        let match;
        while ((match = tagPattern.exec(text)) !== null) {
            const pasteId = parseInt(match[1]);
            const pastedContent = pastedItems.get(pasteId);
            if (pastedContent) {
                expanded = expanded.replace(match[0], pastedContent.content);
            }
        }
        return expanded;
    };
    // Process complete pasted content once buffering is done
    const processPastedContent = (fullContent) => {
        // Always preprocess pasted content
        const cleaned = preprocessPastedContent(fullContent);
        const lines = cleaned.split('\\n');
        if (lines.length > 15) {
            // Large paste - create reference tag
            const pasteId = nextPasteId;
            const pasteRef = {
                id: pasteId,
                content: cleaned,
                lineCount: lines.length,
                timestamp: Date.now()
            };
            setPastedItems(prev => {
                const newMap = new Map(prev);
                newMap.set(pasteId, pasteRef);
                return newMap;
            });
            setNextPasteId(pasteId + 1);
            // Insert reference tag
            const tag = \`[#\${pasteId} Pasted, \${lines.length} lines]\`;
            const before = value.slice(0, cursor);
            const after = value.slice(cursor);
            onChange(before + tag + after);
            setCursor(cursor + tag.length);
        }
        else {
            // Small paste - insert cleaned content directly
            const before = value.slice(0, cursor);
            const after = value.slice(cursor);
            onChange(before + cleaned + after);
            setCursor(cursor + cleaned.length);
        }
        // Reset paste state
        setPasteBuffer('');
        setIsPasting(false);
        setInBracketedPaste(false);
    };
    useInput((input, key) => {
        if (!isFocused)
            return;
        // Escape clears
        if (key.escape) {
            onChange('');
            setCursor(0);
            return;
        }
        // Shift+Enter adds newline
        if (key.return && key.shift) {
            const before = value.slice(0, cursor);
            const after = value.slice(cursor);
            const newValue = before + '\\n' + after;
            onChange(newValue);
            setCursor(cursor + 1);
            return;
        }
        // Enter submits with expanded content
        if (key.return) {
            const expandedValue = expandPasteReferences(value);
            onSubmit?.(expandedValue);
            return;
        }
        // Backspace deletes BEFORE cursor
        // IMPORTANT: Some terminals send 'delete' key when backspace is pressed
        // Handle both key.backspace and key.delete as backspace
        if (key.backspace || key.delete || input === '\\x7f' || input === '\\x08') {
            // Clear any paste state when delete is pressed
            if (isPasting) {
                setIsPasting(false);
                setPasteBuffer('');
                if (pasteTimeout) {
                    clearTimeout(pasteTimeout);
                    setPasteTimeout(null);
                }
            }
            if (cursor > 0) {
                const before = value.slice(0, cursor - 1);
                const after = value.slice(cursor);
                const newValue = before + after;
                onChange(newValue);
                setCursor(cursor - 1);
            }
            return;
        }
        // Forward delete (actual delete key behavior) - removed since we're treating delete as backspace
        // If you need forward delete, use a different key combination
        // Ctrl-A: Jump to beginning of current visual line
        if (key.ctrl && input === 'a') {
            const wrapped = wrapText(value, maxWidth);
            const currentPos = findCursorInWrappedLines(wrapped, cursor);
            // Find absolute position of start of current visual line
            let absolutePos = 0;
            for (let i = 0; i < currentPos.line; i++) {
                absolutePos += wrapped[i].line.length;
                if (!wrapped[i].isHardBreak && i < wrapped.length - 1) {
                    absolutePos++; // Space between wrapped segments
                }
                else if (wrapped[i].isHardBreak) {
                    absolutePos++; // Newline character
                }
            }
            setCursor(absolutePos);
            return;
        }
        // Ctrl-E: Jump to end of current visual line
        if (key.ctrl && input === 'e') {
            const wrapped = wrapText(value, maxWidth);
            const currentPos = findCursorInWrappedLines(wrapped, cursor);
            // Find absolute position of end of current visual line
            let absolutePos = 0;
            for (let i = 0; i <= currentPos.line; i++) {
                if (i === currentPos.line) {
                    absolutePos += wrapped[i].line.length;
                }
                else {
                    absolutePos += wrapped[i].line.length;
                    if (!wrapped[i].isHardBreak && i < wrapped.length - 1) {
                        absolutePos++; // Space between wrapped segments
                    }
                    else if (wrapped[i].isHardBreak) {
                        absolutePos++; // Newline character
                    }
                }
            }
            setCursor(Math.min(absolutePos, value.length));
            return;
        }
        // Left arrow
        if (key.leftArrow) {
            setCursor(Math.max(0, cursor - 1));
            return;
        }
        // Right arrow
        if (key.rightArrow) {
            setCursor(Math.min(value.length, cursor + 1));
            return;
        }
        // Up/Down arrows for navigation (works with both hard and soft wrapped lines)
        if (key.upArrow || key.downArrow) {
            // Get wrapped lines to understand visual layout
            const wrapped = wrapText(value, maxWidth);
            const currentPos = findCursorInWrappedLines(wrapped, cursor);
            if (key.upArrow && currentPos.line > 0) {
                // Move up one visual line
                const targetLine = currentPos.line - 1;
                const targetCol = Math.min(currentPos.col, wrapped[targetLine].line.length);
                // Convert back to absolute position
                let absolutePos = 0;
                for (let i = 0; i < targetLine; i++) {
                    absolutePos += wrapped[i].line.length;
                    // Add space if this was a soft wrap
                    if (!wrapped[i].isHardBreak && i < wrapped.length - 1) {
                        const nextLineExists = i + 1 < wrapped.length;
                        if (nextLineExists)
                            absolutePos++; // Space between wrapped segments
                    }
                    else if (wrapped[i].isHardBreak) {
                        absolutePos++; // Newline character
                    }
                }
                absolutePos += targetCol;
                setCursor(Math.min(absolutePos, value.length));
            }
            else if (key.downArrow && currentPos.line < wrapped.length - 1) {
                // Move down one visual line
                const targetLine = currentPos.line + 1;
                const targetCol = Math.min(currentPos.col, wrapped[targetLine].line.length);
                // Convert back to absolute position
                let absolutePos = 0;
                for (let i = 0; i < targetLine; i++) {
                    absolutePos += wrapped[i].line.length;
                    // Add space if this was a soft wrap
                    if (!wrapped[i].isHardBreak && i < wrapped.length - 1) {
                        const nextLineExists = i + 1 < wrapped.length;
                        if (nextLineExists)
                            absolutePos++; // Space between wrapped segments
                    }
                    else if (wrapped[i].isHardBreak) {
                        absolutePos++; // Newline character
                    }
                }
                absolutePos += targetCol;
                setCursor(Math.min(absolutePos, value.length));
            }
            return;
        }
        // Regular text input with paste detection and buffering
        if (input && !key.ctrl && !key.meta) {
            // Ignore the first character input if flag is set (prevents 'n' from dmux menu)
            if (ignoreNextInput && input.length === 1) {
                setIgnoreNextInput(false);
                return;
            }
            // First, check if this looks like a malformed paste sequence we should ignore
            // Pattern: [200- or [201- followed by content (missing the ~)
            if (input.startsWith('[200-') || input.startsWith('[201-')) {
                // This is a malformed paste marker - strip it and process the rest as normal content
                const cleanedInput = input.replace(/^\\[20[01]-/, '');
                if (cleanedInput) {
                    // Process as a regular paste if it has content
                    const hasNewlines = cleanedInput.includes('\\n');
                    const isVeryLong = cleanedInput.length > 10;
                    if (hasNewlines || isVeryLong) {
                        processPastedContent(cleanedInput);
                        return;
                    }
                    // Otherwise treat as normal input
                    const before = value.slice(0, cursor);
                    const after = value.slice(cursor);
                    onChange(before + cleanedInput + after);
                    setCursor(cursor + cleanedInput.length);
                }
                return;
            }
            // Detect bracketed paste sequences - handle multiple formats
            const PASTE_START = '\\x1b[200~';
            const PASTE_END = '\\x1b[201~';
            // Also check for the pattern without escape char (some terminals strip it)
            const PASTE_START_ALT = '[200~';
            const PASTE_END_ALT = '[201~';
            // Check for bracketed paste markers (both formats)
            const hasPasteStart = input.includes(PASTE_START) || input.includes(PASTE_START_ALT);
            const hasPasteEnd = input.includes(PASTE_END) || input.includes(PASTE_END_ALT);
            // Handle bracketed paste mode
            if (hasPasteStart) {
                setInBracketedPaste(true);
                // Extract content after paste start marker (check both formats)
                let startIdx = -1;
                let markerLength = 0;
                if (input.includes(PASTE_START)) {
                    startIdx = input.indexOf(PASTE_START);
                    markerLength = PASTE_START.length;
                }
                else if (input.includes(PASTE_START_ALT)) {
                    startIdx = input.indexOf(PASTE_START_ALT);
                    markerLength = PASTE_START_ALT.length;
                }
                let endIdx = -1;
                if (hasPasteEnd) {
                    if (input.includes(PASTE_END)) {
                        endIdx = input.indexOf(PASTE_END);
                    }
                    else if (input.includes(PASTE_END_ALT)) {
                        endIdx = input.indexOf(PASTE_END_ALT);
                    }
                }
                const content = hasPasteEnd ?
                    input.substring(startIdx + markerLength, endIdx) :
                    input.substring(startIdx + markerLength);
                setPasteBuffer(content);
                if (hasPasteEnd) {
                    // Complete paste in single chunk
                    processPastedContent(pasteBuffer + content);
                    setPasteBuffer('');
                    setInBracketedPaste(false);
                }
                return;
            }
            if (hasPasteEnd && inBracketedPaste) {
                // End of bracketed paste - check both formats
                let endIdx = -1;
                if (input.includes(PASTE_END)) {
                    endIdx = input.indexOf(PASTE_END);
                }
                else if (input.includes(PASTE_END_ALT)) {
                    endIdx = input.indexOf(PASTE_END_ALT);
                }
                if (endIdx >= 0) {
                    const finalContent = input.substring(0, endIdx);
                    processPastedContent(pasteBuffer + finalContent);
                    setPasteBuffer('');
                    setInBracketedPaste(false);
                    return;
                }
            }
            if (inBracketedPaste) {
                // Continue buffering bracketed paste content
                setPasteBuffer(prev => prev + input);
                return;
            }
            // Detect non-bracketed paste (fallback for terminals without bracketed paste mode)
            // Exclude delete/backspace key sequences from paste detection
            const isDeleteSequence = input === '\\x7f' || input === '\\x08' ||
                input.split('').every(c => c === '\\x7f' || c === '\\x08');
            // Better heuristics for paste detection:
            // - Must have newlines OR be quite long (>10 chars at once)
            // - Single chars or small groups (2-3) are likely fast typing
            // - Already in paste mode should continue
            const hasNewlines = input.includes('\\n');
            const isVeryLong = input.length > 10;
            const isLikelyPaste = !isDeleteSequence && ((hasNewlines && input.length > 2) || // Multi-line content
                isVeryLong || // Very long single chunk
                (isPasting && input.length > 0)); // Continue existing paste
            if (isLikelyPaste && !inBracketedPaste) {
                // Clear any existing timeout
                if (pasteTimeout) {
                    clearTimeout(pasteTimeout);
                }
                // Add to paste buffer
                setPasteBuffer(prev => prev + input);
                setIsPasting(true);
                // Set timeout to detect end of paste (when no more input arrives)
                const timeout = setTimeout(() => {
                    // Process the complete buffered paste
                    if (pasteBuffer || input) {
                        processPastedContent(pasteBuffer + input);
                    }
                    setPasteBuffer('');
                    setIsPasting(false);
                }, 100); // 100ms timeout to collect all chunks
                setPasteTimeout(timeout);
                return;
            }
            // Normal single character input (or fast typing)
            if (!isPasting && !inBracketedPaste) {
                const before = value.slice(0, cursor);
                const after = value.slice(cursor);
                onChange(before + input + after);
                setCursor(cursor + input.length);
            }
            else if (isPasting && !isLikelyPaste && !inBracketedPaste) {
                // If we're in paste mode but this doesn't look like a paste,
                // it's probably just fast typing - cancel paste mode
                if (pasteTimeout) {
                    clearTimeout(pasteTimeout);
                    setPasteTimeout(null);
                }
                setPasteBuffer('');
                setIsPasting(false);
                // Process as normal input
                const before = value.slice(0, cursor);
                const after = value.slice(cursor);
                onChange(before + input + after);
                setCursor(cursor + input.length);
            }
        }
    });
    // Function to wrap text at word boundaries
    const wrapText = (text, width) => {
        if (!text)
            return [{ line: '', isHardBreak: false }];
        const hardLines = text.split('\\n');
        const wrappedLines = [];
        for (let i = 0; i < hardLines.length; i++) {
            const hardLine = hardLines[i];
            const isLastHardLine = i === hardLines.length - 1;
            if (hardLine.length <= width) {
                // Line fits within width
                wrappedLines.push({ line: hardLine, isHardBreak: !isLastHardLine });
            }
            else {
                // Need to wrap this line at word boundaries
                let remaining = hardLine;
                while (remaining.length > 0) {
                    if (remaining.length <= width) {
                        // Last segment of this hard line
                        wrappedLines.push({
                            line: remaining,
                            isHardBreak: !isLastHardLine
                        });
                        break;
                    }
                    // Find last space within width limit
                    let breakPoint = width;
                    // Look for the last space that fits within the width - 1 to wrap before overflow
                    let lastSpace = remaining.lastIndexOf(' ', width - 1);
                    if (lastSpace > 0) {
                        // Found a space to break at
                        breakPoint = lastSpace;
                    }
                    else {
                        // No good space found, break at width or look for first space
                        const firstSpace = remaining.indexOf(' ');
                        if (firstSpace > 0 && firstSpace < width) {
                            breakPoint = firstSpace;
                        }
                        else {
                            // No spaces or space is beyond width, break at width
                            breakPoint = Math.min(width, remaining.length);
                        }
                    }
                    const segment = remaining.slice(0, breakPoint);
                    wrappedLines.push({
                        line: segment.trimEnd(),
                        isHardBreak: false // soft wrap
                    });
                    // Skip the space if we broke at a space
                    const nextChar = remaining[breakPoint];
                    if (nextChar === ' ') {
                        remaining = remaining.slice(breakPoint + 1);
                    }
                    else {
                        remaining = remaining.slice(breakPoint);
                    }
                }
            }
        }
        return wrappedLines;
    };
    // Function to find cursor position in wrapped lines
    const findCursorInWrappedLines = (wrappedLines, absoluteCursor) => {
        if (wrappedLines.length === 0) {
            return { line: 0, col: 0 };
        }
        let currentPos = 0;
        // Walk through each wrapped line and track character positions
        for (let lineIndex = 0; lineIndex < wrappedLines.length; lineIndex++) {
            const wrappedLine = wrappedLines[lineIndex];
            const lineLength = wrappedLine.line.length;
            // Check if cursor is within this wrapped line
            if (absoluteCursor <= currentPos + lineLength) {
                const colInLine = absoluteCursor - currentPos;
                return {
                    line: lineIndex,
                    col: Math.max(0, Math.min(colInLine, lineLength))
                };
            }
            // Move past this line's characters
            currentPos += lineLength;
            // Add 1 for newline character if this is a hard break
            if (wrappedLine.isHardBreak) {
                currentPos++;
                // Check if cursor is exactly at the newline position
                if (absoluteCursor === currentPos - 1) {
                    return {
                        line: lineIndex,
                        col: lineLength
                    };
                }
            }
            // For soft breaks (word wrapping), account for the space that was removed
            else if (lineIndex < wrappedLines.length - 1) {
                // Add 1 for the space that was trimmed during word wrapping
                currentPos++;
                // Check if cursor is at the space position
                if (absoluteCursor === currentPos - 1) {
                    return {
                        line: lineIndex,
                        col: lineLength
                    };
                }
            }
        }
        // Cursor is at the very end
        const lastLine = wrappedLines[wrappedLines.length - 1];
        return {
            line: wrappedLines.length - 1,
            col: lastLine ? lastLine.line.length : 0
        };
    };
    // Helper to render text with highlighted paste tags
    const renderTextWithTags = (text, isInverse = false) => {
        const tagPattern = /(\\[#\\d+ Pasted, \\d+ lines?\\])/g;
        const parts = text.split(tagPattern);
        return parts.map((part, i) => {
            if (part.match(tagPattern)) {
                // Render paste tag with special styling
                return React.createElement(Text, { key: i, color: "cyan", dimColor: true }, part);
            }
            // Regular text
            return isInverse ? React.createElement(Text, { key: i, inverse: true }, part) : React.createElement(Text, { key: i }, part);
        });
    };
    // Memoize wrapped text to avoid recalculating on every render
    const wrappedLines = useMemo(() => wrapText(value, maxWidth), [value, maxWidth]);
    const hasMultipleLines = wrappedLines.length > 1;
    if (value === '') {
        // Show cursor for empty input (no placeholder)
        return (React.createElement(Box, null,
            React.createElement(Box, { width: 2 },
                React.createElement(Text, null, '> ')),
            React.createElement(Box, null,
                React.createElement(Text, { inverse: true }, ' '))));
    }
    // Find cursor position in wrapped lines
    const cursorPos = findCursorInWrappedLines(wrappedLines, cursor);
    // Render wrapped lines
    return (React.createElement(Box, { flexDirection: "column" }, wrappedLines.map((wrappedLine, idx) => {
        const isFirst = idx === 0;
        const hasCursor = idx === cursorPos.line;
        const line = wrappedLine.line;
        if (hasCursor) {
            // Ensure cursor position is valid
            const actualCol = Math.min(cursorPos.col, line.length);
            const before = line.slice(0, actualCol);
            const at = line[actualCol] || ' ';
            const after = line.slice(actualCol + 1);
            // Check if cursor is within a paste tag
            const tagPattern = /\\[#\\d+ Pasted, \\d+ lines?\\]/g;
            let match;
            let cursorInTag = false;
            while ((match = tagPattern.exec(line)) !== null) {
                if (actualCol >= match.index && actualCol < match.index + match[0].length) {
                    cursorInTag = true;
                    break;
                }
            }
            return (React.createElement(Box, { key: idx },
                React.createElement(Box, { width: 2 },
                    React.createElement(Text, null, isFirst ? '> ' : '  ')),
                React.createElement(Box, null, cursorInTag ? (
                // Cursor is within a paste tag - render specially
                React.createElement(React.Fragment, null,
                    renderTextWithTags(before),
                    React.createElement(Text, { inverse: true, color: "cyan" }, at),
                    renderTextWithTags(after))) : (
                // Normal rendering with tag highlighting
                React.createElement(React.Fragment, null,
                    renderTextWithTags(before),
                    React.createElement(Text, { inverse: true }, at),
                    renderTextWithTags(after))))));
        }
        return (React.createElement(Box, { key: idx },
            React.createElement(Box, { width: 2 },
                React.createElement(Text, null, isFirst ? '> ' : '  ')),
            React.createElement(Box, null, line ? renderTextWithTags(line) : React.createElement(Text, null, ' '))));
    })));
};
export default CleanTextInput;
//# sourceMappingURL=CleanTextInput.js.map`,
    mimeType: 'application/javascript',
    size: 29918
  },
  'DmuxApp.js': {
    content: `import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useApp } from 'ink';
import { execSync } from 'child_process';
import path from 'path';
import { createRequire } from 'module';
// Hooks
import usePanes from './hooks/usePanes.js';
import useProjectSettings from './hooks/useProjectSettings.js';
import useTerminalWidth from './hooks/useTerminalWidth.js';
import useNavigation from './hooks/useNavigation.js';
import useAutoUpdater from './hooks/useAutoUpdater.js';
import useAgentDetection from './hooks/useAgentDetection.js';
import useAgentStatus from './hooks/useAgentStatus.js';
import usePaneRunner from './hooks/usePaneRunner.js';
import usePaneCreation from './hooks/usePaneCreation.js';
import useActionSystem from './hooks/useActionSystem.js';
// Utils
import { applySmartLayout } from './utils/tmux.js';
import { suggestCommand } from './utils/commands.js';
import { generateSlug } from './utils/slug.js';
import { getMainBranch } from './utils/git.js';
import { StateManager } from './shared/StateManager.js';
import { getStatusDetector } from './services/StatusDetector.js';
import { PaneAction } from './actions/index.js';
const require = createRequire(import.meta.url);
const packageJson = require('../package.json');
import PanesGrid from './components/PanesGrid.js';
import NewPaneDialog from './components/NewPaneDialog.js';
import AgentChoiceDialog from './components/AgentChoiceDialog.js';
import CommandPromptDialog from './components/CommandPromptDialog.js';
import FileCopyPrompt from './components/FileCopyPrompt.js';
import LoadingIndicator from './components/LoadingIndicator.js';
import RunningIndicator from './components/RunningIndicator.js';
import UpdatingIndicator from './components/UpdatingIndicator.js';
import CreatingIndicator from './components/CreatingIndicator.js';
import FooterHelp from './components/FooterHelp.js';
import QRCode from './components/QRCode.js';
import KebabMenu from './components/KebabMenu.js';
import ActionChoiceDialog from './components/ActionChoiceDialog.js';
import ActionConfirmDialog from './components/ActionConfirmDialog.js';
const DmuxApp = ({ panesFile, projectName, sessionName, settingsFile, autoUpdater, serverPort, server }) => {
    /* panes state moved to usePanes */
    const [selectedIndex, setSelectedIndex] = useState(0);
    const [showNewPaneDialog, setShowNewPaneDialog] = useState(false);
    const [newPanePrompt, setNewPanePrompt] = useState('');
    const [statusMessage, setStatusMessage] = useState('');
    const [isCreatingPane, setIsCreatingPane] = useState(false);
    const [showQRCode, setShowQRCode] = useState(false);
    const [tunnelUrl, setTunnelUrl] = useState(null);
    const [isCreatingTunnel, setIsCreatingTunnel] = useState(false);
    const { projectSettings, saveSettings } = useProjectSettings(settingsFile);
    const [showCommandPrompt, setShowCommandPrompt] = useState(null);
    const [commandInput, setCommandInput] = useState('');
    const [showFileCopyPrompt, setShowFileCopyPrompt] = useState(false);
    const [currentCommandType, setCurrentCommandType] = useState(null);
    const [runningCommand, setRunningCommand] = useState(false);
    const [quitConfirmMode, setQuitConfirmMode] = useState(false);
    const [showKebabMenu, setShowKebabMenu] = useState(false);
    const [kebabMenuPaneIndex, setKebabMenuPaneIndex] = useState(null);
    const [kebabMenuOption, setKebabMenuOption] = useState(0);
    // Update state handled by hook
    const { updateInfo, showUpdateDialog, isUpdating, performUpdate, skipUpdate, dismissUpdate, updateAvailable } = useAutoUpdater(autoUpdater, setStatusMessage);
    const { exit } = useApp();
    // Agent selection state
    const { availableAgents } = useAgentDetection();
    const [showAgentChoiceDialog, setShowAgentChoiceDialog] = useState(false);
    const [agentChoice, setAgentChoice] = useState(null);
    const [pendingPrompt, setPendingPrompt] = useState('');
    // Track terminal dimensions for responsive layout
    const terminalWidth = useTerminalWidth();
    // Panes state and persistence (skipLoading will be updated after actionSystem is initialized)
    const { panes, setPanes, isLoading, loadPanes, savePanes } = usePanes(panesFile, false);
    // Action system
    const actionSystem = useActionSystem({
        panes,
        savePanes,
        sessionName,
        projectName,
        onPaneRemove: (paneId) => {
            const updated = panes.filter(p => p.id !== paneId);
            setPanes(updated);
        },
    });
    // Pane runner
    const { copyNonGitFiles, runCommandInternal, monitorTestOutput, monitorDevOutput, attachBackgroundWindow } = usePaneRunner({
        panes,
        savePanes,
        projectSettings,
        setStatusMessage,
        setRunningCommand,
    });
    // Pane creation
    const { openInEditor: openEditor2, createNewPane: createNewPaneHook } = usePaneCreation({
        panes,
        savePanes,
        projectName,
        setIsCreatingPane,
        setStatusMessage,
        setNewPanePrompt,
        loadPanes,
        panesFile,
        availableAgents,
    });
    // Listen for status updates with analysis data and merge into panes
    useEffect(() => {
        const statusDetector = getStatusDetector();
        const handleStatusUpdate = (event) => {
            setPanes(prevPanes => {
                const updatedPanes = prevPanes.map(pane => {
                    if (pane.id === event.paneId) {
                        const updated = {
                            ...pane,
                            agentStatus: event.status,
                        };
                        // Only update analysis fields if they're present in the event (not undefined)
                        // This prevents simple status changes from overwriting PaneAnalyzer results
                        if (event.optionsQuestion !== undefined) {
                            updated.optionsQuestion = event.optionsQuestion;
                        }
                        if (event.options !== undefined) {
                            updated.options = event.options;
                        }
                        if (event.potentialHarm !== undefined) {
                            updated.potentialHarm = event.potentialHarm;
                        }
                        if (event.summary !== undefined) {
                            updated.agentSummary = event.summary;
                        }
                        // Clear option dialog data when transitioning away from 'waiting' state
                        if (event.status !== 'waiting' && pane.agentStatus === 'waiting') {
                            updated.optionsQuestion = undefined;
                            updated.options = undefined;
                            updated.potentialHarm = undefined;
                        }
                        // Clear summary when transitioning away from 'idle' state
                        if (event.status !== 'idle' && pane.agentStatus === 'idle') {
                            updated.agentSummary = undefined;
                        }
                        return updated;
                    }
                    return pane;
                });
                // Immediately sync to StateManager so API has latest data
                const stateManager = StateManager.getInstance();
                stateManager.updatePanes(updatedPanes);
                // Also persist to disk so changes survive restarts
                savePanes(updatedPanes).catch(err => {
                    console.error('Failed to save panes after status update:', err);
                });
                return updatedPanes;
            });
        };
        statusDetector.on('status-updated', handleStatusUpdate);
        return () => {
            statusDetector.off('status-updated', handleStatusUpdate);
        };
    }, [setPanes, savePanes]);
    // Sync panes with StateManager (for non-status updates)
    useEffect(() => {
        const stateManager = StateManager.getInstance();
        stateManager.updatePanes(panes);
    }, [panes]);
    // Sync settings with StateManager
    useEffect(() => {
        const stateManager = StateManager.getInstance();
        stateManager.updateSettings(projectSettings);
    }, [projectSettings]);
    // Load panes and settings on mount and refresh periodically
    useEffect(() => {
        // SIGTERM should quit immediately (for process management)
        const handleTermination = () => {
            cleanExit();
        };
        process.on('SIGTERM', handleTermination);
        return () => {
            process.removeListener('SIGTERM', handleTermination);
        };
    }, []);
    // Auto-show new pane dialog when starting with no panes
    useEffect(() => {
        // Only show the dialog if:
        // 1. Initial load is complete (!isLoading)
        // 2. We have no panes
        // 3. We're not already showing the dialog
        // 4. We're not showing any other dialogs or prompts
        if (!isLoading &&
            panes.length === 0 &&
            !showNewPaneDialog &&
            !actionSystem.actionState.showConfirmDialog &&
            !actionSystem.actionState.showChoiceDialog &&
            !showCommandPrompt &&
            !showFileCopyPrompt &&
            !showAgentChoiceDialog &&
            !isCreatingPane &&
            !runningCommand &&
            !isUpdating) {
            setShowNewPaneDialog(true);
        }
    }, [isLoading, panes.length, showNewPaneDialog, actionSystem.actionState.showConfirmDialog, actionSystem.actionState.showChoiceDialog, showCommandPrompt, showFileCopyPrompt, showAgentChoiceDialog, isCreatingPane, runningCommand, isUpdating]);
    // Update checking moved to useAutoUpdater
    // Set default agent choice when detection completes
    useEffect(() => {
        if (agentChoice == null && availableAgents.length > 0) {
            setAgentChoice(availableAgents[0] || 'claude');
        }
    }, [availableAgents]);
    // Monitor agent status across panes (returns a map of pane ID to status)
    const agentStatuses = useAgentStatus({
        panes,
        suspend: showNewPaneDialog || actionSystem.actionState.showConfirmDialog || actionSystem.actionState.showChoiceDialog || !!showCommandPrompt || showFileCopyPrompt,
        onPaneRemoved: (paneId) => {
            // Remove pane from list when it no longer exists in tmux
            const updatedPanes = panes.filter(p => p.id !== paneId);
            savePanes(updatedPanes);
        },
    });
    // loadPanes moved to usePanes
    // getPanePositions moved to utils/tmux
    // Navigation logic moved to hook
    const { getCardGridPosition, findCardInDirection } = useNavigation(terminalWidth, panes.length, isLoading);
    // findCardInDirection provided by useNavigation
    // savePanes moved to usePanes
    // applySmartLayout moved to utils/tmux
    const createNewPane = async (prompt, agent) => {
        setIsCreatingPane(true);
        setStatusMessage('Generating slug...');
        const slug = await generateSlug(prompt);
        setStatusMessage(\`Creating worktree: \${slug}...\`);
        // Get git root directory for consistent worktree placement
        let projectRoot;
        try {
            projectRoot = execSync('git rev-parse --show-toplevel', {
                encoding: 'utf-8',
                stdio: 'pipe'
            }).trim();
        }
        catch {
            // Fallback to current directory if not in a git repo
            projectRoot = process.cwd();
        }
        // Create worktree path inside .dmux/worktrees directory
        const worktreePath = path.join(projectRoot, '.dmux', 'worktrees', slug);
        // Get the original pane ID (where dmux is running) before clearing
        const originalPaneId = execSync('tmux display-message -p "#{pane_id}"', { encoding: 'utf-8' }).trim();
        // Multiple clearing strategies to prevent artifacts
        // 1. Clear screen with ANSI codes
        process.stdout.write('\\x1b[2J\\x1b[H');
        // 2. Fill with blank lines to push content off screen
        process.stdout.write('\\n'.repeat(100));
        // 3. Clear tmux history and send clear command
        try {
            execSync('tmux clear-history', { stdio: 'pipe' });
            execSync('tmux send-keys C-l', { stdio: 'pipe' });
        }
        catch { }
        // Wait a bit for clearing to settle
        await new Promise(resolve => setTimeout(resolve, 100));
        // 4. Force tmux to refresh the display
        try {
            execSync('tmux refresh-client', { stdio: 'pipe' });
        }
        catch { }
        // Get current pane count to determine layout
        const paneCount = parseInt(execSync('tmux list-panes | wc -l', { encoding: 'utf-8' }).trim());
        // Enable pane borders to show titles
        try {
            execSync(\`tmux set-option -g pane-border-status top\`, { stdio: 'pipe' });
        }
        catch {
            // Ignore if already set or fails
        }
        // Create new pane
        const paneInfo = execSync(\`tmux split-window -h -P -F '#{pane_id}'\`, { encoding: 'utf-8' }).trim();
        // Wait for pane creation to settle
        await new Promise(resolve => setTimeout(resolve, 500));
        // Set pane title to match the slug
        try {
            execSync(\`tmux select-pane -t '\${paneInfo}' -T "\${slug}"\`, { stdio: 'pipe' });
        }
        catch {
            // Ignore if setting title fails
        }
        // Apply smart layout based on pane count
        const newPaneCount = paneCount + 1;
        applySmartLayout(newPaneCount);
        // Create git worktree and cd into it
        // This MUST happen before launching Claude to ensure we're in the right directory
        try {
            // First, create the worktree and cd into it as a single command
            // Use ; instead of && to ensure cd runs even if worktree already exists
            const worktreeCmd = \`git worktree add "\${worktreePath}" -b \${slug} 2>/dev/null ; cd "\${worktreePath}"\`;
            execSync(\`tmux send-keys -t '\${paneInfo}' '\${worktreeCmd}' Enter\`, { stdio: 'pipe' });
            // Wait longer for worktree creation and cd to complete
            // This is critical - if we don't wait long enough, Claude will start in the wrong directory
            await new Promise(resolve => setTimeout(resolve, 2500));
            // Verify we're in the worktree directory by sending pwd command  
            execSync(\`tmux send-keys -t '\${paneInfo}' 'echo "Worktree created at:" && pwd' Enter\`, { stdio: 'pipe' });
            await new Promise(resolve => setTimeout(resolve, 500));
            setStatusMessage(agent ? \`Worktree created, launching \${agent === 'opencode' ? 'opencode' : 'Claude'}...\` : 'Worktree created.');
        }
        catch (error) {
            // Log error but continue - worktree creation is essential
            setStatusMessage(\`Warning: Worktree issue: \${error}\`);
            // Even if worktree creation failed, try to cd to the directory in case it exists
            execSync(\`tmux send-keys -t '\${paneInfo}' 'cd "\${worktreePath}" 2>/dev/null || (echo "ERROR: Failed to create/enter worktree \${slug}" && pwd)' Enter\`, { stdio: 'pipe' });
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        // Prepare and send the agent command
        let escapedCmd = '';
        if (agent === 'claude') {
            // Claude should always be launched AFTER we're in the worktree directory
            let claudeCmd;
            if (prompt && prompt.trim()) {
                const escapedPrompt = prompt
                    .replace(/\\\\/g, '\\\\\\\\')
                    .replace(/"/g, '\\\\"')
                    .replace(/\`/g, '\\\\\`')
                    .replace(/\\$/g, '\\\\$');
                claudeCmd = \`claude "\${escapedPrompt}" --permission-mode=acceptEdits\`;
            }
            else {
                claudeCmd = \`claude --permission-mode=acceptEdits\`;
            }
            // Send Claude command to new pane
            escapedCmd = claudeCmd.replace(/'/g, "'\\\\''");
            execSync(\`tmux send-keys -t '\${paneInfo}' '\${escapedCmd}'\`, { stdio: 'pipe' });
            execSync(\`tmux send-keys -t '\${paneInfo}' Enter\`, { stdio: 'pipe' });
        }
        else if (agent === 'opencode') {
            // opencode: start the TUI, then paste the prompt and submit
            const openCoderCmd = \`opencode\`;
            const escapedOpenCmd = openCoderCmd.replace(/'/g, "'\\\\''");
            execSync(\`tmux send-keys -t '\${paneInfo}' '\${escapedOpenCmd}'\`, { stdio: 'pipe' });
            execSync(\`tmux send-keys -t '\${paneInfo}' Enter\`, { stdio: 'pipe' });
            if (prompt && prompt.trim()) {
                await new Promise(resolve => setTimeout(resolve, 1500));
                const bufName = \`dmux_prompt_\${Date.now()}\`;
                const promptEsc = prompt.replace(/\\\\/g, '\\\\\\\\').replace(/'/g, "'\\\\''");
                execSync(\`tmux set-buffer -b '\${bufName}' -- '\${promptEsc}'\`, { stdio: 'pipe' });
                execSync(\`tmux paste-buffer -b '\${bufName}' -t '\${paneInfo}'\`, { stdio: 'pipe' });
                await new Promise(resolve => setTimeout(resolve, 200));
                execSync(\`tmux delete-buffer -b '\${bufName}'\`, { stdio: 'pipe' });
                execSync(\`tmux send-keys -t '\${paneInfo}' Enter\`, { stdio: 'pipe' });
            }
        }
        if (agent === 'claude') {
            // Monitor for Claude Code trust prompt and auto-respond
            const autoApproveTrust = async () => {
                // Wait for Claude to start up before checking for prompts
                await new Promise(resolve => setTimeout(resolve, 800));
                const maxChecks = 100; // 100 checks * 100ms = 10 seconds total
                const checkInterval = 100; // Check every 100ms
                let lastContent = '';
                let stableContentCount = 0;
                let promptHandled = false;
                // More comprehensive trust prompt patterns
                const trustPromptPatterns = [
                    /Do you trust the files in this folder\\?/i,
                    /Trust the files in this workspace\\?/i,
                    /Do you trust the authors of the files/i,
                    /Do you want to trust this workspace\\?/i,
                    /trust.*files.*folder/i,
                    /trust.*workspace/i,
                    /Do you trust/i,
                    /Trust this folder/i,
                    /trust.*directory/i,
                    /permission.*grant/i,
                    /allow.*access/i,
                    /workspace.*trust/i,
                    /accept.*edits/i, // Claude's accept edits prompt
                    /permission.*mode/i, // Permission mode prompt
                    /allow.*claude/i, // Allow Claude prompt
                    /\\[y\\/n\\]/i, // Common yes/no prompt pattern
                    /\\(y\\/n\\)/i,
                    /Yes\\/No/i,
                    /\\[Y\\/n\\]/i, // Default yes pattern
                    /press.*enter.*accept/i, // Press enter to accept
                    /press.*enter.*continue/i, // Press enter to continue
                    /❯\\s*1\\.\\s*Yes,\\s*proceed/i, // New Claude numbered menu format
                    /Enter to confirm.*Esc to exit/i, // New Claude confirmation format
                    /1\\.\\s*Yes,\\s*proceed/i, // Yes proceed option
                    /2\\.\\s*No,\\s*exit/i // No exit option
                ];
                for (let i = 0; i < maxChecks; i++) {
                    await new Promise(resolve => setTimeout(resolve, checkInterval));
                    try {
                        // Capture the pane content
                        const paneContent = execSync(\`tmux capture-pane -t '\${paneInfo}' -p -S -30\`, // Capture last 30 lines
                        { encoding: 'utf-8', stdio: 'pipe' });
                        if (i % 10 === 0) { // Log every 10 checks (every second)
                        }
                        // Check if content has stabilized (same for 3 checks = prompt is waiting)
                        if (paneContent === lastContent) {
                            stableContentCount++;
                        }
                        else {
                            stableContentCount = 0;
                            lastContent = paneContent;
                        }
                        // Look for trust prompt in the current content
                        const hasTrustPrompt = trustPromptPatterns.some(pattern => pattern.test(paneContent));
                        // Also check if we see specific Claude permission text
                        const hasClaudePermissionPrompt = paneContent.includes('Do you trust') ||
                            paneContent.includes('trust the files') ||
                            paneContent.includes('permission') ||
                            paneContent.includes('allow') ||
                            (paneContent.includes('folder') && paneContent.includes('?'));
                        if ((hasTrustPrompt || hasClaudePermissionPrompt) && !promptHandled) {
                            // Content is stable and we found a prompt
                            if (stableContentCount >= 2) {
                                // Check if this is the new Claude numbered menu format
                                const isNewClaudeFormat = /❯\\s*1\\.\\s*Yes,\\s*proceed/i.test(paneContent) ||
                                    /Enter to confirm.*Esc to exit/i.test(paneContent);
                                if (isNewClaudeFormat) {
                                    // For new Claude format, just press Enter to confirm default "Yes, proceed"
                                    execSync(\`tmux send-keys -t '\${paneInfo}' Enter\`, { stdio: 'pipe' });
                                }
                                else {
                                    // Try multiple response methods for older formats
                                    // Method 1: Send 'y' followed by Enter (most explicit)
                                    execSync(\`tmux send-keys -t '\${paneInfo}' 'y'\`, { stdio: 'pipe' });
                                    await new Promise(resolve => setTimeout(resolve, 50));
                                    execSync(\`tmux send-keys -t '\${paneInfo}' Enter\`, { stdio: 'pipe' });
                                    // Method 2: Just Enter (if it's a yes/no with default yes)
                                    await new Promise(resolve => setTimeout(resolve, 100));
                                    execSync(\`tmux send-keys -t '\${paneInfo}' Enter\`, { stdio: 'pipe' });
                                }
                                // Mark as handled to avoid duplicate responses
                                promptHandled = true;
                                // Wait and check if prompt is gone
                                await new Promise(resolve => setTimeout(resolve, 500));
                                // Verify the prompt is gone
                                const updatedContent = execSync(\`tmux capture-pane -t '\${paneInfo}' -p -S -10\`, { encoding: 'utf-8', stdio: 'pipe' });
                                // If trust prompt is gone, check if we need to resend the Claude command
                                const promptGone = !trustPromptPatterns.some(p => p.test(updatedContent));
                                if (promptGone) {
                                    // Check if Claude is running or if we need to restart it
                                    const claudeRunning = updatedContent.includes('Claude') ||
                                        updatedContent.includes('claude') ||
                                        updatedContent.includes('Assistant') ||
                                        (prompt && updatedContent.includes(prompt.substring(0, Math.min(20, prompt.length))));
                                    if (!claudeRunning && !updatedContent.includes('$')) {
                                        await new Promise(resolve => setTimeout(resolve, 300));
                                        execSync(\`tmux send-keys -t '\${paneInfo}' '\${escapedCmd}'\`, { stdio: 'pipe' });
                                        execSync(\`tmux send-keys -t '\${paneInfo}' Enter\`, { stdio: 'pipe' });
                                    }
                                    break;
                                }
                            }
                        }
                        // If we see Claude is already running without prompts, we're done
                        if (!hasTrustPrompt && !hasClaudePermissionPrompt &&
                            (paneContent.includes('Claude') || paneContent.includes('Assistant'))) {
                            break;
                        }
                    }
                    catch (error) {
                        // Continue checking, errors are non-fatal
                    }
                }
            };
            // Start monitoring for trust prompt in background
            autoApproveTrust().catch(err => {
            });
        }
        // Keep focus on the new pane
        execSync(\`tmux select-pane -t '\${paneInfo}'\`, { stdio: 'pipe' });
        // Save pane info
        const newPane = {
            id: \`dmux-\${Date.now()}\`,
            slug,
            prompt: prompt || 'No initial prompt',
            paneId: paneInfo,
            worktreePath,
            agent
        };
        const updatedPanes = [...panes, newPane];
        await savePanes(updatedPanes);
        // Switch back to the original pane (where dmux is running)
        execSync(\`tmux select-pane -t '\${originalPaneId}'\`, { stdio: 'pipe' });
        // Re-set the title for the dmux pane
        try {
            execSync(\`tmux select-pane -t '\${originalPaneId}' -T "dmux-\${projectName}"\`, { stdio: 'pipe' });
        }
        catch {
            // Ignore if setting title fails
        }
        // Clear the screen and redraw the UI
        process.stdout.write('\\x1b[2J\\x1b[H');
        // Reset the creating pane flag and refresh
        setIsCreatingPane(false);
        setStatusMessage('');
        setNewPanePrompt('');
        // Force a reload of panes to ensure UI is up to date
        await loadPanes();
    };
    const jumpToPane = (paneId) => {
        try {
            // Enable pane borders to show titles (if not already enabled)
            try {
                execSync(\`tmux set-option -g pane-border-status top\`, { stdio: 'pipe' });
            }
            catch {
                // Ignore if already set or fails
            }
            execSync(\`tmux select-pane -t '\${paneId}'\`, { stdio: 'pipe' });
            setStatusMessage('Jumped to pane');
            setTimeout(() => setStatusMessage(''), 2000);
        }
        catch {
            setStatusMessage('Failed to jump - pane may be closed');
            setTimeout(() => setStatusMessage(''), 2000);
        }
    };
    const runCommand = async (type, pane) => {
        if (!pane.worktreePath) {
            setStatusMessage('No worktree path for this pane');
            setTimeout(() => setStatusMessage(''), 2000);
            return;
        }
        const command = type === 'test' ? projectSettings.testCommand : projectSettings.devCommand;
        const isFirstRun = type === 'test' ? !projectSettings.firstTestRun : !projectSettings.firstDevRun;
        if (!command) {
            // No command configured, prompt user
            setShowCommandPrompt(type);
            return;
        }
        // Check if this is the first run and offer to copy non-git files
        if (isFirstRun) {
            // Show file copy prompt and wait for response
            setShowFileCopyPrompt(true);
            setCurrentCommandType(type);
            setStatusMessage(\`First time running \${type} command...\`);
            // Return here - the actual command will be run after user responds to prompt
            return;
        }
        try {
            setRunningCommand(true);
            setStatusMessage(\`Starting \${type} in background window...\`);
            // Kill existing window if present
            const existingWindowId = type === 'test' ? pane.testWindowId : pane.devWindowId;
            if (existingWindowId) {
                try {
                    execSync(\`tmux kill-window -t '\${existingWindowId}'\`, { stdio: 'pipe' });
                }
                catch { }
            }
            // Create a new background window for the command
            const windowName = \`\${pane.slug}-\${type}\`;
            const windowId = execSync(\`tmux new-window -d -n '\${windowName}' -P -F '#{window_id}'\`, { encoding: 'utf-8', stdio: 'pipe' }).trim();
            // Create a log file to capture output
            const logFile = \`/tmp/dmux-\${pane.id}-\${type}.log\`;
            // Build the command with output capture
            const fullCommand = type === 'test'
                ? \`cd "\${pane.worktreePath}" && \${command} 2>&1 | tee \${logFile}\`
                : \`cd "\${pane.worktreePath}" && \${command} 2>&1 | tee \${logFile}\`;
            // Send the command to the new window
            execSync(\`tmux send-keys -t '\${windowId}' '\${fullCommand.replace(/'/g, "'\\\\''")}'\`, { stdio: 'pipe' });
            execSync(\`tmux send-keys -t '\${windowId}' Enter\`, { stdio: 'pipe' });
            // Update pane with window info
            const updatedPane = {
                ...pane,
                [type === 'test' ? 'testWindowId' : 'devWindowId']: windowId,
                [type === 'test' ? 'testStatus' : 'devStatus']: 'running'
            };
            const updatedPanes = panes.map(p => p.id === pane.id ? updatedPane : p);
            await savePanes(updatedPanes);
            // Start monitoring the output
            if (type === 'test') {
                // For tests, monitor for completion
                setTimeout(() => monitorTestOutput(pane.id, logFile), 2000);
            }
            else {
                // For dev, monitor for server URL
                setTimeout(() => monitorDevOutput(pane.id, logFile), 2000);
            }
            setRunningCommand(false);
            setStatusMessage(\`\${type === 'test' ? 'Test' : 'Dev server'} started in background\`);
            setTimeout(() => setStatusMessage(''), 3000);
        }
        catch (error) {
            setRunningCommand(false);
            setStatusMessage(\`Failed to run \${type} command\`);
            setTimeout(() => setStatusMessage(''), 3000);
        }
    };
    // Update handling moved to useAutoUpdater
    // Cleanup function for exit
    const cleanExit = () => {
        // Clear screen before exiting Ink
        process.stdout.write('\\x1b[2J\\x1b[3J\\x1b[H');
        // Exit the Ink app (this cleans up the React tree)
        exit();
        // Give Ink a moment to clean up its rendering, then do final cleanup
        setTimeout(() => {
            // Multiple aggressive clearing strategies
            process.stdout.write('\\x1b[2J\\x1b[H'); // Clear screen and move cursor to home
            process.stdout.write('\\x1b[3J'); // Clear scrollback buffer
            process.stdout.write('\\x1b[0m'); // Reset all attributes
            // Clear tmux history and pane
            try {
                execSync('tmux clear-history', { stdio: 'pipe' });
                execSync('tmux send-keys C-l', { stdio: 'pipe' });
            }
            catch { }
            // One more final clear
            process.stdout.write('\\x1b[2J\\x1b[H');
            // Show clean goodbye message
            process.stdout.write('\\n  Run dmux again to resume. Goodbye 👋\\n\\n');
            // Exit process
            process.exit(0);
        }, 100);
    };
    useInput(async (input, key) => {
        // Handle Ctrl+C for quit confirmation (must be first, before any other checks)
        if (key.ctrl && input === 'c') {
            if (quitConfirmMode) {
                // Second Ctrl+C - actually quit
                cleanExit();
            }
            else {
                // First Ctrl+C - show confirmation
                setQuitConfirmMode(true);
                // Reset after 3 seconds if user doesn't press Ctrl+C again
                setTimeout(() => {
                    setQuitConfirmMode(false);
                }, 3000);
            }
            return;
        }
        if (isCreatingPane || runningCommand || isUpdating || isLoading || isCreatingTunnel) {
            // Disable input while performing operations or loading
            return;
        }
        // Handle kebab menu navigation
        if (showKebabMenu && kebabMenuPaneIndex !== null) {
            const currentPane = panes[kebabMenuPaneIndex];
            const hasWorktree = !!currentPane?.worktreePath;
            const menuOptions = hasWorktree ? 6 : 2; // view, test, dev, open, merge, close (if worktree) OR view, close
            if (key.escape) {
                setShowKebabMenu(false);
                setKebabMenuPaneIndex(null);
                setKebabMenuOption(0);
                return;
            }
            else if (key.upArrow) {
                setKebabMenuOption(Math.max(0, kebabMenuOption - 1));
                return;
            }
            else if (key.downArrow) {
                setKebabMenuOption(Math.min(menuOptions - 1, kebabMenuOption + 1));
                return;
            }
            else if (key.return) {
                // Execute the selected menu action
                setShowKebabMenu(false);
                if (kebabMenuOption === 0) {
                    // View - jump to pane (NEW: using action system)
                    actionSystem.executeAction(PaneAction.VIEW, currentPane);
                }
                else if (hasWorktree && kebabMenuOption === 1) {
                    // Test
                    await runCommand('test', currentPane);
                }
                else if (hasWorktree && kebabMenuOption === 2) {
                    // Dev
                    await runCommand('dev', currentPane);
                }
                else if (hasWorktree && kebabMenuOption === 3) {
                    // Open
                    if (currentPane.testWindowId || currentPane.devWindowId) {
                        // If both exist, prefer dev (since it's usually more interactive)
                        if (currentPane.devWindowId && currentPane.devStatus === 'running') {
                            await attachBackgroundWindow(currentPane, 'dev');
                        }
                        else if (currentPane.testWindowId) {
                            await attachBackgroundWindow(currentPane, 'test');
                        }
                    }
                    else {
                        setStatusMessage('No test or dev window to open');
                        setTimeout(() => setStatusMessage(''), 2000);
                    }
                }
                else if (hasWorktree && kebabMenuOption === 4) {
                    // Merge (NEW: using action system)
                    actionSystem.executeAction(PaneAction.MERGE, currentPane, { mainBranch: getMainBranch() });
                }
                else if ((hasWorktree && kebabMenuOption === 5) || (!hasWorktree && kebabMenuOption === 1)) {
                    // Close (NEW: using action system)
                    actionSystem.executeAction(PaneAction.CLOSE, currentPane);
                }
                setKebabMenuPaneIndex(null);
                setKebabMenuOption(0);
                return;
            }
            // Don't process other inputs while menu is open
            return;
        }
        // Handle quit confirm mode - ESC cancels it
        if (quitConfirmMode) {
            if (key.escape) {
                setQuitConfirmMode(false);
                return;
            }
            // Allow other inputs to continue (don't return early)
        }
        // Handle QR code view
        if (showQRCode) {
            if (key.escape) {
                setShowQRCode(false);
            }
            return;
        }
        // Handle action system confirm dialog
        if (actionSystem.actionState.showConfirmDialog) {
            if (key.escape || input === 'n' || input === 'N') {
                if (actionSystem.actionState.onConfirmNo) {
                    actionSystem.executeCallback(actionSystem.actionState.onConfirmNo);
                }
                else {
                    actionSystem.setActionState(prev => ({ ...prev, showConfirmDialog: false }));
                }
                return;
            }
            else if (input === 'y' || input === 'Y') {
                if (actionSystem.actionState.onConfirmYes) {
                    actionSystem.executeCallback(actionSystem.actionState.onConfirmYes);
                }
                return;
            }
            return;
        }
        // Handle action system choice dialog
        if (actionSystem.actionState.showChoiceDialog) {
            if (key.escape) {
                actionSystem.setActionState(prev => ({ ...prev, showChoiceDialog: false }));
                return;
            }
            else if (key.upArrow) {
                actionSystem.setActionState(prev => ({
                    ...prev,
                    choiceSelectedIndex: Math.max(0, prev.choiceSelectedIndex - 1)
                }));
                return;
            }
            else if (key.downArrow) {
                const maxIndex = actionSystem.actionState.choiceOptions.length - 1;
                actionSystem.setActionState(prev => ({
                    ...prev,
                    choiceSelectedIndex: Math.min(maxIndex, prev.choiceSelectedIndex + 1)
                }));
                return;
            }
            else if (key.return) {
                const selectedOption = actionSystem.actionState.choiceOptions[actionSystem.actionState.choiceSelectedIndex];
                if (selectedOption && actionSystem.actionState.onChoiceSelect) {
                    actionSystem.executeCallback(async () => actionSystem.actionState.onChoiceSelect(selectedOption.id));
                }
                return;
            }
            return;
        }
        if (showFileCopyPrompt) {
            if (input === 'y' || input === 'Y') {
                setShowFileCopyPrompt(false);
                const selectedPane = panes[selectedIndex];
                if (selectedPane && selectedPane.worktreePath && currentCommandType) {
                    await copyNonGitFiles(selectedPane.worktreePath);
                    // Mark as not first run and continue with command
                    const newSettings = {
                        ...projectSettings,
                        [currentCommandType === 'test' ? 'firstTestRun' : 'firstDevRun']: true
                    };
                    await saveSettings(newSettings);
                    // Now run the actual command
                    await runCommandInternal(currentCommandType, selectedPane);
                }
                setCurrentCommandType(null);
            }
            else if (input === 'n' || input === 'N' || key.escape) {
                setShowFileCopyPrompt(false);
                const selectedPane = panes[selectedIndex];
                if (selectedPane && currentCommandType) {
                    // Mark as not first run and continue without copying
                    const newSettings = {
                        ...projectSettings,
                        [currentCommandType === 'test' ? 'firstTestRun' : 'firstDevRun']: true
                    };
                    await saveSettings(newSettings);
                    // Now run the actual command
                    await runCommandInternal(currentCommandType, selectedPane);
                }
                setCurrentCommandType(null);
            }
            return;
        }
        if (showAgentChoiceDialog) {
            if (key.escape) {
                setShowAgentChoiceDialog(false);
                setShowNewPaneDialog(true);
                setNewPanePrompt(pendingPrompt);
                setPendingPrompt('');
            }
            else if (key.leftArrow || input === '1' || (input && input.toLowerCase() === 'c')) {
                setAgentChoice('claude');
            }
            else if (key.rightArrow || input === '2' || (input && input.toLowerCase() === 'o')) {
                setAgentChoice('opencode');
            }
            else if (key.return) {
                const chosen = agentChoice || (availableAgents[0] || 'claude');
                const promptValue = pendingPrompt;
                setShowAgentChoiceDialog(false);
                setPendingPrompt('');
                await createNewPane(promptValue, chosen);
                setNewPanePrompt('');
            }
            return;
        }
        if (showCommandPrompt) {
            if (key.escape) {
                setShowCommandPrompt(null);
                setCommandInput('');
            }
            else if (key.return) {
                if (commandInput.trim() === '') {
                    // If empty, suggest a default command based on package manager
                    const suggested = await suggestCommand(showCommandPrompt);
                    if (suggested) {
                        setCommandInput(suggested);
                    }
                }
                else {
                    // User provided manual command
                    const newSettings = {
                        ...projectSettings,
                        [showCommandPrompt === 'test' ? 'testCommand' : 'devCommand']: commandInput.trim()
                    };
                    await saveSettings(newSettings);
                    const selectedPane = panes[selectedIndex];
                    if (selectedPane) {
                        // Check if first run
                        const isFirstRun = showCommandPrompt === 'test' ? !projectSettings.firstTestRun : !projectSettings.firstDevRun;
                        if (isFirstRun) {
                            setCurrentCommandType(showCommandPrompt);
                            setShowCommandPrompt(null);
                            setShowFileCopyPrompt(true);
                        }
                        else {
                            await runCommandInternal(showCommandPrompt, selectedPane);
                            setShowCommandPrompt(null);
                            setCommandInput('');
                        }
                    }
                    else {
                        setShowCommandPrompt(null);
                        setCommandInput('');
                    }
                }
            }
            return;
        }
        if (showNewPaneDialog) {
            if (key.escape) {
                setShowNewPaneDialog(false);
                setNewPanePrompt('');
            }
            else if (key.ctrl && input === 'o') {
                // Open in external editor
                openEditor2(newPanePrompt, setNewPanePrompt);
            }
            // TextInput handles other input events
            return;
        }
        // Handle directional navigation with spatial awareness based on card grid layout
        if (key.upArrow || key.downArrow || key.leftArrow || key.rightArrow) {
            let targetIndex = null;
            if (key.upArrow) {
                targetIndex = findCardInDirection(selectedIndex, 'up');
            }
            else if (key.downArrow) {
                targetIndex = findCardInDirection(selectedIndex, 'down');
            }
            else if (key.leftArrow) {
                targetIndex = findCardInDirection(selectedIndex, 'left');
            }
            else if (key.rightArrow) {
                targetIndex = findCardInDirection(selectedIndex, 'right');
            }
            if (targetIndex !== null) {
                setSelectedIndex(targetIndex);
            }
            return;
        }
        if (input === 'm' && selectedIndex < panes.length) {
            // Open kebab menu for selected pane
            setShowKebabMenu(true);
            setKebabMenuPaneIndex(selectedIndex);
            setKebabMenuOption(0);
        }
        else if (input === 'q') {
            cleanExit();
        }
        else if (input === 'r' && server) {
            // Create tunnel if not already created, then show QR code
            if (!tunnelUrl) {
                setIsCreatingTunnel(true);
                setStatusMessage('Creating tunnel...');
                try {
                    const url = await server.startTunnel();
                    setTunnelUrl(url);
                    setStatusMessage('');
                    setShowQRCode(true);
                }
                catch (error) {
                    setStatusMessage('Failed to create tunnel');
                    setTimeout(() => setStatusMessage(''), 3000);
                }
                finally {
                    setIsCreatingTunnel(false);
                }
            }
            else {
                // Tunnel already exists, just show the QR code
                setShowQRCode(true);
            }
        }
        else if (!isLoading && (input === 'n' || (key.return && selectedIndex === panes.length))) {
            // Clear the prompt and show dialog in next tick to prevent 'n' bleeding through
            setNewPanePrompt('');
            setShowNewPaneDialog(true);
            return; // Consume the 'n' keystroke so it doesn't propagate
        }
        else if (input === 'j' && selectedIndex < panes.length) {
            // Jump to pane (NEW: using action system)
            actionSystem.executeAction(PaneAction.VIEW, panes[selectedIndex]);
        }
        else if (input === 'x' && selectedIndex < panes.length) {
            // Close pane (NEW: using action system)
            actionSystem.executeAction(PaneAction.CLOSE, panes[selectedIndex]);
        }
        else if (key.return && selectedIndex < panes.length) {
            // Jump to pane (NEW: using action system)
            actionSystem.executeAction(PaneAction.VIEW, panes[selectedIndex]);
        }
    });
    // If showing QR code, render only that
    if (showQRCode && tunnelUrl) {
        return (React.createElement(Box, { flexDirection: "column" },
            React.createElement(Box, { marginBottom: 1 },
                React.createElement(Text, { bold: true, color: "cyan" }, "dmux - Remote Access")),
            React.createElement(QRCode, { url: tunnelUrl }),
            React.createElement(Box, { marginTop: 1 },
                React.createElement(Text, { dimColor: true }, "Press ESC to return to pane list"))));
    }
    return (React.createElement(Box, { flexDirection: "column" },
        React.createElement(PanesGrid, { panes: panes, selectedIndex: selectedIndex, isLoading: isLoading, showNewPaneDialog: showNewPaneDialog, agentStatuses: agentStatuses, kebabMenuPaneIndex: kebabMenuPaneIndex ?? undefined }),
        isLoading && (React.createElement(LoadingIndicator, null)),
        showNewPaneDialog && !showAgentChoiceDialog && (React.createElement(NewPaneDialog, { value: newPanePrompt, onChange: setNewPanePrompt, onSubmit: (value) => {
                const promptValue = value;
                const agents = availableAgents;
                if (agents.length === 0) {
                    setShowNewPaneDialog(false);
                    setNewPanePrompt('');
                    createNewPaneHook(promptValue);
                }
                else if (agents.length === 1) {
                    setShowNewPaneDialog(false);
                    setNewPanePrompt('');
                    createNewPaneHook(promptValue, agents[0]);
                }
                else {
                    setPendingPrompt(promptValue);
                    setShowNewPaneDialog(false);
                    setNewPanePrompt('');
                    setShowAgentChoiceDialog(true);
                    setAgentChoice(agentChoice || 'claude');
                }
            } })),
        showAgentChoiceDialog && (React.createElement(AgentChoiceDialog, { agentChoice: agentChoice })),
        isCreatingPane && (React.createElement(CreatingIndicator, { message: statusMessage })),
        showCommandPrompt && (React.createElement(CommandPromptDialog, { type: showCommandPrompt, value: commandInput, onChange: setCommandInput })),
        showFileCopyPrompt && (React.createElement(FileCopyPrompt, null)),
        showKebabMenu && kebabMenuPaneIndex !== null && panes[kebabMenuPaneIndex] && (React.createElement(KebabMenu, { selectedOption: kebabMenuOption, hasWorktree: !!panes[kebabMenuPaneIndex].worktreePath, paneName: panes[kebabMenuPaneIndex].slug })),
        actionSystem.actionState.showConfirmDialog && (React.createElement(ActionConfirmDialog, { title: actionSystem.actionState.confirmTitle, message: actionSystem.actionState.confirmMessage, yesLabel: actionSystem.actionState.confirmYesLabel, noLabel: actionSystem.actionState.confirmNoLabel })),
        actionSystem.actionState.showChoiceDialog && (React.createElement(ActionChoiceDialog, { title: actionSystem.actionState.choiceTitle, message: actionSystem.actionState.choiceMessage, options: actionSystem.actionState.choiceOptions, selectedIndex: actionSystem.actionState.choiceSelectedIndex })),
        runningCommand && (React.createElement(RunningIndicator, null)),
        isUpdating && (React.createElement(UpdatingIndicator, null)),
        isCreatingTunnel && (React.createElement(Box, { flexDirection: "column", borderStyle: "round", borderColor: "cyan", padding: 1, marginTop: 1 },
            React.createElement(Text, { bold: true, color: "cyan" }, "Creating tunnel..."),
            React.createElement(Box, { marginTop: 1 },
                React.createElement(Text, { dimColor: true }, "This may take a few moments...")))),
        statusMessage && (React.createElement(Box, { marginTop: 1 },
            React.createElement(Text, { color: "green" }, statusMessage))),
        actionSystem.actionState.statusMessage && (React.createElement(Box, { marginTop: 1 },
            React.createElement(Text, { color: actionSystem.actionState.statusType === 'error' ? 'red' :
                    actionSystem.actionState.statusType === 'success' ? 'green' :
                        'cyan' }, actionSystem.actionState.statusMessage))),
        React.createElement(FooterHelp, { show: !showNewPaneDialog && !showCommandPrompt, showRemoteKey: !!server, quitConfirmMode: quitConfirmMode, gridInfo: (() => {
                if (!process.env.DEBUG_DMUX)
                    return undefined;
                const cols = Math.max(1, Math.floor(terminalWidth / 37));
                const rows = Math.ceil((panes.length + 1) / cols);
                const pos = getCardGridPosition(selectedIndex);
                return \`Grid: \${cols} cols × \${rows} rows | Selected: row \${pos.row}, col \${pos.col} | Terminal: \${terminalWidth}w\`;
            })() }),
        React.createElement(Text, { dimColor: true },
            "v",
            packageJson.version,
            updateAvailable && updateInfo && (React.createElement(Text, { color: "yellow" },
                " \\u2022 Update available: ",
                updateInfo.latestVersion)))));
};
export default DmuxApp;
//# sourceMappingURL=DmuxApp.js.map`,
    mimeType: 'application/javascript',
    size: 51552
  },
  'EnhancedTextInput.js': {
    content: `import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useFocus } from 'ink';
import { execSync } from 'child_process';
import path from 'path';
const EnhancedTextInput = ({ value, onChange, placeholder = '', onSubmit, onCancel, multiline = false, workingDirectory = process.cwd() }) => {
    const { isFocused } = useFocus({ autoFocus: true });
    const [cursorPosition, setCursorPosition] = useState(value.length);
    const [lines, setLines] = useState([value]);
    const [currentLine, setCurrentLine] = useState(0);
    const [showAutocomplete, setShowAutocomplete] = useState(false);
    const [autocompleteQuery, setAutocompleteQuery] = useState('');
    const [autocompleteStartPos, setAutocompleteStartPos] = useState(0);
    const [fileMatches, setFileMatches] = useState([]);
    const [selectedMatchIndex, setSelectedMatchIndex] = useState(0);
    const [displayValue, setDisplayValue] = useState(value);
    // Update lines when value changes externally
    useEffect(() => {
        if (multiline) {
            setLines(value.split('\\n'));
        }
        else {
            setLines([value]);
        }
        setDisplayValue(value);
        // Keep cursor position valid
        if (cursorPosition > value.length) {
            setCursorPosition(value.length);
        }
    }, [value, multiline]);
    // Search for files when autocomplete query changes
    useEffect(() => {
        if (showAutocomplete && autocompleteQuery.length > 0) {
            searchFiles(autocompleteQuery);
        }
        else {
            setFileMatches([]);
        }
    }, [autocompleteQuery, showAutocomplete]);
    const searchFiles = async (query) => {
        try {
            // Use find command to search for files
            const searchCmd = \`find "\${workingDirectory}" -type f -name "*\${query}*" 2>/dev/null | head -20\`;
            const dirSearchCmd = \`find "\${workingDirectory}" -type d -name "*\${query}*" 2>/dev/null | head -10\`;
            const fileResults = await new Promise((resolve) => {
                try {
                    const result = execSync(searchCmd, { encoding: 'utf-8' }).trim().split('\\n').filter(Boolean);
                    resolve(result);
                }
                catch {
                    resolve([]);
                }
            });
            const dirResults = await new Promise((resolve) => {
                try {
                    const result = execSync(dirSearchCmd, { encoding: 'utf-8' }).trim().split('\\n').filter(Boolean);
                    resolve(result);
                }
                catch {
                    resolve([]);
                }
            });
            const matches = [];
            // Process directory matches
            for (const dirPath of dirResults) {
                const relativePath = path.relative(workingDirectory, dirPath);
                if (relativePath && !relativePath.startsWith('..')) {
                    matches.push({
                        path: dirPath,
                        displayPath: relativePath + '/',
                        type: 'directory'
                    });
                }
            }
            // Process file matches
            for (const filePath of fileResults) {
                const relativePath = path.relative(workingDirectory, filePath);
                if (relativePath && !relativePath.startsWith('..')) {
                    matches.push({
                        path: filePath,
                        displayPath: relativePath,
                        type: 'file'
                    });
                }
            }
            // Sort by relevance (shorter paths first, then alphabetically)
            matches.sort((a, b) => {
                const aScore = a.displayPath.length + (a.displayPath.toLowerCase().indexOf(query.toLowerCase()) === 0 ? 0 : 100);
                const bScore = b.displayPath.length + (b.displayPath.toLowerCase().indexOf(query.toLowerCase()) === 0 ? 0 : 100);
                if (aScore !== bScore)
                    return aScore - bScore;
                return a.displayPath.localeCompare(b.displayPath);
            });
            setFileMatches(matches.slice(0, 10)); // Limit to 10 matches
            setSelectedMatchIndex(0);
        }
        catch (error) {
            setFileMatches([]);
        }
    };
    const insertText = (text, position) => {
        const before = displayValue.slice(0, position);
        const after = displayValue.slice(position);
        const newValue = before + text + after;
        onChange(newValue);
        setCursorPosition(position + text.length);
    };
    const deleteText = (start, end) => {
        const before = displayValue.slice(0, start);
        const after = displayValue.slice(end);
        const newValue = before + after;
        onChange(newValue);
        setCursorPosition(start);
    };
    const moveCursor = (position) => {
        const clampedPosition = Math.max(0, Math.min(displayValue.length, position));
        setCursorPosition(clampedPosition);
    };
    const findWordBoundary = (text, position, direction) => {
        const wordRegex = /\\w/;
        let pos = position;
        if (direction === 'left') {
            // Skip any whitespace
            while (pos > 0 && !wordRegex.test(text[pos - 1])) {
                pos--;
            }
            // Skip the word
            while (pos > 0 && wordRegex.test(text[pos - 1])) {
                pos--;
            }
        }
        else {
            // Skip any whitespace
            while (pos < text.length && !wordRegex.test(text[pos])) {
                pos++;
            }
            // Skip the word
            while (pos < text.length && wordRegex.test(text[pos])) {
                pos++;
            }
        }
        return pos;
    };
    const completeFileReference = (match) => {
        // Replace the autocomplete query with the selected file path
        const before = displayValue.slice(0, autocompleteStartPos);
        const after = displayValue.slice(cursorPosition);
        const newValue = before + match.displayPath + after;
        onChange(newValue);
        setCursorPosition(autocompleteStartPos + match.displayPath.length);
        setShowAutocomplete(false);
        setAutocompleteQuery('');
    };
    useInput((input, key) => {
        // Only handle input when focused
        if (!isFocused)
            return;
        // Debug logging for key detection
        if (process.env.DEBUG_DMUX) {
            console.error('Key pressed:', { input, key });
        }
        // Handle autocomplete navigation
        if (showAutocomplete) {
            if (key.escape) {
                setShowAutocomplete(false);
                setAutocompleteQuery('');
                return;
            }
            else if (key.upArrow) {
                setSelectedMatchIndex(Math.max(0, selectedMatchIndex - 1));
                return;
            }
            else if (key.downArrow) {
                setSelectedMatchIndex(Math.min(fileMatches.length - 1, selectedMatchIndex + 1));
                return;
            }
            else if (key.return || key.tab) {
                if (fileMatches.length > 0) {
                    completeFileReference(fileMatches[selectedMatchIndex]);
                }
                return;
            }
        }
        // Handle special keys
        if (key.escape) {
            onCancel?.();
            return;
        }
        if (key.return && !multiline) {
            onSubmit?.();
            return;
        }
        if (key.return && multiline && !key.shift) {
            // In multiline mode, Enter adds a new line
            insertText('\\n', cursorPosition);
            return;
        }
        if (key.return && multiline && key.shift) {
            // Shift+Enter submits in multiline mode
            onSubmit?.();
            return;
        }
        // Cursor movement
        if (key.leftArrow) {
            if (key.meta || key.alt) {
                // Move to previous word (Alt/Cmd + Left)
                const newPos = findWordBoundary(displayValue, cursorPosition, 'left');
                moveCursor(newPos);
            }
            else {
                moveCursor(cursorPosition - 1);
            }
            return;
        }
        if (key.rightArrow) {
            if (key.meta || key.alt) {
                // Move to next word (Alt/Cmd + Right)
                const newPos = findWordBoundary(displayValue, cursorPosition, 'right');
                moveCursor(newPos);
            }
            else {
                moveCursor(cursorPosition + 1);
            }
            return;
        }
        // Line navigation for multiline and single-line
        if (key.upArrow) {
            if (multiline) {
                // Move to line above
                const lines = displayValue.split('\\n');
                let currentPos = 0;
                let lineIndex = 0;
                let columnIndex = 0;
                // Find current line and column
                for (let i = 0; i < lines.length; i++) {
                    const lineLength = lines[i].length;
                    if (currentPos + lineLength >= cursorPosition) {
                        lineIndex = i;
                        columnIndex = cursorPosition - currentPos;
                        break;
                    }
                    currentPos += lineLength + 1; // +1 for newline
                }
                // Move to previous line if possible
                if (lineIndex > 0) {
                    const prevLineLength = lines[lineIndex - 1].length;
                    const newColumn = Math.min(columnIndex, prevLineLength);
                    // Calculate new cursor position
                    let newPos = 0;
                    for (let i = 0; i < lineIndex - 1; i++) {
                        newPos += lines[i].length + 1;
                    }
                    newPos += newColumn;
                    moveCursor(newPos);
                }
                else {
                    // At first line, move to start of line
                    moveCursor(0);
                }
            }
            else {
                // Single line: move to start
                moveCursor(0);
            }
            return;
        }
        if (key.downArrow) {
            if (multiline) {
                // Move to line below
                const lines = displayValue.split('\\n');
                let currentPos = 0;
                let lineIndex = 0;
                let columnIndex = 0;
                // Find current line and column
                for (let i = 0; i < lines.length; i++) {
                    const lineLength = lines[i].length;
                    if (currentPos + lineLength >= cursorPosition) {
                        lineIndex = i;
                        columnIndex = cursorPosition - currentPos;
                        break;
                    }
                    currentPos += lineLength + 1; // +1 for newline
                }
                // Move to next line if possible
                if (lineIndex < lines.length - 1) {
                    const nextLineLength = lines[lineIndex + 1].length;
                    const newColumn = Math.min(columnIndex, nextLineLength);
                    // Calculate new cursor position
                    let newPos = 0;
                    for (let i = 0; i <= lineIndex; i++) {
                        newPos += lines[i].length + 1;
                    }
                    newPos += newColumn;
                    moveCursor(newPos);
                }
                else {
                    // At last line, move to end of line
                    moveCursor(displayValue.length);
                }
            }
            else {
                // Single line: move to end
                moveCursor(displayValue.length);
            }
            return;
        }
        // Home/End keys
        if (key.ctrl && input === 'a') {
            // Ctrl+A - Move to start of line
            if (multiline) {
                const lineStart = displayValue.lastIndexOf('\\n', cursorPosition - 1) + 1;
                moveCursor(lineStart);
            }
            else {
                moveCursor(0);
            }
            return;
        }
        if (key.ctrl && input === 'e') {
            // Ctrl+E - Move to end of line
            if (multiline) {
                const lineEnd = displayValue.indexOf('\\n', cursorPosition);
                moveCursor(lineEnd === -1 ? displayValue.length : lineEnd);
            }
            else {
                moveCursor(displayValue.length);
            }
            return;
        }
        // Deletion - handle both backspace and delete properly
        if (key.backspace || key.delete) {
            if (key.backspace) {
                // Backspace: delete character before cursor
                if (key.meta || key.alt) {
                    // Delete word (Alt/Cmd + Backspace)
                    const wordStart = findWordBoundary(displayValue, cursorPosition, 'left');
                    deleteText(wordStart, cursorPosition);
                }
                else if (cursorPosition > 0) {
                    deleteText(cursorPosition - 1, cursorPosition);
                }
            }
            else if (key.delete) {
                // Delete: delete character after cursor
                if (key.meta || key.alt) {
                    // Delete word forward (Alt/Cmd + Delete)
                    const wordEnd = findWordBoundary(displayValue, cursorPosition, 'right');
                    deleteText(cursorPosition, wordEnd);
                }
                else if (cursorPosition < displayValue.length) {
                    deleteText(cursorPosition, cursorPosition + 1);
                }
            }
            return;
        }
        // Text input
        if (input && !key.ctrl && !key.meta) {
            // Check for @ symbol to trigger autocomplete
            if (input === '@') {
                setShowAutocomplete(true);
                setAutocompleteStartPos(cursorPosition + 1);
                setAutocompleteQuery('');
                insertText(input, cursorPosition);
            }
            else if (showAutocomplete) {
                // Update autocomplete query
                insertText(input, cursorPosition);
                const newQuery = displayValue.slice(autocompleteStartPos, cursorPosition + 1);
                setAutocompleteQuery(newQuery);
            }
            else {
                insertText(input, cursorPosition);
            }
        }
    });
    // Build display with cursor - handle multiline properly
    const getDisplayWithCursor = () => {
        if (!multiline) {
            // Single line display
            const before = displayValue.slice(0, cursorPosition);
            const after = displayValue.slice(cursorPosition);
            const cursorChar = after[0] || ' ';
            const remaining = after.slice(1);
            return (React.createElement(React.Fragment, null,
                React.createElement(Text, null, before),
                React.createElement(Text, { inverse: true }, cursorChar),
                React.createElement(Text, null, remaining)));
        }
        else {
            // Multiline display - render each line separately
            const lines = displayValue.split('\\n');
            let currentPos = 0;
            let result = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const lineStart = currentPos;
                const lineEnd = currentPos + line.length;
                if (cursorPosition >= lineStart && cursorPosition <= lineEnd) {
                    // This line contains the cursor
                    const beforeCursor = line.slice(0, cursorPosition - lineStart);
                    const atCursor = line[cursorPosition - lineStart] || ' ';
                    const afterCursor = line.slice(cursorPosition - lineStart + 1);
                    result.push(React.createElement(Box, { key: i },
                        React.createElement(Text, null, i > 0 ? '  ' : ''),
                        React.createElement(Text, null, beforeCursor),
                        React.createElement(Text, { inverse: true }, atCursor),
                        React.createElement(Text, null, afterCursor)));
                }
                else {
                    // Normal line without cursor
                    result.push(React.createElement(Box, { key: i },
                        React.createElement(Text, null, i > 0 ? '  ' : ''),
                        React.createElement(Text, null, line)));
                }
                currentPos = lineEnd + 1; // +1 for newline
            }
            // If cursor is at the very end after a newline, show it
            if (cursorPosition === displayValue.length && displayValue.endsWith('\\n')) {
                result.push(React.createElement(Box, { key: lines.length },
                    React.createElement(Text, null, "  "),
                    React.createElement(Text, { inverse: true }, " ")));
            }
            return React.createElement(Box, { flexDirection: "column" }, result);
        }
    };
    return (React.createElement(Box, { flexDirection: "column" },
        multiline ? (React.createElement(Box, { flexDirection: "row" },
            React.createElement(Text, null, '> '),
            React.createElement(Box, { flexGrow: 1 }, getDisplayWithCursor()))) : (React.createElement(Box, null,
            React.createElement(Text, null, '> '),
            getDisplayWithCursor())),
        showAutocomplete && fileMatches.length > 0 && (React.createElement(Box, { flexDirection: "column", marginTop: 1, borderStyle: "single", borderColor: "cyan", paddingX: 1 },
            React.createElement(Text, { color: "cyan", dimColor: true },
                "Files matching: @",
                autocompleteQuery),
            fileMatches.map((match, index) => (React.createElement(Box, { key: match.path },
                React.createElement(Text, { color: index === selectedMatchIndex ? 'cyan' : 'gray' },
                    index === selectedMatchIndex ? '▶ ' : '  ',
                    match.type === 'directory' ? '📁 ' : '📄 ',
                    match.displayPath)))),
            React.createElement(Text, { dimColor: true, italic: true }, "\\u2191\\u2193 to select, Tab/Enter to complete, Esc to cancel")))));
};
export default EnhancedTextInput;
//# sourceMappingURL=EnhancedTextInput.js.map`,
    mimeType: 'application/javascript',
    size: 18658
  },
  'GeminiTextInput.js': {
    content: `import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useFocus } from 'ink';
const GeminiTextInput = ({ value, onChange, onSubmit, onCancel, multiline = false, placeholder = '' }) => {
    const { isFocused } = useFocus({ autoFocus: true });
    const [lines, setLines] = useState([]);
    const [cursorRow, setCursorRow] = useState(0);
    const [cursorCol, setCursorCol] = useState(0);
    // Split text into lines and update cursor position
    useEffect(() => {
        const newLines = value ? value.split('\\n') : [''];
        setLines(newLines);
        // Calculate cursor position from value length
        let remaining = value.length;
        let row = 0;
        let col = 0;
        for (let i = 0; i < newLines.length; i++) {
            const lineLength = newLines[i].length;
            if (remaining <= lineLength) {
                row = i;
                col = remaining;
                break;
            }
            remaining -= lineLength + 1; // +1 for newline
        }
        setCursorRow(row);
        setCursorCol(col);
    }, [value]);
    // Convert row/col back to text
    const updateText = (newLines, row, col) => {
        const text = newLines.join('\\n');
        onChange(text);
        setCursorRow(row);
        setCursorCol(col);
    };
    useInput((input, key) => {
        if (!isFocused)
            return;
        // Handle special keys
        if (key.escape) {
            onCancel?.();
            return;
        }
        if (key.return && !multiline) {
            onSubmit?.();
            return;
        }
        if (key.return && multiline && !key.shift) {
            // Add newline in multiline mode
            const currentLine = lines[cursorRow] || '';
            const before = currentLine.slice(0, cursorCol);
            const after = currentLine.slice(cursorCol);
            const newLines = [...lines];
            newLines[cursorRow] = before;
            newLines.splice(cursorRow + 1, 0, after);
            updateText(newLines, cursorRow + 1, 0);
            return;
        }
        if (key.return && multiline && key.shift) {
            // Shift+Enter submits in multiline mode
            onSubmit?.();
            return;
        }
        // Handle backspace
        if (key.backspace) {
            const currentLine = lines[cursorRow] || '';
            if (cursorCol > 0) {
                // Delete character before cursor
                const before = currentLine.slice(0, cursorCol - 1);
                const after = currentLine.slice(cursorCol);
                const newLines = [...lines];
                newLines[cursorRow] = before + after;
                updateText(newLines, cursorRow, cursorCol - 1);
            }
            else if (cursorRow > 0) {
                // At beginning of line, merge with previous line
                const prevLine = lines[cursorRow - 1] || '';
                const newCol = prevLine.length;
                const newLines = [...lines];
                newLines[cursorRow - 1] = prevLine + currentLine;
                newLines.splice(cursorRow, 1);
                updateText(newLines, cursorRow - 1, newCol);
            }
            return;
        }
        // Handle delete
        if (key.delete) {
            const currentLine = lines[cursorRow] || '';
            if (cursorCol < currentLine.length) {
                // Delete character after cursor
                const before = currentLine.slice(0, cursorCol);
                const after = currentLine.slice(cursorCol + 1);
                const newLines = [...lines];
                newLines[cursorRow] = before + after;
                updateText(newLines, cursorRow, cursorCol);
            }
            else if (cursorRow < lines.length - 1) {
                // At end of line, merge with next line
                const nextLine = lines[cursorRow + 1] || '';
                const newLines = [...lines];
                newLines[cursorRow] = currentLine + nextLine;
                newLines.splice(cursorRow + 1, 1);
                updateText(newLines, cursorRow, cursorCol);
            }
            return;
        }
        // Handle arrow keys
        if (key.leftArrow) {
            if (cursorCol > 0) {
                setCursorCol(cursorCol - 1);
            }
            else if (cursorRow > 0) {
                const prevLine = lines[cursorRow - 1] || '';
                setCursorRow(cursorRow - 1);
                setCursorCol(prevLine.length);
            }
            return;
        }
        if (key.rightArrow) {
            const currentLine = lines[cursorRow] || '';
            if (cursorCol < currentLine.length) {
                setCursorCol(cursorCol + 1);
            }
            else if (cursorRow < lines.length - 1) {
                setCursorRow(cursorRow + 1);
                setCursorCol(0);
            }
            return;
        }
        if (key.upArrow && multiline) {
            if (cursorRow > 0) {
                const targetLine = lines[cursorRow - 1] || '';
                setCursorRow(cursorRow - 1);
                setCursorCol(Math.min(cursorCol, targetLine.length));
            }
            return;
        }
        if (key.downArrow && multiline) {
            if (cursorRow < lines.length - 1) {
                const targetLine = lines[cursorRow + 1] || '';
                setCursorRow(cursorRow + 1);
                setCursorCol(Math.min(cursorCol, targetLine.length));
            }
            return;
        }
        // Handle Home/End
        if (key.ctrl && input === 'a') {
            setCursorCol(0);
            return;
        }
        if (key.ctrl && input === 'e') {
            const currentLine = lines[cursorRow] || '';
            setCursorCol(currentLine.length);
            return;
        }
        // Handle regular text input
        if (input && !key.ctrl && !key.meta) {
            const currentLine = lines[cursorRow] || '';
            const before = currentLine.slice(0, cursorCol);
            const after = currentLine.slice(cursorCol);
            const newLines = [...lines];
            newLines[cursorRow] = before + input + after;
            updateText(newLines, cursorRow, cursorCol + 1);
        }
    });
    // Render the input with cursor
    const renderLine = (line, rowIndex) => {
        const isCursorLine = rowIndex === cursorRow;
        if (!isCursorLine) {
            // Line without cursor - add prefix for continuation lines
            return (React.createElement(Box, { key: rowIndex },
                React.createElement(Text, null, rowIndex > 0 ? '  ' : ''),
                React.createElement(Text, null, line || ' ')));
        }
        // Line with cursor
        const before = line.slice(0, cursorCol);
        const cursorChar = line[cursorCol] || ' ';
        const after = line.slice(cursorCol + 1);
        return (React.createElement(Box, { key: rowIndex },
            React.createElement(Text, null, rowIndex > 0 ? '  ' : ''),
            React.createElement(Text, null, before),
            React.createElement(Text, { inverse: true }, cursorChar),
            React.createElement(Text, null, after)));
    };
    // Show placeholder when empty
    if (value === '' && placeholder) {
        return (React.createElement(Box, null,
            React.createElement(Text, null, '> '),
            React.createElement(Text, { dimColor: true }, placeholder),
            React.createElement(Text, { inverse: true }, ' ')));
    }
    // Render multiline
    if (multiline) {
        return (React.createElement(Box, { flexDirection: "column" },
            React.createElement(Box, { flexDirection: "row" },
                React.createElement(Text, null, '> '),
                React.createElement(Box, { flexDirection: "column", flexGrow: 1 }, lines.map((line, index) => renderLine(line, index))))));
    }
    // Render single line
    const line = lines[0] || '';
    const before = line.slice(0, cursorCol);
    const cursorChar = line[cursorCol] || ' ';
    const after = line.slice(cursorCol + 1);
    return (React.createElement(Box, null,
        React.createElement(Text, null, '> '),
        React.createElement(Text, null, before),
        React.createElement(Text, { inverse: true }, cursorChar),
        React.createElement(Text, null, after)));
};
export default GeminiTextInput;
//# sourceMappingURL=GeminiTextInput.js.map`,
    mimeType: 'application/javascript',
    size: 8416
  },
  'MergePane.js': {
    content: `import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useApp } from 'ink';
import { execSync } from 'child_process';
import CleanTextInput from './CleanTextInput.js';
export default function MergePane({ pane, onComplete, onCancel, mainBranch }) {
    const { exit } = useApp();
    const [status, setStatus] = useState('checking');
    const [commandHistory, setCommandHistory] = useState([]);
    const [error, setError] = useState(null);
    const [conflictFiles, setConflictFiles] = useState([]);
    const [showResolutionPrompt, setShowResolutionPrompt] = useState(false);
    const [agentPrompt, setAgentPrompt] = useState('');
    const [showAgentPromptInput, setShowAgentPromptInput] = useState(false);
    const [commitMessage, setCommitMessage] = useState('');
    const [showCommitInput, setShowCommitInput] = useState(false);
    const addCommandOutput = (command, output, error) => {
        setCommandHistory(prev => [...prev, {
                command,
                output,
                error,
                timestamp: new Date()
            }]);
    };
    const runCommand = (command, cwd) => {
        try {
            const output = execSync(command, {
                cwd: cwd || pane.worktreePath,
                encoding: 'utf8',
                stdio: 'pipe'
            });
            addCommandOutput(command, output);
            return { success: true, output };
        }
        catch (err) {
            const errorMsg = err.stderr || err.message;
            addCommandOutput(command, '', errorMsg);
            return { success: false, output: '', error: errorMsg };
        }
    };
    const checkForConflicts = (cwd) => {
        const result = runCommand('git status --porcelain', cwd);
        if (result.success) {
            const conflicts = result.output
                .split('\\n')
                .filter(line => line.startsWith('UU ') || line.startsWith('AA '))
                .map(line => line.substring(3).trim());
            if (conflicts.length > 0) {
                setConflictFiles(conflicts);
                return true;
            }
        }
        return false;
    };
    const generateCommitMessage = async () => {
        const apiKey = process.env.OPENROUTER_API_KEY;
        if (!apiKey) {
            return \`chore: merge \${pane.slug} into \${mainBranch}\`;
        }
        try {
            const diff = runCommand('git diff --staged');
            if (!diff.success) {
                return \`chore: merge \${pane.slug} into \${mainBranch}\`;
            }
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': \`Bearer \${apiKey}\`,
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    model: 'openai/gpt-4o-mini',
                    messages: [{
                            role: 'user',
                            content: \`Generate a concise, semantic commit message for these changes. Follow conventional commits format (feat:, fix:, chore:, etc). Be specific about what changed:\\n\\n\${diff.output.substring(0, 4000)}\`
                        }],
                    max_tokens: 100,
                    temperature: 0.3,
                }),
            });
            const data = await response.json();
            return data.choices?.[0]?.message?.content?.trim() || \`chore: merge \${pane.slug} into \${mainBranch}\`;
        }
        catch {
            return \`chore: merge \${pane.slug} into \${mainBranch}\`;
        }
    };
    const performMerge = async () => {
        setStatus('checking');
        // Step 1: Check for uncommitted changes in the worktree
        const statusResult = runCommand('git status --porcelain');
        if (statusResult.success && statusResult.output.trim()) {
            setStatus('uncommitted-changes');
            // Generate commit message
            setStatus('committing');
            const message = await generateCommitMessage();
            setCommitMessage(message);
            // Stage and commit changes in the worktree
            runCommand('git add -A');
            const commitResult = runCommand(\`git commit -m "\${message}"\`);
            if (!commitResult.success) {
                setError('Failed to commit changes');
                setStatus('error');
                return;
            }
        }
        // Step 2: Get the main repository path (parent of .dmux/worktrees)
        const mainRepoPath = pane.worktreePath?.replace(/\\/\\.dmux\\/worktrees\\/[^/]+$/, '');
        if (!mainRepoPath) {
            setError('Could not determine main repository path');
            setStatus('error');
            return;
        }
        // Step 3: Switch to main repository and checkout main branch
        setStatus('switching-branch');
        const checkoutResult = runCommand(\`git checkout \${mainBranch}\`, mainRepoPath);
        if (!checkoutResult.success) {
            // If main is already checked out, that's fine
            if (!checkoutResult.error?.includes('already on')) {
                setError(\`Failed to switch to \${mainBranch} branch: \${checkoutResult.error}\`);
                setStatus('error');
                return;
            }
        }
        // Step 4: Attempt merge in the main repository
        setStatus('merging');
        const mergeResult = runCommand(\`git merge \${pane.slug} --no-ff\`, mainRepoPath);
        if (!mergeResult.success) {
            // Check if it's a merge conflict
            if (mergeResult.error?.includes('Automatic merge failed') || checkForConflicts(mainRepoPath)) {
                setStatus('merge-conflict');
                setShowResolutionPrompt(true);
                return;
            }
            else {
                setError('Merge failed: ' + mergeResult.error);
                setStatus('error');
                return;
            }
        }
        // Step 5: Success - worktree cleanup will happen if user confirms pane closure
        setStatus('success');
    };
    const handleAgentResolution = () => {
        setShowResolutionPrompt(false);
        setShowAgentPromptInput(true);
    };
    const submitAgentResolution = () => {
        setShowAgentPromptInput(false);
        setStatus('resolving-with-agent');
        // Get the main repository path
        const mainRepoPath = pane.worktreePath?.replace(/\\/\\.dmux\\/worktrees\\/[^/]+$/, '');
        // Exit the app and launch agent with conflict resolution prompt
        const fullPrompt = agentPrompt || \`Fix the merge conflicts in the following files: \${conflictFiles.join(', ')}. Resolve them appropriately based on the changes from branch \${pane.slug} (\${pane.prompt}) and ensure the code remains functional.\`;
        // Clear screen and exit
        process.stdout.write('\\x1b[2J\\x1b[H');
        // Launch Claude to resolve conflicts in the main repository
        try {
            execSync(\`claude "\${fullPrompt}" --permission-mode=acceptEdits\`, {
                stdio: 'inherit',
                cwd: mainRepoPath || process.cwd()
            });
        }
        catch {
            // Try opencode as fallback
            try {
                execSync(\`echo "\${fullPrompt}" | opencode\`, {
                    stdio: 'inherit',
                    cwd: mainRepoPath || process.cwd()
                });
            }
            catch { }
        }
        exit();
    };
    const handleManualResolution = () => {
        setShowResolutionPrompt(false);
        setStatus('manual-resolution');
        // Show instructions and exit
        process.stdout.write('\\x1b[2J\\x1b[H');
        exit();
    };
    useEffect(() => {
        performMerge();
    }, []);
    useInput((input, key) => {
        if (key.escape) {
            onCancel();
            return;
        }
        if (showResolutionPrompt && !showAgentPromptInput) {
            if (input === 'a' || input === 'A') {
                handleAgentResolution();
            }
            else if (input === 'm' || input === 'M') {
                handleManualResolution();
            }
            else if (input === 'c' || input === 'C') {
                onCancel();
            }
        }
        if (status === 'success') {
            if (input === 'y' || input === 'Y' || key.return) {
                onComplete();
            }
            else if (input === 'n' || input === 'N') {
                onCancel();
            }
        }
        if (status === 'error' && key.return) {
            onCancel();
        }
    });
    const getStatusColor = (s) => {
        switch (s) {
            case 'error':
            case 'merge-conflict':
                return 'red';
            case 'success':
                return 'green';
            case 'checking':
            case 'committing':
            case 'switching-branch':
            case 'merging':
            case 'completing':
                return 'yellow';
            default:
                return 'white';
        }
    };
    const getStatusText = (s) => {
        switch (s) {
            case 'checking': return 'Checking repository status...';
            case 'uncommitted-changes': return 'Found uncommitted changes, committing...';
            case 'committing': return \`Committing changes: \${commitMessage}\`;
            case 'switching-branch': return \`Switching to \${mainBranch} branch...\`;
            case 'merging': return \`Merging \${pane.slug} into \${mainBranch}...\`;
            case 'merge-conflict': return 'Merge conflict detected!';
            case 'conflict-resolution-prompt': return 'Choose conflict resolution method';
            case 'resolving-with-agent': return 'Launching agent to resolve conflicts...';
            case 'manual-resolution': return 'Manual resolution selected';
            case 'completing': return 'Cleaning up worktree and branch...';
            case 'success': return 'Merge completed successfully!';
            case 'error': return \`Error: \${error}\`;
            default: return '';
        }
    };
    return (React.createElement(Box, { flexDirection: "column", padding: 1 },
        React.createElement(Box, { marginBottom: 1 },
            React.createElement(Text, { bold: true, color: "cyan" },
                "Merging: ",
                pane.slug,
                " \\u2192 ",
                mainBranch)),
        React.createElement(Box, { borderStyle: "round", borderColor: "gray", flexDirection: "column", padding: 1, marginBottom: 1 },
            React.createElement(Text, { color: getStatusColor(status), bold: true },
                "Status: ",
                getStatusText(status))),
        commandHistory.length > 0 && (React.createElement(Box, { borderStyle: "single", borderColor: "gray", flexDirection: "column", padding: 1, marginBottom: 1, height: 10 },
            React.createElement(Text, { dimColor: true }, "Command Output:"),
            commandHistory.slice(-5).map((cmd, i) => (React.createElement(Box, { key: i, flexDirection: "column" },
                React.createElement(Text, { color: "blue" },
                    "$ ",
                    cmd.command),
                cmd.output && React.createElement(Text, { dimColor: true }, cmd.output.substring(0, 200)),
                cmd.error && React.createElement(Text, { color: "red" }, cmd.error.substring(0, 200))))))),
        showResolutionPrompt && !showAgentPromptInput && (React.createElement(Box, { borderStyle: "double", borderColor: "yellow", flexDirection: "column", padding: 1 },
            React.createElement(Text, { color: "yellow", bold: true }, "Merge Conflict Resolution Required"),
            React.createElement(Text, null, "Conflicted files:"),
            conflictFiles.map(file => (React.createElement(Text, { key: file, color: "red" },
                "  \\u2022 ",
                file))),
            React.createElement(Text, null, " "),
            React.createElement(Text, null, "Choose resolution method:"),
            React.createElement(Text, { color: "cyan" }, "  (A) Resolve with AI agent"),
            React.createElement(Text, { color: "green" }, "  (M) Resolve manually"),
            React.createElement(Text, { color: "gray" }, "  (C) Cancel merge"))),
        showAgentPromptInput && (React.createElement(Box, { borderStyle: "round", borderColor: "cyan", flexDirection: "column", padding: 1 },
            React.createElement(Text, null, "Enter prompt for agent (or press Enter for default):"),
            React.createElement(CleanTextInput, { value: agentPrompt, onChange: setAgentPrompt, onSubmit: submitAgentResolution, placeholder: \`Fix merge conflicts from \${pane.slug} branch\` }))),
        status === 'success' && (React.createElement(Box, { borderStyle: "double", borderColor: "green", flexDirection: "column", padding: 1 },
            React.createElement(Text, { color: "green", bold: true }, "\\u2713 Merge completed successfully!"),
            React.createElement(Text, null,
                "Branch ",
                pane.slug,
                " has been merged into ",
                mainBranch),
            React.createElement(Text, null, " "),
            React.createElement(Text, null,
                "Close the pane \\"",
                pane.slug,
                "\\"? (Y/n)"))),
        status === 'error' && (React.createElement(Box, { borderStyle: "double", borderColor: "red", flexDirection: "column", padding: 1 },
            React.createElement(Text, { color: "red", bold: true }, "\\u2717 Merge failed"),
            React.createElement(Text, null, error),
            React.createElement(Text, null, " "),
            React.createElement(Text, { dimColor: true }, "Press Enter to return to main menu")))));
}
//# sourceMappingURL=MergePane.js.map`,
    mimeType: 'application/javascript',
    size: 13852
  },
  'MultilineTextInput.js': {
    content: `import React, { useState, useEffect, useCallback } from 'react';
import { Box, Text, useInput, useFocus } from 'ink';
const MultilineTextInput = ({ value, onChange, onSubmit, placeholder = 'Type your message...' }) => {
    const { isFocused } = useFocus({ autoFocus: true });
    const [cursorPosition, setCursorPosition] = useState(0);
    // Keep cursor in bounds
    useEffect(() => {
        if (cursorPosition > value.length) {
            setCursorPosition(value.length);
        }
    }, [value.length, cursorPosition]);
    const getCurrentLineAndColumn = useCallback(() => {
        let lineNumber = 0;
        let columnNumber = 0;
        let charCount = 0;
        const lines = value.split('\\n');
        for (let i = 0; i < lines.length; i++) {
            const lineLength = lines[i].length;
            if (charCount + lineLength >= cursorPosition) {
                lineNumber = i;
                columnNumber = cursorPosition - charCount;
                break;
            }
            charCount += lineLength + 1; // +1 for newline
        }
        return { lineNumber, columnNumber, lines };
    }, [value, cursorPosition]);
    const positionFromLineColumn = (lineNumber, columnNumber, lines) => {
        let position = 0;
        for (let i = 0; i < lineNumber && i < lines.length; i++) {
            position += lines[i].length + 1; // +1 for newline
        }
        if (lineNumber < lines.length) {
            position += Math.min(columnNumber, lines[lineNumber].length);
        }
        return position;
    };
    useInput((input, key) => {
        if (!isFocused)
            return;
        // Handle escape
        if (key.escape) {
            onChange('');
            setCursorPosition(0);
            return;
        }
        // Handle submit
        if (key.return && key.shift) {
            onSubmit?.();
            return;
        }
        // Handle enter (new line)
        if (key.return) {
            const before = value.slice(0, cursorPosition);
            const after = value.slice(cursorPosition);
            onChange(before + '\\n' + after);
            setCursorPosition(cursorPosition + 1);
            return;
        }
        // Handle backspace
        if (key.backspace) {
            if (cursorPosition > 0) {
                const before = value.slice(0, cursorPosition - 1);
                const after = value.slice(cursorPosition);
                onChange(before + after);
                setCursorPosition(cursorPosition - 1);
            }
            return;
        }
        // Handle delete
        if (key.delete) {
            if (cursorPosition < value.length) {
                const before = value.slice(0, cursorPosition);
                const after = value.slice(cursorPosition + 1);
                onChange(before + after);
            }
            return;
        }
        // Handle left arrow
        if (key.leftArrow) {
            if (key.meta || key.ctrl) {
                // Move to beginning of line
                const { lineNumber, lines } = getCurrentLineAndColumn();
                const newPosition = positionFromLineColumn(lineNumber, 0, lines);
                setCursorPosition(newPosition);
            }
            else {
                setCursorPosition(Math.max(0, cursorPosition - 1));
            }
            return;
        }
        // Handle right arrow
        if (key.rightArrow) {
            if (key.meta || key.ctrl) {
                // Move to end of line
                const { lineNumber, lines } = getCurrentLineAndColumn();
                const lineLength = lines[lineNumber]?.length || 0;
                const newPosition = positionFromLineColumn(lineNumber, lineLength, lines);
                setCursorPosition(newPosition);
            }
            else {
                setCursorPosition(Math.min(value.length, cursorPosition + 1));
            }
            return;
        }
        // Handle up arrow
        if (key.upArrow) {
            const { lineNumber, columnNumber, lines } = getCurrentLineAndColumn();
            if (lineNumber > 0) {
                const targetLine = lineNumber - 1;
                const targetColumn = Math.min(columnNumber, lines[targetLine].length);
                const newPosition = positionFromLineColumn(targetLine, targetColumn, lines);
                setCursorPosition(newPosition);
            }
            return;
        }
        // Handle down arrow
        if (key.downArrow) {
            const { lineNumber, columnNumber, lines } = getCurrentLineAndColumn();
            if (lineNumber < lines.length - 1) {
                const targetLine = lineNumber + 1;
                const targetColumn = Math.min(columnNumber, lines[targetLine].length);
                const newPosition = positionFromLineColumn(targetLine, targetColumn, lines);
                setCursorPosition(newPosition);
            }
            return;
        }
        // Handle ctrl+a (home)
        if (key.ctrl && input === 'a') {
            const { lineNumber, lines } = getCurrentLineAndColumn();
            const newPosition = positionFromLineColumn(lineNumber, 0, lines);
            setCursorPosition(newPosition);
            return;
        }
        // Handle ctrl+e (end)
        if (key.ctrl && input === 'e') {
            const { lineNumber, lines } = getCurrentLineAndColumn();
            const lineLength = lines[lineNumber]?.length || 0;
            const newPosition = positionFromLineColumn(lineNumber, lineLength, lines);
            setCursorPosition(newPosition);
            return;
        }
        // Handle regular text input
        if (input && !key.ctrl && !key.meta) {
            const before = value.slice(0, cursorPosition);
            const after = value.slice(cursorPosition);
            onChange(before + input + after);
            setCursorPosition(cursorPosition + input.length);
        }
    });
    // Render the text with cursor
    const renderContent = () => {
        if (!value && placeholder) {
            return (React.createElement(Box, null,
                React.createElement(Text, { dimColor: true }, placeholder),
                React.createElement(Text, { inverse: true }, ' ')));
        }
        const lines = value.split('\\n');
        const { lineNumber: cursorLine, columnNumber: cursorCol } = getCurrentLineAndColumn();
        return (React.createElement(Box, { flexDirection: "column" }, lines.map((line, index) => {
            const isFirstLine = index === 0;
            const isCursorLine = index === cursorLine;
            if (!isCursorLine) {
                return (React.createElement(Box, { key: index },
                    !isFirstLine && React.createElement(Text, null, '  '),
                    React.createElement(Text, null, line || ' ')));
            }
            // Render line with cursor
            const before = line.slice(0, cursorCol);
            const atCursor = line[cursorCol] || ' ';
            const after = line.slice(cursorCol + 1);
            return (React.createElement(Box, { key: index },
                !isFirstLine && React.createElement(Text, null, '  '),
                React.createElement(Text, null, before),
                React.createElement(Text, { inverse: true }, atCursor),
                React.createElement(Text, null, after)));
        })));
    };
    return (React.createElement(Box, { flexDirection: "row", alignItems: "flex-start" },
        React.createElement(Text, null, '> '),
        React.createElement(Box, { flexGrow: 1 }, renderContent())));
};
export default MultilineTextInput;
//# sourceMappingURL=MultilineTextInput.js.map`,
    mimeType: 'application/javascript',
    size: 7643
  },
  'PaneAnalyzer.js': {
    content: `import { execSync } from 'child_process';
export class PaneAnalyzer {
    apiKey;
    constructor() {
        this.apiKey = process.env.OPENROUTER_API_KEY || '';
    }
    /**
     * Captures the last N lines from a tmux pane
     */
    capturePaneContent(paneId, lines = 50) {
        try {
            // Capture pane content with line history
            // -p prints to stdout, -S -<lines> starts from <lines> lines back
            const content = execSync(\`tmux capture-pane -t '\${paneId}' -p -S -\${lines}\`, { encoding: 'utf8', stdio: 'pipe' });
            return content;
        }
        catch (error) {
            // Failed to capture pane content
            return '';
        }
    }
    /**
     * Stage 1: Determines the state of the pane
     */
    async determineState(content, signal) {
        if (!this.apiKey) {
            // API key not set
            return 'in_progress';
        }
        const systemPrompt = \`You are analyzing terminal output to determine its current state.
IMPORTANT: Focus primarily on the LAST 10 LINES of the output, as that's where the current state is shown.

Return a JSON object with a "state" field containing exactly one of these three values:
- "option_dialog": ONLY when specific options/choices are clearly presented
- "in_progress": When there are progress indicators showing active work
- "open_prompt": DEFAULT state - use this unless you're certain it's one of the above

OPTION DIALOG - Must have clear choices presented:
- "Continue? [y/n]"
- "Select: 1) Create 2) Edit 3) Cancel"
- "[A]ccept, [R]eject, [E]dit"
- Menu with numbered/lettered options
- Clear list of specific keys/choices to select

IN PROGRESS - Look for these in the BOTTOM 10 LINES:
- KEY INDICATOR: "(esc to interrupt)" or "esc to cancel" = ALWAYS in_progress
- Progress symbols with ANY action word: ✶ ⏺ ✽ ⏳ 🔄 followed by any word ending in "ing..."
- Common progress words: "Working..." "Loading..." "Processing..." "Running..." "Building..."
- Claude Code's creative words: "Pondering..." "Crunching..." "Flibbergibberating..." etc.
- ANY word ending in "ing..." with progress symbols
- Active progress bars or percentages
- The phrase "esc to interrupt" anywhere = definitely in_progress

OPEN PROMPT - The DEFAULT state:
- Empty prompts: "> "
- Questions waiting for input
- Any prompt line without specific options
- Static UI elements like "⏵⏵ accept edits on" (without "esc to interrupt")
- When there's no clear progress or options

CRITICAL:
1. Check the BOTTOM 10 lines first - that's where the current state appears
2. If you see "(esc to interrupt)" ANYWHERE = it's in_progress
3. When uncertain, default to "open_prompt"\`;
        try {
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': \`Bearer \${this.apiKey}\`,
                    'Content-Type': 'application/json',
                    'HTTP-Referer': 'https://github.com/dmux/dmux',
                    'X-Title': 'dmux',
                },
                body: JSON.stringify({
                    model: 'x-ai/grok-4-fast:free',
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: \`Analyze this terminal output and return a JSON object with the state:\\n\\n\${content}\` }
                    ],
                    temperature: 0.1,
                    max_tokens: 20,
                    response_format: { type: 'json_object' },
                }),
                signal
            });
            if (!response.ok) {
                const errorText = await response.text();
                // API error
                return 'in_progress';
            }
            const data = await response.json();
            const result = JSON.parse(data.choices?.[0]?.message?.content || '{}');
            // Validate the state
            const state = result.state;
            if (state === 'option_dialog' || state === 'open_prompt' || state === 'in_progress') {
                return state;
            }
            return 'in_progress';
        }
        catch (error) {
            // Failed to determine state
            return 'in_progress';
        }
    }
    /**
     * Stage 2: Extract option details if state is option_dialog
     */
    async extractOptions(content, signal) {
        if (!this.apiKey) {
            return {};
        }
        const systemPrompt = \`You are analyzing an option dialog in a terminal.
Extract the following and return as JSON:
1. The question being asked
2. Each available option with:
   - The action/choice description
   - The exact keys to press (could be letters, numbers, arrow keys + enter, etc.)
   - Any additional context

Return a JSON object with:
- question: The question or prompt text
- options: Array of {action, keys, description}
- potential_harm: {has_risk, description} if there's risk of harm

EXAMPLES:
Input: "Delete all files? [y/n]"
Output: {
  "question": "Delete all files?",
  "options": [
    {"action": "Yes", "keys": ["y"]},
    {"action": "No", "keys": ["n"]}
  ],
  "potential_harm": {"has_risk": true, "description": "Will delete all files"}
}

Input: "Select option:\\n1. Create file\\n2. Edit file\\n3. Cancel"
Output: {
  "question": "Select option:",
  "options": [
    {"action": "Create file", "keys": ["1"]},
    {"action": "Edit file", "keys": ["2"]},
    {"action": "Cancel", "keys": ["3"]}
  ]
}

Input: "[A]ccept edits, [R]eject, [E]dit manually"
Output: {
  "question": "Choose action for edits",
  "options": [
    {"action": "Accept edits", "keys": ["a", "A"]},
    {"action": "Reject", "keys": ["r", "R"]},
    {"action": "Edit manually", "keys": ["e", "E"]}
  ]
}\`;
        try {
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': \`Bearer \${this.apiKey}\`,
                    'Content-Type': 'application/json',
                    'HTTP-Referer': 'https://github.com/dmux/dmux',
                    'X-Title': 'dmux',
                },
                body: JSON.stringify({
                    model: 'x-ai/grok-4-fast:free',
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: \`Extract the option details from this dialog and return as JSON:\\n\\n\${content}\` }
                    ],
                    temperature: 0.1,
                    max_tokens: 300,
                    response_format: { type: 'json_object' },
                }),
                signal
            });
            if (!response.ok) {
                // API error in option extraction
                return {};
            }
            const data = await response.json();
            const result = JSON.parse(data.choices?.[0]?.message?.content || '{}');
            return {
                question: result.question,
                options: result.options?.map((opt) => ({
                    action: opt.action,
                    keys: Array.isArray(opt.keys) ? opt.keys : [opt.keys],
                    description: opt.description
                })),
                potentialHarm: result.potential_harm ? {
                    hasRisk: result.potential_harm.has_risk,
                    description: result.potential_harm.description
                } : undefined
            };
        }
        catch (error) {
            // Failed to extract options
            return {};
        }
    }
    /**
     * Stage 3: Extract summary when state is open_prompt (idle)
     */
    async extractSummary(content, signal) {
        if (!this.apiKey) {
            return undefined;
        }
        const systemPrompt = \`You are analyzing terminal output from an AI coding agent (Claude Code or opencode).
The agent is now idle and waiting for the next prompt.

Your task: Provide a 1 paragraph or shorter summary of what the agent communicated to the user before going idle.

Focus on:
- What the agent just finished doing or said
- Any results, conclusions, or feedback provided
- Keep it concise (1-2 sentences max)
- Use past tense ("completed", "fixed", "created", etc.)

Return a JSON object with a "summary" field.

Examples:
- "Completed refactoring the authentication module and fixed TypeScript errors."
- "Created the new user dashboard component with responsive design."
- "Build succeeded with no errors. All tests passed."
- "Unable to find the specified file. Waiting for clarification."

If there's no meaningful content or the output is unclear, return an empty summary.\`;
        try {
            const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': \`Bearer \${this.apiKey}\`,
                    'Content-Type': 'application/json',
                    'HTTP-Referer': 'https://github.com/dmux/dmux',
                    'X-Title': 'dmux',
                },
                body: JSON.stringify({
                    model: 'x-ai/grok-4-fast:free',
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: \`Extract the summary from this terminal output:\\n\\n\${content}\` }
                    ],
                    temperature: 0.1,
                    max_tokens: 100,
                    response_format: { type: 'json_object' },
                }),
                signal
            });
            if (!response.ok) {
                return undefined;
            }
            const data = await response.json();
            const result = JSON.parse(data.choices?.[0]?.message?.content || '{}');
            return result.summary || undefined;
        }
        catch (error) {
            return undefined;
        }
    }
    /**
     * Main analysis function that captures and analyzes a pane
     */
    async analyzePane(paneId, signal) {
        // Capture the pane content (50 lines for state detection)
        const content = this.capturePaneContent(paneId, 50);
        if (!content) {
            return { state: 'in_progress' };
        }
        // Stage 1: Determine the state
        const state = await this.determineState(content, signal);
        // If it's an option dialog, extract option details
        if (state === 'option_dialog') {
            const optionDetails = await this.extractOptions(content, signal);
            return {
                state,
                ...optionDetails
            };
        }
        // If it's open_prompt (idle), extract summary
        if (state === 'open_prompt') {
            const summary = await this.extractSummary(content, signal);
            return {
                state,
                summary
            };
        }
        // Otherwise just return the state (in_progress)
        return { state };
    }
}
//# sourceMappingURL=PaneAnalyzer.js.map`,
    mimeType: 'application/javascript',
    size: 11125
  },
  'SimpleEnhancedInput.js': {
    content: `import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useStdout } from 'ink';
import { execSync } from 'child_process';
import path from 'path';
import stringWidth from 'string-width';
import chalk from 'chalk';
const SimpleEnhancedInput = ({ value, onChange, placeholder = '', onSubmit, onCancel, isActive = true, workingDirectory = process.cwd() }) => {
    const [cursorPosition, setCursorPosition] = useState(0);
    const [showAutocomplete, setShowAutocomplete] = useState(false);
    const [autocompleteQuery, setAutocompleteQuery] = useState('');
    const [autocompleteStartPos, setAutocompleteStartPos] = useState(0);
    const [fileMatches, setFileMatches] = useState([]);
    const [selectedMatchIndex, setSelectedMatchIndex] = useState(0);
    const [displayValue, setDisplayValue] = useState(value);
    const { stdout } = useStdout();
    const terminalWidth = stdout?.columns || 80;
    const [pastedContent, setPastedContent] = useState(new Map());
    // Update cursor when value changes externally
    useEffect(() => {
        // Only update cursor to end if value actually changed and we're not already editing
        if (value.length > 0 && cursorPosition === 0) {
            // This is initial value, keep cursor at 0
        }
        else if (value === '') {
            setCursorPosition(0);
        }
    }, [value]);
    // Helper function to check if text looks like a paste that should be formatted
    const shouldFormatPaste = (text) => {
        // Only format if it's a large paste, not single newlines
        // Single newline = user pressing shift+enter
        // Multiple lines with content = likely a paste
        if (text === '\\n')
            return false; // Single newline is never a paste
        const hasMultipleLines = text.includes('\\n') && text.length > 1;
        const isVeryLong = text.length > 100;
        // Check for code-like patterns that might break display
        const hasSpecialChars = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]/.test(text);
        const hasAnsiCodes = /\\x1b\\[[0-9;]*[a-zA-Z]/.test(text);
        return hasMultipleLines || isVeryLong || hasSpecialChars || hasAnsiCodes;
    };
    // Helper function to process pasted text
    const processPastedText = (text) => {
        if (!shouldFormatPaste(text)) {
            return text;
        }
        // Generate a unique ID for this paste
        const pasteId = pastedContent.size + 1;
        // Store the actual content
        const newPastedContent = new Map(pastedContent);
        newPastedContent.set(pasteId, text);
        setPastedContent(newPastedContent);
        // Count lines in the pasted content
        const lineCount = (text.match(/\\n/g) || []).length + 1;
        // Return placeholder text
        return \`[#\${pasteId} pasted \${lineCount} lines]\`;
    };
    // Helper function to get the actual value with pasted content restored
    const getActualValue = () => {
        let actualValue = displayValue;
        // Replace all placeholders with actual content
        pastedContent.forEach((content, id) => {
            const placeholder = \`[#\${id} pasted \${(content.match(/\\n/g) || []).length + 1} lines]\`;
            actualValue = actualValue.replace(placeholder, content);
        });
        return actualValue;
    };
    // Update display value when value prop changes
    useEffect(() => {
        setDisplayValue(value);
        // Clear pasted content when value is cleared
        if (value === '') {
            setPastedContent(new Map());
        }
    }, [value]);
    // Search for files when autocomplete query changes or when @ is typed
    useEffect(() => {
        if (showAutocomplete) {
            searchFiles(autocompleteQuery);
        }
        else {
            setFileMatches([]);
        }
    }, [autocompleteQuery, showAutocomplete]);
    const searchFiles = async (query) => {
        try {
            // Directories to exclude from search
            const excludeDirs = [
                'node_modules',
                '.git',
                'dist',
                'build',
                '.next',
                '.nuxt',
                '.cache',
                'coverage',
                '.vscode',
                '.idea',
                'vendor',
                'target',
                '.pnpm-store',
                '__pycache__',
                '.pytest_cache',
                '.tox',
                'venv',
                '.venv',
                'env',
                '.env'
            ];
            // Build exclude arguments for find command
            const excludeArgs = excludeDirs.map(dir => \`-path "*/\${dir}" -prune -o\`).join(' ');
            // If query is empty, show root directory files
            let searchCmd;
            let dirSearchCmd;
            // Check if query is a directory path (ends with /)
            const isDirectoryPath = query.endsWith('/');
            if (query === '') {
                // Show files and directories in the root of the working directory (excluding common dirs)
                searchCmd = \`find "\${workingDirectory}" -maxdepth 1 \\\\( \${excludeArgs} -type f -print \\\\) 2>/dev/null | head -20\`;
                dirSearchCmd = \`find "\${workingDirectory}" -maxdepth 1 \\\\( \${excludeArgs} -type d -print \\\\) 2>/dev/null | grep -v "^\${workingDirectory}$" | head -10\`;
            }
            else if (isDirectoryPath) {
                // Navigate into directory - show contents of the specified directory
                const dirPath = path.join(workingDirectory, query.slice(0, -1)); // Remove trailing slash
                searchCmd = \`find "\${dirPath}" -maxdepth 1 \\\\( \${excludeArgs} -type f -print \\\\) 2>/dev/null | head -20\`;
                dirSearchCmd = \`find "\${dirPath}" -maxdepth 1 \\\\( \${excludeArgs} -type d -print \\\\) 2>/dev/null | grep -v "^\${dirPath}$" | head -10\`;
            }
            else {
                // Search for files matching the query (excluding common dirs)
                searchCmd = \`find "\${workingDirectory}" \\\\( \${excludeArgs} -type f -name "*\${query}*" -print \\\\) 2>/dev/null | head -20\`;
                dirSearchCmd = \`find "\${workingDirectory}" \\\\( \${excludeArgs} -type d -name "*\${query}*" -print \\\\) 2>/dev/null | head -10\`;
            }
            let fileResults = [];
            let dirResults = [];
            try {
                fileResults = execSync(searchCmd, { encoding: 'utf-8' }).trim().split('\\n').filter(Boolean);
            }
            catch { }
            try {
                dirResults = execSync(dirSearchCmd, { encoding: 'utf-8' }).trim().split('\\n').filter(Boolean);
            }
            catch { }
            const matches = [];
            // Helper to check if path contains excluded directories
            const isExcluded = (filepath) => {
                const excludedPatterns = [
                    'node_modules', '.git', 'dist', 'build', '.next', '.nuxt',
                    '.cache', 'coverage', '.vscode', '.idea', 'vendor', 'target',
                    '.pnpm-store', '__pycache__', '.pytest_cache', '.tox',
                    'venv', '.venv', 'env', '.env'
                ];
                return excludedPatterns.some(pattern => filepath.includes(\`/\${pattern}/\`) || filepath.endsWith(\`/\${pattern}\`));
            };
            // Process directory matches
            for (const dirPath of dirResults) {
                if (isExcluded(dirPath))
                    continue;
                const relativePath = path.relative(workingDirectory, dirPath);
                if (relativePath && !relativePath.startsWith('..')) {
                    // When browsing within a directory, adjust the display path
                    let displayPath = relativePath;
                    if (isDirectoryPath && query) {
                        // We're inside a subdirectory, show just the item name
                        displayPath = path.basename(dirPath);
                    }
                    matches.push({
                        path: dirPath,
                        displayPath: displayPath + '/',
                        type: 'directory'
                    });
                }
            }
            // Process file matches
            for (const filePath of fileResults) {
                if (isExcluded(filePath))
                    continue;
                const relativePath = path.relative(workingDirectory, filePath);
                if (relativePath && !relativePath.startsWith('..')) {
                    // When browsing within a directory, adjust the display path
                    let displayPath = relativePath;
                    if (isDirectoryPath && query) {
                        // We're inside a subdirectory, show just the item name
                        displayPath = path.basename(filePath);
                    }
                    matches.push({
                        path: filePath,
                        displayPath: displayPath,
                        type: 'file'
                    });
                }
            }
            // Sort by relevance
            matches.sort((a, b) => {
                const aScore = a.displayPath.length;
                const bScore = b.displayPath.length;
                return aScore - bScore;
            });
            setFileMatches(matches.slice(0, 10));
            setSelectedMatchIndex(0);
        }
        catch (error) {
            setFileMatches([]);
        }
    };
    const insertText = (text, position, isPaste = false) => {
        // Process text if it's a paste
        const processedText = isPaste ? processPastedText(text) : text;
        const before = displayValue.slice(0, position);
        const after = displayValue.slice(position);
        const newDisplayValue = before + processedText + after;
        setDisplayValue(newDisplayValue);
        // Update the actual value with processed text (placeholder for pastes)
        const newValue = before + processedText + after;
        onChange(newValue);
        // Update cursor position - just move by the length of inserted text
        // Don't add any special handling for wrapping
        const newCursorPos = position + processedText.length;
        setCursorPosition(newCursorPos);
    };
    const deleteText = (start, end) => {
        const before = displayValue.slice(0, start);
        const after = displayValue.slice(end);
        const newDisplayValue = before + after;
        setDisplayValue(newDisplayValue);
        onChange(newDisplayValue);
        setCursorPosition(start);
    };
    const moveCursor = (position) => {
        const clampedPosition = Math.max(0, Math.min(displayValue.length, position));
        setCursorPosition(clampedPosition);
    };
    // Gemini CLI-style buffer system with proper line tracking
    const getBuffer = (text, width) => {
        const lines = [];
        let charPosition = 0;
        const charToLineMap = [];
        // Split by actual newlines first
        const logicalLines = text.split('\\n');
        for (let logicalIdx = 0; logicalIdx < logicalLines.length; logicalIdx++) {
            const logicalLine = logicalLines[logicalIdx];
            if (logicalLine.length === 0) {
                // Empty line
                lines.push('');
                charToLineMap[charPosition] = { line: lines.length - 1, col: 0 };
                charPosition += 1; // for the newline
            }
            else {
                // Break this logical line into visual lines
                let remaining = logicalLine;
                let isFirstWrap = true;
                while (remaining.length > 0) {
                    let lineContent = '';
                    let charsUsed = 0;
                    // Try to fit as many complete words as possible
                    const words = remaining.split(' ');
                    let wordIndex = 0;
                    while (wordIndex < words.length) {
                        const word = words[wordIndex];
                        const separator = (wordIndex === 0 || lineContent === '') ? '' : ' ';
                        const testContent = lineContent + separator + word;
                        if (stringWidth(testContent) <= width) {
                            lineContent = testContent;
                            charsUsed += (separator + word).length;
                            wordIndex++;
                        }
                        else {
                            // This word doesn't fit
                            if (lineContent === '') {
                                // Word is longer than line width, break it
                                let charCount = 0;
                                for (let i = 0; i < word.length; i++) {
                                    const testChar = word.slice(0, i + 1);
                                    if (stringWidth(testChar) <= width) {
                                        charCount = i + 1;
                                    }
                                    else {
                                        break;
                                    }
                                }
                                lineContent = word.slice(0, Math.max(1, charCount));
                                charsUsed = lineContent.length;
                            }
                            break;
                        }
                    }
                    // Add this visual line
                    lines.push(lineContent);
                    // Map character positions to line/col
                    for (let i = 0; i < charsUsed; i++) {
                        charToLineMap[charPosition + i] = {
                            line: lines.length - 1,
                            col: i
                        };
                    }
                    // Move to next part
                    remaining = remaining.slice(charsUsed).trimStart();
                    charPosition += charsUsed;
                    // Skip spaces that were trimmed
                    const originalRemaining = logicalLine.slice(charPosition - (logicalIdx === 0 ? 0 : logicalIdx));
                    const spacesToSkip = originalRemaining.length - remaining.length - charsUsed;
                    if (spacesToSkip > 0 && !isFirstWrap) {
                        charPosition += spacesToSkip;
                    }
                    isFirstWrap = false;
                }
            }
            // Add newline mapping if not last logical line
            if (logicalIdx < logicalLines.length - 1) {
                charToLineMap[charPosition] = {
                    line: lines.length - 1,
                    col: lines[lines.length - 1]?.length || 0
                };
                charPosition += 1;
            }
        }
        // Handle cursor at end
        if (charPosition <= text.length) {
            charToLineMap[text.length] = {
                line: Math.max(0, lines.length - 1),
                col: lines[lines.length - 1]?.length || 0
            };
        }
        return { lines, charToLineMap };
    };
    const findWordBoundary = (text, position, direction) => {
        const wordRegex = /\\w/;
        let pos = position;
        if (direction === 'left') {
            // Skip any non-word chars
            while (pos > 0 && !wordRegex.test(text[pos - 1])) {
                pos--;
            }
            // Skip the word
            while (pos > 0 && wordRegex.test(text[pos - 1])) {
                pos--;
            }
        }
        else {
            // Skip any non-word chars
            while (pos < text.length && !wordRegex.test(text[pos])) {
                pos++;
            }
            // Skip the word
            while (pos < text.length && wordRegex.test(text[pos])) {
                pos++;
            }
        }
        return pos;
    };
    const completeFileReference = (match) => {
        const before = displayValue.slice(0, autocompleteStartPos);
        const after = displayValue.slice(cursorPosition);
        // Build the complete path to insert
        let completePath;
        if (autocompleteQuery.endsWith('/')) {
            // We're in a subdirectory, need to build the full path
            completePath = autocompleteQuery + match.displayPath.replace(/\\/$/, ''); // Remove trailing slash from directories
        }
        else {
            // Use the relative path from working directory
            completePath = path.relative(workingDirectory, match.path);
        }
        const newDisplayValue = before + completePath + after;
        setDisplayValue(newDisplayValue);
        onChange(newDisplayValue);
        setCursorPosition(autocompleteStartPos + completePath.length);
        setShowAutocomplete(false);
        setAutocompleteQuery('');
    };
    useInput((input, key) => {
        // Only handle input when active
        if (!isActive)
            return;
        // Handle autocomplete navigation
        if (showAutocomplete) {
            if (key.escape) {
                setShowAutocomplete(false);
                setAutocompleteQuery('');
                return;
            }
            else if (key.upArrow) {
                setSelectedMatchIndex(Math.max(0, selectedMatchIndex - 1));
                return;
            }
            else if (key.downArrow) {
                setSelectedMatchIndex(Math.min(fileMatches.length - 1, selectedMatchIndex + 1));
                return;
            }
            else if (key.rightArrow) {
                // Navigate into directory with right arrow
                if (fileMatches.length > 0) {
                    const selectedMatch = fileMatches[selectedMatchIndex];
                    if (selectedMatch.type === 'directory') {
                        // Build the full path for navigation
                        let newQuery;
                        if (autocompleteQuery.endsWith('/')) {
                            // We're already in a directory, append the selected subdirectory
                            newQuery = autocompleteQuery + selectedMatch.displayPath;
                        }
                        else if (autocompleteQuery) {
                            // We have a search query, replace it with the full path
                            const relativePath = path.relative(workingDirectory, selectedMatch.path);
                            newQuery = relativePath + '/';
                        }
                        else {
                            // We're at root, use the display path
                            newQuery = selectedMatch.displayPath;
                        }
                        setAutocompleteQuery(newQuery);
                        // Trigger a new search within this directory
                        searchFiles(newQuery);
                    }
                }
                return;
            }
            else if (key.leftArrow) {
                // Navigate back/up one directory level with left arrow
                if (autocompleteQuery.includes('/')) {
                    // Remove the last directory segment
                    const segments = autocompleteQuery.split('/');
                    segments.pop(); // Remove last segment
                    if (segments.length > 0) {
                        segments.pop(); // Remove the directory we're going back from
                        const newQuery = segments.length > 0 ? segments.join('/') + '/' : '';
                        setAutocompleteQuery(newQuery);
                        searchFiles(newQuery);
                    }
                    else {
                        // Go back to root
                        setAutocompleteQuery('');
                        searchFiles('');
                    }
                }
                else if (autocompleteQuery !== '') {
                    // Go back to root if we have a query but no slashes
                    setAutocompleteQuery('');
                    searchFiles('');
                }
                return;
            }
            else if (key.return || key.tab) {
                if (fileMatches.length > 0) {
                    completeFileReference(fileMatches[selectedMatchIndex]);
                }
                return;
            }
        }
        // Handle special keys
        if (key.escape) {
            onCancel?.();
            return;
        }
        if (key.shift && key.return) {
            // Insert newline for multiline input
            // Force insert a newline character directly into the value
            const before = displayValue.slice(0, cursorPosition);
            const after = displayValue.slice(cursorPosition);
            const newValue = before + '\\n' + after;
            setDisplayValue(newValue);
            onChange(newValue);
            setCursorPosition(cursorPosition + 1);
            return;
        }
        if (key.return && !key.shift) {
            // Get the actual value with pasted content restored before submitting
            const actualValue = getActualValue();
            onChange(actualValue);
            onSubmit?.();
            return;
        }
        // Buffer-based navigation like Gemini CLI
        if (!showAutocomplete && key.upArrow) {
            const inputWidth = Math.max(1, terminalWidth - 4);
            const buffer = getBuffer(displayValue, inputWidth);
            const currentPos = buffer.charToLineMap[cursorPosition] || { line: 0, col: 0 };
            if (currentPos.line > 0) {
                const targetLine = currentPos.line - 1;
                const targetLineLength = buffer.lines[targetLine].length;
                const targetColumn = Math.min(currentPos.col, targetLineLength);
                // Find character position for this line/column
                let newCursorPos = 0;
                for (let charPos = 0; charPos < displayValue.length; charPos++) {
                    const mapped = buffer.charToLineMap[charPos];
                    if (mapped && mapped.line === targetLine && mapped.col === targetColumn) {
                        newCursorPos = charPos;
                        break;
                    }
                }
                moveCursor(newCursorPos);
            }
            return;
        }
        if (!showAutocomplete && key.downArrow) {
            const inputWidth = Math.max(1, terminalWidth - 4);
            const buffer = getBuffer(displayValue, inputWidth);
            const currentPos = buffer.charToLineMap[cursorPosition] || { line: 0, col: 0 };
            if (currentPos.line < buffer.lines.length - 1) {
                const targetLine = currentPos.line + 1;
                const targetLineLength = buffer.lines[targetLine].length;
                const targetColumn = Math.min(currentPos.col, targetLineLength);
                // Find character position for this line/column
                let newCursorPos = displayValue.length;
                for (let charPos = 0; charPos <= displayValue.length; charPos++) {
                    const mapped = buffer.charToLineMap[charPos];
                    if (mapped && mapped.line === targetLine && mapped.col === targetColumn) {
                        newCursorPos = charPos;
                        break;
                    }
                }
                moveCursor(newCursorPos);
            }
            else {
                // At last line, move to end
                moveCursor(displayValue.length);
            }
            return;
        }
        // Cursor movement
        if (key.leftArrow) {
            if (key.meta || key.alt || key.option) {
                // Move to previous word
                const newPos = findWordBoundary(displayValue, cursorPosition, 'left');
                moveCursor(newPos);
            }
            else {
                // Regular left movement - skip over newlines
                if (cursorPosition > 0) {
                    moveCursor(cursorPosition - 1);
                }
            }
            return;
        }
        if (key.rightArrow) {
            if (key.meta || key.alt || key.option) {
                // Move to next word
                const newPos = findWordBoundary(displayValue, cursorPosition, 'right');
                moveCursor(newPos);
            }
            else {
                // Regular right movement - skip over newlines
                if (cursorPosition < displayValue.length) {
                    moveCursor(cursorPosition + 1);
                }
            }
            return;
        }
        // Home/End keys - Ctrl+A / Ctrl+E
        if (key.ctrl && input === 'a') {
            moveCursor(0);
            return;
        }
        if (key.ctrl && input === 'e') {
            moveCursor(displayValue.length);
            return;
        }
        // Deletion
        if (key.backspace || key.delete) {
            if (key.meta || key.alt || key.option) {
                // Delete word
                const wordStart = findWordBoundary(displayValue, cursorPosition, 'left');
                deleteText(wordStart, cursorPosition);
            }
            else if (cursorPosition > 0) {
                deleteText(cursorPosition - 1, cursorPosition);
            }
            return;
        }
        // Text input
        if (input && !key.ctrl && !key.meta) {
            // Detect paste by checking if input is unusually long or contains special characters
            const isPaste = input.length > 1 && shouldFormatPaste(input);
            // Use input as-is - terminal wrapping is visual only, not actual newlines
            const filteredInput = input;
            // Check for @ symbol to trigger autocomplete
            if (filteredInput === '@') {
                setShowAutocomplete(true);
                setAutocompleteStartPos(cursorPosition + 1);
                setAutocompleteQuery('');
                insertText(filteredInput, cursorPosition, false);
            }
            else if (showAutocomplete) {
                // Update autocomplete query
                insertText(filteredInput, cursorPosition, isPaste);
                const newQuery = displayValue.slice(autocompleteStartPos, cursorPosition + 1) + filteredInput;
                setAutocompleteQuery(newQuery);
            }
            else {
                insertText(filteredInput, cursorPosition, isPaste);
            }
        }
    });
    // Gemini CLI-style display with proper buffer-based cursor calculation
    const getDisplayWithCursor = () => {
        const inputWidth = Math.max(1, terminalWidth - 4);
        const buffer = getBuffer(displayValue, inputWidth);
        // Get cursor position from the character map
        const cursorPos = buffer.charToLineMap[cursorPosition] || { line: 0, col: 0 };
        const cursorLine = cursorPos.line;
        const cursorColumn = cursorPos.col;
        // Handle empty input
        if (buffer.lines.length === 0 || (buffer.lines.length === 1 && buffer.lines[0] === '')) {
            return (React.createElement(Box, null,
                React.createElement(Text, null, chalk.inverse(' ')),
                placeholder && React.createElement(Text, { dimColor: true }, placeholder)));
        }
        return (React.createElement(Box, { flexDirection: "column" }, buffer.lines.map((line, idx) => {
            if (idx === cursorLine) {
                // Line with cursor - exact Gemini CLI approach
                const beforeCursor = line.slice(0, cursorColumn);
                const atCursor = line[cursorColumn] || ' ';
                const afterCursor = line.slice(cursorColumn + 1);
                return (React.createElement(Box, { key: idx },
                    React.createElement(Text, null, beforeCursor),
                    React.createElement(Text, null, chalk.inverse(atCursor)),
                    React.createElement(Text, null, afterCursor)));
            }
            else {
                return React.createElement(Text, { key: idx }, line);
            }
        })));
    };
    return (React.createElement(Box, { flexDirection: "column" },
        React.createElement(Box, null, displayValue ? (getDisplayWithCursor()) : (React.createElement(React.Fragment, null,
            React.createElement(Text, { inverse: true }, " "),
            placeholder && React.createElement(Text, { dimColor: true }, placeholder)))),
        showAutocomplete && fileMatches.length > 0 && (React.createElement(Box, { flexDirection: "column", marginTop: 1, borderStyle: "single", borderColor: "cyan", paddingX: 1 },
            React.createElement(Text, { color: "cyan", dimColor: true }, autocompleteQuery.endsWith('/')
                ? \`Browsing: @\${autocompleteQuery}\`
                : autocompleteQuery
                    ? \`Files matching: @\${autocompleteQuery}\`
                    : 'Files in current directory:'),
            fileMatches.map((match, index) => (React.createElement(Box, { key: match.path },
                React.createElement(Text, { color: index === selectedMatchIndex ? 'cyan' : 'gray' },
                    index === selectedMatchIndex ? '▶ ' : '  ',
                    match.displayPath)))),
            React.createElement(Text, { dimColor: true, italic: true }, "\\u2191\\u2193 select \\u2022 \\u2192 enter directory \\u2022 \\u2190 go back \\u2022 Tab/Enter complete \\u2022 Esc cancel")))));
};
export default SimpleEnhancedInput;
//# sourceMappingURL=SimpleEnhancedInput.js.map`,
    mimeType: 'application/javascript',
    size: 29480
  },
  'SimpleGeminiInput.js': {
    content: `import React, { useState, useEffect } from 'react';
import { Box, Text, useInput, useFocus } from 'ink';
const SimpleGeminiInput = ({ value, onChange, onSubmit, onCancel, multiline = false, placeholder = '' }) => {
    const { isFocused } = useFocus({ autoFocus: true });
    const [cursorOffset, setCursorOffset] = useState(0);
    // Keep cursor in bounds when value changes
    useEffect(() => {
        if (cursorOffset > value.length) {
            setCursorOffset(value.length);
        }
    }, [value, cursorOffset]);
    useInput((input, key) => {
        if (!isFocused)
            return;
        // Handle special keys
        if (key.escape) {
            onCancel?.();
            return;
        }
        if (key.return && !multiline) {
            onSubmit?.();
            return;
        }
        if (key.return && multiline && !key.shift) {
            // Add newline in multiline mode
            const before = value.slice(0, cursorOffset);
            const after = value.slice(cursorOffset);
            onChange(before + '\\n' + after);
            setCursorOffset(cursorOffset + 1);
            return;
        }
        if (key.return && multiline && key.shift) {
            // Shift+Enter submits in multiline mode
            onSubmit?.();
            return;
        }
        // Handle backspace - delete character BEFORE cursor
        if (key.backspace) {
            if (cursorOffset > 0) {
                const before = value.slice(0, cursorOffset - 1);
                const after = value.slice(cursorOffset);
                onChange(before + after);
                setCursorOffset(cursorOffset - 1);
            }
            return;
        }
        // Handle delete - delete character AT cursor
        if (key.delete) {
            if (cursorOffset < value.length) {
                const before = value.slice(0, cursorOffset);
                const after = value.slice(cursorOffset + 1);
                onChange(before + after);
                // Cursor stays in same position
            }
            return;
        }
        // Handle arrow keys
        if (key.leftArrow) {
            if (cursorOffset > 0) {
                setCursorOffset(cursorOffset - 1);
            }
            return;
        }
        if (key.rightArrow) {
            if (cursorOffset < value.length) {
                setCursorOffset(cursorOffset + 1);
            }
            return;
        }
        // Handle up/down for multiline
        if (multiline) {
            const lines = value.split('\\n');
            let currentPos = 0;
            let currentLine = 0;
            let colInLine = 0;
            // Find current line and column
            for (let i = 0; i < lines.length; i++) {
                const lineLength = lines[i].length;
                if (currentPos + lineLength >= cursorOffset) {
                    currentLine = i;
                    colInLine = cursorOffset - currentPos;
                    break;
                }
                currentPos += lineLength + 1; // +1 for newline
            }
            if (key.upArrow) {
                if (currentLine > 0) {
                    // Move to previous line, same column or end of line
                    const prevLine = lines[currentLine - 1];
                    const newCol = Math.min(colInLine, prevLine.length);
                    let newOffset = 0;
                    for (let i = 0; i < currentLine - 1; i++) {
                        newOffset += lines[i].length + 1;
                    }
                    newOffset += newCol;
                    setCursorOffset(newOffset);
                }
                else {
                    // Already at first line, move to start
                    setCursorOffset(0);
                }
                return;
            }
            if (key.downArrow) {
                if (currentLine < lines.length - 1) {
                    // Move to next line, same column or end of line
                    const nextLine = lines[currentLine + 1];
                    const newCol = Math.min(colInLine, nextLine.length);
                    let newOffset = 0;
                    for (let i = 0; i <= currentLine; i++) {
                        newOffset += lines[i].length + 1;
                    }
                    newOffset += newCol;
                    setCursorOffset(newOffset);
                }
                else {
                    // Already at last line, move to end
                    setCursorOffset(value.length);
                }
                return;
            }
        }
        // Handle Home/End
        if (key.ctrl && input === 'a') {
            if (multiline) {
                // Move to start of current line
                const beforeCursor = value.slice(0, cursorOffset);
                const lastNewline = beforeCursor.lastIndexOf('\\n');
                setCursorOffset(lastNewline === -1 ? 0 : lastNewline + 1);
            }
            else {
                setCursorOffset(0);
            }
            return;
        }
        if (key.ctrl && input === 'e') {
            if (multiline) {
                // Move to end of current line
                const afterCursor = value.slice(cursorOffset);
                const nextNewline = afterCursor.indexOf('\\n');
                if (nextNewline === -1) {
                    setCursorOffset(value.length);
                }
                else {
                    setCursorOffset(cursorOffset + nextNewline);
                }
            }
            else {
                setCursorOffset(value.length);
            }
            return;
        }
        // Handle regular text input
        if (input && !key.ctrl && !key.meta) {
            const before = value.slice(0, cursorOffset);
            const after = value.slice(cursorOffset);
            onChange(before + input + after);
            setCursorOffset(cursorOffset + input.length);
        }
    });
    // Render the display with cursor
    const renderDisplay = () => {
        // Show placeholder when empty
        if (value === '' && placeholder) {
            return (React.createElement(React.Fragment, null,
                React.createElement(Text, { dimColor: true }, placeholder),
                React.createElement(Text, { inverse: true }, ' ')));
        }
        // For multiline, split and render each line
        if (multiline) {
            const lines = value.split('\\n');
            let currentPos = 0;
            const elements = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const lineStart = currentPos;
                const lineEnd = currentPos + line.length;
                if (i > 0) {
                    elements.push(React.createElement(Text, { key: \`indent-\${i}\` }, '  '));
                }
                if (cursorOffset >= lineStart && cursorOffset <= lineEnd) {
                    // This line contains the cursor
                    const posInLine = cursorOffset - lineStart;
                    const before = line.slice(0, posInLine);
                    const cursorChar = line[posInLine] || ' ';
                    const after = line.slice(posInLine + 1);
                    elements.push(React.createElement(React.Fragment, { key: \`line-\${i}\` },
                        React.createElement(Text, null, before),
                        React.createElement(Text, { inverse: true }, cursorChar),
                        React.createElement(Text, null, after)));
                }
                else {
                    // Normal line without cursor
                    elements.push(React.createElement(Text, { key: \`line-\${i}\` }, line || ' '));
                }
                // Add newline representation except for last line
                if (i < lines.length - 1) {
                    elements.push(React.createElement(Text, { key: \`newline-\${i}\` }, '\\n'));
                }
                currentPos = lineEnd + 1; // +1 for newline
            }
            // Handle cursor at very end after a newline
            if (cursorOffset === value.length && value.endsWith('\\n')) {
                elements.push(React.createElement(Text, { key: "indent-end" }, '  '));
                elements.push(React.createElement(Text, { key: "cursor-end", inverse: true }, ' '));
            }
            return React.createElement(React.Fragment, null, elements);
        }
        // Single line rendering
        const before = value.slice(0, cursorOffset);
        const cursorChar = value[cursorOffset] || ' ';
        const after = value.slice(cursorOffset + 1);
        return (React.createElement(React.Fragment, null,
            React.createElement(Text, null, before),
            React.createElement(Text, { inverse: true }, cursorChar),
            React.createElement(Text, null, after)));
    };
    return (React.createElement(Box, null,
        React.createElement(Text, null, '> '),
        renderDisplay()));
};
export default SimpleGeminiInput;
//# sourceMappingURL=SimpleGeminiInput.js.map`,
    mimeType: 'application/javascript',
    size: 9085
  },
  'StyledTextInput.js': {
    content: `import React from 'react';
import { Box, Text } from 'ink';
import TextInput from 'ink-text-input';
const StyledTextInput = ({ value, onChange, onSubmit, placeholder = 'Type your message...' }) => {
    return (React.createElement(Box, null,
        React.createElement(Text, null, '> '),
        React.createElement(TextInput, { value: value, onChange: onChange, onSubmit: onSubmit, placeholder: placeholder, showCursor: true })));
};
export default StyledTextInput;
//# sourceMappingURL=StyledTextInput.js.map`,
    mimeType: 'application/javascript',
    size: 511
  },
  '_plugin-vue_export-helper.css': {
    content: `*{margin:0;padding:0;box-sizing:border-box}:root{--bg-gradient-start: #0f0f23;--bg-gradient-mid: #1a1a2e;--bg-gradient-end: #16213e;--text-primary: #e0e0e0;--text-secondary: #a0a0a0;--text-tertiary: #808080;--text-dim: #606060;--text-dimmer: #666;--text-bright: #fff;--border-color: rgba(255, 255, 255, .1);--border-accent: rgba(255, 140, 0, .3);--card-bg: rgba(255, 255, 255, .05);--card-border: rgba(255, 255, 255, .1);--header-bg: rgba(255, 255, 255, .05);--input-bg: rgba(255, 255, 255, .05);--input-border: rgba(255, 255, 255, .12);--input-focus-border: rgba(255, 140, 0, .5);--input-focus-bg: rgba(255, 255, 255, .08);--input-focus-shadow: rgba(255, 140, 0, .1);--button-bg: rgba(200, 210, 230, .15);--button-border: rgba(255, 255, 255, .08);--button-hover-bg: rgba(200, 210, 230, .25);--button-hover-border: rgba(255, 255, 255, .15);--tooltip-bg: rgba(20, 20, 30, .98);--tooltip-border: rgba(255, 255, 255, .15);--hint-bg: rgba(255, 255, 255, .05);--agent-bg: rgba(255, 255, 255, .08);--agent-border: rgba(255, 255, 255, .15);--idle-badge-bg: rgba(255, 255, 255, .08);--idle-badge-border: rgba(255, 255, 255, .1)}[data-theme=light]{--bg-gradient-start: #f0f4f8;--bg-gradient-mid: #e6eef5;--bg-gradient-end: #dce7f0;--text-primary: #1a1a2e;--text-secondary: #4a5568;--text-tertiary: #718096;--text-dim: #a0aec0;--text-dimmer: #cbd5e0;--text-bright: #000;--border-color: rgba(0, 0, 0, .1);--border-accent: rgba(255, 140, 0, .4);--card-bg: rgba(255, 255, 255, .8);--card-border: rgba(0, 0, 0, .08);--header-bg: rgba(255, 255, 255, .9);--input-bg: rgba(255, 255, 255, .6);--input-border: rgba(0, 0, 0, .15);--input-focus-border: rgba(255, 140, 0, .6);--input-focus-bg: rgba(255, 255, 255, .9);--input-focus-shadow: rgba(255, 140, 0, .15);--button-bg: rgba(0, 0, 0, .05);--button-border: rgba(0, 0, 0, .1);--button-hover-bg: rgba(0, 0, 0, .1);--button-hover-border: rgba(0, 0, 0, .2);--tooltip-bg: rgba(255, 255, 255, .98);--tooltip-border: rgba(0, 0, 0, .15);--hint-bg: rgba(0, 0, 0, .03);--agent-bg: rgba(0, 0, 0, .05);--agent-border: rgba(0, 0, 0, .12);--idle-badge-bg: rgba(0, 0, 0, .05);--idle-badge-border: rgba(0, 0, 0, .1)}@keyframes fadeIn{0%{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}@keyframes pulse{0%,to{opacity:1}50%{opacity:.5}}@keyframes slideInFromTop{0%{opacity:0;transform:translateY(-20px)}to{opacity:1;transform:translateY(0)}}body{font-family:-apple-system,BlinkMacSystemFont,SF Pro Display,SF Pro Text,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;background:linear-gradient(135deg,var(--bg-gradient-start) 0%,var(--bg-gradient-mid) 50%,var(--bg-gradient-end) 100%);background-attachment:fixed;color:var(--text-primary);min-height:100vh;display:flex;flex-direction:column;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;transition:background .3s ease,color .3s ease}.container{max-width:1400px;margin:0 auto;padding:40px 20px;width:100%;flex:1;display:flex;flex-direction:column;animation:fadeIn .5s ease-out}header{display:flex;justify-content:space-between;align-items:center;padding:16px 24px;margin-bottom:0;background:var(--header-bg);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);border-bottom:2px solid var(--border-accent);animation:slideInFromTop .6s ease-out;gap:16px}.logo{height:24px;width:auto;flex-shrink:0}h1{font-size:18px;font-weight:600;letter-spacing:-.5px;color:var(--text-primary);flex:1;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:0;max-width:500px;margin:0 auto}.session-info{display:flex;gap:12px;align-items:center;font-size:13px;color:var(--text-secondary);flex-shrink:0}.theme-toggle{background:transparent;border:none;padding:4px;cursor:pointer;transition:all .2s ease;display:flex;align-items:center;justify-content:center;color:var(--text-secondary);flex-shrink:0;width:24px;height:24px}.theme-toggle:hover{color:var(--text-primary);transform:scale(1.1)}.theme-toggle svg{width:20px;height:20px;fill:currentColor}.session-info span{display:flex;align-items:center;gap:6px}.status-indicator{color:#4ade80;font-size:16px;animation:pulse 2s ease-in-out infinite}main{flex:1;padding-top:40px;min-height:0}.panes-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(380px,1fr));gap:24px;margin-bottom:40px}.pane-card{background:var(--card-bg);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border:1px solid var(--card-border);border-radius:12px;padding:12px;position:relative;animation:fadeIn .5s ease-out backwards;color:inherit;display:block}.pane-card:nth-child(1){animation-delay:.1s}.pane-card:nth-child(2){animation-delay:.15s}.pane-card:nth-child(3){animation-delay:.2s}.pane-card:nth-child(4){animation-delay:.25s}.pane-card:nth-child(5){animation-delay:.3s}.pane-card:nth-child(6){animation-delay:.35s}.pane-header{margin-bottom:16px;display:flex;align-items:flex-start;justify-content:space-between;gap:12px;position:relative}.pane-header-content{flex:1;display:flex;flex-direction:column;gap:6px}.action-menu-btn{background:transparent;border:none;color:var(--text-tertiary);font-size:20px;padding:4px 8px;cursor:pointer;transition:all .2s ease;line-height:1;flex-shrink:0}.action-menu-btn:hover{color:var(--text-primary);background:var(--button-hover-bg);border-radius:4px}.action-menu-dropdown{position:absolute;top:32px;right:0;background:var(--tooltip-bg);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border:1px solid var(--tooltip-border);border-radius:8px;padding:4px;z-index:100;min-width:180px;box-shadow:0 8px 24px #0000004d;animation:fadeIn .2s ease-out}.action-menu-item{width:100%;display:flex;align-items:center;gap:8px;padding:8px 12px;background:transparent;border:none;border-radius:4px;color:var(--text-primary);font-size:13px;cursor:pointer;transition:all .15s ease;text-align:left}.action-menu-item:hover:not(:disabled){background:var(--button-hover-bg)}.action-menu-item:disabled{opacity:.5;cursor:not-allowed}.action-icon{font-size:14px;width:16px;text-align:center}.action-label{flex:1}.pane-title-link{display:inline-flex;align-items:center;gap:8px;text-decoration:none;color:inherit;width:fit-content}.pane-title-link:hover .pane-title{text-decoration:underline}.pane-title{font-size:20px;font-weight:600;color:var(--text-bright);letter-spacing:-.3px}.pane-arrow{font-size:16px;color:var(--text-secondary);transition:all .2s ease;opacity:.6}.pane-title-link:hover .pane-arrow{color:#ff8c00;transform:translate(2px);opacity:1}.pane-meta{display:flex;align-items:center;gap:12px}.pane-agent{padding:2px 8px;border-radius:4px;font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:.3px;background:var(--agent-bg);border:1px solid var(--agent-border);color:var(--text-tertiary);white-space:nowrap}.pane-agent.claude{background:#d9775726;border-color:#d977574d;color:#d97757}.pane-agent.opencode{background:#667eea26;border-color:#667eea4d;color:#667eea}.pane-prompt-section{margin-bottom:12px}.pane-prompt-header{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;background:var(--input-bg);border:1px solid var(--input-border);border-radius:6px;cursor:pointer;transition:all .2s ease}.pane-prompt-header:hover{background:var(--input-focus-bg);border-color:var(--input-border)}.prompt-label{font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:.5px;color:var(--text-tertiary)}.expand-icon{font-size:10px;color:var(--text-tertiary);transition:transform .2s ease}.pane-prompt{color:var(--text-secondary);font-size:13px;margin-top:8px;padding:8px 12px;line-height:1.6;background:var(--input-bg);border:1px solid var(--input-border);border-radius:6px;font-family:SF Mono,Monaco,Courier New,monospace}.agent-summary{color:var(--text-secondary);font-size:13px;margin-bottom:12px;padding:10px 12px;line-height:1.5;background:#60a5fa14;border:1px solid rgba(96,165,250,.2);border-radius:6px;font-style:italic}.tooltip{position:absolute;background:var(--tooltip-bg);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border:1px solid var(--tooltip-border);padding:16px;border-radius:12px;z-index:1000;white-space:pre-wrap;max-width:400px;max-height:200px;overflow-y:auto;box-shadow:0 20px 60px #0000004d,0 0 0 1px var(--border-color);font-size:13px;color:var(--text-primary);pointer-events:none;animation:fadeIn .2s ease-out}.pane-status{display:flex;flex-direction:column;gap:10px}.status-item{display:flex;justify-content:space-between;align-items:center;font-size:13px;padding:8px 0}.status-label{color:var(--text-tertiary);font-weight:500}.status-value{display:flex;align-items:center;gap:6px}.status-badge{padding:4px 10px;border-radius:6px;font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:.3px;transition:all .2s ease}.status-badge.working{background:linear-gradient(135deg,#fbbf24,#f59e0b);color:#000;box-shadow:0 2px 8px #fbbf2466}.status-badge.waiting{background:linear-gradient(135deg,#60a5fa,#3b82f6);color:#000;box-shadow:0 2px 8px #60a5fa66}.status-badge.idle{background:var(--idle-badge-bg);color:var(--text-tertiary);border:1px solid var(--idle-badge-border)}.status-badge.running,.status-badge.passed{background:linear-gradient(135deg,#4ade80,#22c55e);color:#000;box-shadow:0 2px 8px #4ade8066}.status-badge.failed{background:linear-gradient(135deg,#f87171,#ef4444);color:#000;box-shadow:0 2px 8px #f8717166}.status-badge.analyzing{background:linear-gradient(135deg,#a78bfa,#8b5cf6);color:#000;box-shadow:0 2px 8px #a78bfa66;animation:pulse 2s ease-in-out infinite}.pane-id{font-family:SF Mono,Monaco,monospace;font-size:10px;color:var(--text-dimmer);font-weight:500;letter-spacing:.2px}.pane-interactive{margin-top:12px}.options-dialog{display:flex;flex-direction:column;gap:12px}.options-question{font-size:14px;font-weight:500;color:var(--text-primary);line-height:1.4}.options-warning{padding:8px 12px;background:#f871711a;border:1px solid rgba(248,113,113,.3);border-radius:6px;color:#fca5a5;font-size:12px;display:flex;align-items:center;gap:6px}.options-buttons{display:flex;flex-wrap:wrap;gap:8px}.option-button{padding:8px 16px;background:linear-gradient(135deg,#60a5fa,#3b82f6);color:#000;border:none;border-radius:6px;font-size:13px;font-weight:600;cursor:pointer;transition:all .2s ease;box-shadow:0 2px 8px #60a5fa4d}.option-button:hover{transform:translateY(-2px);box-shadow:0 4px 12px #60a5fa66}.option-button:active{transform:translateY(0)}.option-button-danger{background:linear-gradient(135deg,#f87171,#ef4444);box-shadow:0 2px 8px #f871714d}.option-button-danger:hover{box-shadow:0 4px 12px #f8717166}.analyzing-state{display:flex;align-items:center;gap:12px;padding:8px 0;color:#a78bfa;font-size:14px;font-weight:500}.loader-spinner{width:20px;height:20px;border:3px solid rgba(167,139,250,.2);border-top-color:#a78bfa;border-radius:50%;animation:spin 1s linear infinite}.prompt-input-wrapper{display:flex;align-items:flex-start;gap:8px;padding:8px;background:var(--input-bg);border:1px solid var(--input-border);border-radius:8px;transition:all .2s ease}.prompt-input-wrapper:focus-within{border-color:var(--input-focus-border);background:var(--input-focus-bg);box-shadow:0 0 0 3px var(--input-focus-shadow)}.queued-message{margin-top:8px;padding:6px 10px;background:#4ade801a;border:1px solid rgba(74,222,128,.3);border-radius:6px;color:#4ade80;font-size:12px;animation:fadeIn .3s ease-out}.prompt-textarea{flex:1;min-height:20px;max-height:150px;padding:0;background:transparent;border:none;color:var(--text-primary);font-family:SF Mono,Monaco,Courier New,monospace;font-size:13px;line-height:1.4;resize:none;overflow-y:auto}.prompt-textarea:focus{outline:none}.prompt-textarea:disabled{opacity:.5;cursor:not-allowed}.prompt-textarea::placeholder{color:var(--text-dimmer)}.send-button{flex-shrink:0;width:28px;height:28px;padding:6px;background:var(--button-bg);color:var(--text-secondary);border:1px solid var(--button-border);border-radius:50%;cursor:pointer;transition:all .2s ease;display:flex;align-items:center;justify-content:center}.send-button:hover:not(:disabled){background:var(--button-hover-bg);border-color:var(--button-hover-border)}.send-button:active:not(:disabled){transform:scale(.92)}.send-button:disabled{opacity:.3;cursor:not-allowed}.send-button svg{width:100%;height:100%;fill:currentColor}.button-loader{width:14px;height:14px;border:2px solid rgba(0,0,0,.2);border-top-color:#000;border-radius:50%;animation:spin .8s linear infinite}.dev-server-status{margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,.08);display:flex;align-items:center;gap:8px;font-size:12px}.dev-link{color:#ff8c00;text-decoration:none;font-weight:600;transition:color .2s ease}.dev-link:hover{color:orange}.no-panes{text-align:center;padding:100px 20px;color:var(--text-tertiary);animation:fadeIn .6s ease-out}.no-panes p{margin-bottom:16px;font-size:18px;font-weight:500}.hint{font-size:14px;color:var(--text-dim);background:var(--hint-bg);padding:12px 24px;border-radius:12px;display:inline-block;margin-top:8px}footer{padding:12px 0;margin-top:auto;animation:fadeIn .8s ease-out}.footer-info{display:flex;justify-content:space-between;font-size:11px;color:var(--text-dim);padding:0}.footer-info span{display:flex;align-items:center;gap:8px}@media (max-width: 768px){.container{padding:0 16px 24px}header{padding:12px 18px;gap:8px}.logo{height:20px}h1{font-size:14px;max-width:none}.session-info{font-size:11px;gap:8px}.session-info span:not(.status-indicator){display:none}main{padding-top:24px}.panes-grid{grid-template-columns:1fr;gap:16px}.footer-info{flex-direction:column;gap:6px;font-size:10px}}.term-fg-black{color:#000}.term-fg-red{color:#cd3131}.term-fg-green{color:#0dbc79}.term-fg-yellow{color:#e5e510}.term-fg-blue{color:#2472c8}.term-fg-magenta{color:#bc3fbc}.term-fg-cyan{color:#11a8cd}.term-fg-white{color:#e5e5e5}.term-fg-bright-black{color:#666}.term-fg-bright-red{color:#f14c4c}.term-fg-bright-green{color:#23d18b}.term-fg-bright-yellow{color:#f5f543}.term-fg-bright-blue{color:#3b8eea}.term-fg-bright-magenta{color:#d670d6}.term-fg-bright-cyan{color:#29b8db}.term-fg-bright-white{color:#fff}.term-bg-black{background-color:#000}.term-bg-red{background-color:#cd3131}.term-bg-green{background-color:#0dbc79}.term-bg-yellow{background-color:#e5e510}.term-bg-blue{background-color:#2472c8}.term-bg-magenta{background-color:#bc3fbc}.term-bg-cyan{background-color:#11a8cd}.term-bg-white{background-color:#e5e5e5}.term-bold{font-weight:700}.term-dim{opacity:.7}.term-italic{font-style:italic}.term-underline{text-decoration:underline}.term-strikethrough{text-decoration:line-through}.action-dialog-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:#000000b3;backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);display:flex;align-items:center;justify-content:center;z-index:1000;animation:fadeIn .2s ease-out}.action-dialog{background:var(--card-bg);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border:1px solid var(--card-border);border-radius:16px;padding:32px;max-width:540px;width:90%;box-shadow:0 20px 60px #0006;animation:slideInFromTop .3s ease-out}.action-dialog h3{margin:0 0 20px;font-size:24px;font-weight:600;color:var(--text-bright);letter-spacing:-.5px}.action-dialog p{margin:0 0 20px;color:var(--text-secondary);font-size:14px;line-height:1.5}.action-dialog label{display:block;font-size:14px;font-weight:600;color:var(--text-primary);margin-bottom:10px;letter-spacing:-.2px}.action-dialog textarea{width:100%;padding:14px 16px;background:var(--input-bg);border:2px solid var(--input-border);border-radius:10px;color:var(--text-primary);font-family:-apple-system,BlinkMacSystemFont,SF Pro Display,SF Pro Text,Segoe UI,Roboto,sans-serif;font-size:15px;line-height:1.5;resize:vertical;transition:all .2s ease;margin-bottom:20px}.action-dialog textarea:focus{outline:none;border-color:var(--input-focus-border);background:var(--input-focus-bg);box-shadow:0 0 0 4px var(--input-focus-shadow)}.action-dialog textarea::placeholder{color:var(--text-dim);font-style:italic}.dialog-hint{font-size:13px;color:var(--text-tertiary);margin-bottom:16px;display:flex;align-items:center;gap:6px}.dialog-hint kbd{background:var(--button-bg);border:1px solid var(--button-border);border-radius:4px;padding:2px 6px;font-family:SF Mono,Monaco,monospace;font-size:11px;font-weight:600;color:var(--text-primary);box-shadow:0 1px 2px #0000001a}.dialog-loading{display:flex;align-items:center;justify-content:center;gap:12px;padding:24px;color:var(--text-secondary);font-size:15px;font-weight:500}.dialog-loading .loader-spinner{width:24px;height:24px;border:3px solid rgba(96,165,250,.2);border-top-color:#60a5fa;border-radius:50%;animation:spin .8s linear infinite}.dialog-input{width:100%;padding:14px 16px;background:var(--input-bg);border:2px solid var(--input-border);border-radius:10px;color:var(--text-primary);font-family:-apple-system,BlinkMacSystemFont,SF Pro Display,SF Pro Text,Segoe UI,Roboto,sans-serif;font-size:15px;line-height:1.5;transition:all .2s ease;margin-bottom:20px}.dialog-input:focus{outline:none;border-color:var(--input-focus-border);background:var(--input-focus-bg);box-shadow:0 0 0 4px var(--input-focus-shadow)}.dialog-input::placeholder{color:var(--text-dim);font-style:italic}.dialog-buttons{display:flex;gap:12px;justify-content:flex-end}.dialog-btn{padding:12px 24px;border:2px solid var(--button-border);border-radius:10px;background:var(--button-bg);color:var(--text-primary);font-size:15px;font-weight:600;cursor:pointer;transition:all .2s ease}.dialog-btn:hover{background:var(--button-hover-bg);border-color:var(--button-hover-border);transform:translateY(-1px)}.dialog-btn:active{transform:translateY(0)}.dialog-btn:disabled{opacity:.5;cursor:not-allowed;transform:none}.dialog-btn-primary{background:linear-gradient(135deg,#60a5fa,#3b82f6);color:#000;border-color:transparent;box-shadow:0 2px 8px #60a5fa4d}.dialog-btn-primary:hover{transform:translateY(-2px);box-shadow:0 6px 16px #60a5fa80}.dialog-btn-primary:active{transform:translateY(-1px);box-shadow:0 4px 12px #60a5fa66}.dialog-btn-primary:disabled{opacity:.6;transform:none;box-shadow:0 2px 8px #60a5fa33}.choice-options{display:flex;flex-direction:column;gap:8px}.choice-option-btn{width:100%;padding:12px 16px;background:var(--button-bg);border:1px solid var(--button-border);border-radius:8px;color:var(--text-primary);font-size:14px;text-align:left;cursor:pointer;transition:all .2s ease;display:flex;flex-direction:column;gap:4px}.choice-option-btn:hover{background:var(--button-hover-bg);border-color:var(--button-hover-border);transform:translate(4px)}.choice-option-btn.danger{border-color:#f871714d;background:#f871711a}.choice-option-btn.danger:hover{border-color:#f8717180;background:#f8717133}.agent-choices{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin-bottom:20px}.agent-choice-button{padding:16px 20px;background:var(--button-bg);border:2px solid var(--button-border);border-radius:12px;color:var(--text-primary);font-size:15px;font-weight:600;cursor:pointer;transition:all .2s ease;text-align:center;text-transform:capitalize;position:relative;overflow:hidden}.agent-choice-button:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(135deg,#60a5fa1a,#3b82f61a);opacity:0;transition:opacity .2s ease}.agent-choice-button:hover{background:var(--button-hover-bg);border-color:var(--input-focus-border);transform:translateY(-2px);box-shadow:0 4px 12px #60a5fa33}.agent-choice-button:hover:before{opacity:1}.agent-choice-button:active{transform:translateY(0)}.agent-choice-button:disabled{opacity:.5;cursor:not-allowed;transform:none}.option-description{font-size:12px;color:var(--text-tertiary);font-weight:400}.terminal-page{display:flex;flex-direction:column;height:100vh;background:#000}.back-button{color:#e0e0e0;text-decoration:none;font-size:14px;font-weight:500;transition:color .2s;white-space:nowrap;flex-shrink:0}.back-button:hover{color:#fff}.terminal-content{flex:1;overflow:auto;padding:10px}.terminal-page .terminal-output{font-family:JetBrains Mono,SF Mono,Monaco,Cascadia Code,Roboto Mono,monospace;line-height:1.2;color:#f0f0f0;margin:0;min-height:100%}.terminal-row{white-space:pre;margin:0;padding:0;line-height:1.2}.mobile-toolbar{display:flex;gap:6px;padding:8px;background:#1a1a1a;border-bottom:1px solid #333;overflow-x:auto;flex-wrap:nowrap}.toolbar-key{background:#2d2d2d;border:1px solid #444;border-radius:4px;color:#e0e0e0;padding:8px 12px;font-size:13px;font-family:SF Mono,Monaco,monospace;cursor:pointer;flex-shrink:0;min-width:44px;transition:all .15s;-webkit-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent}.toolbar-key:active{background:#3d3d3d;transform:scale(.95)}.toolbar-key.active{background:#667eea;border-color:#667eea;color:#fff}.mobile-input{position:absolute;left:-9999px;width:1px;height:1px;opacity:.01;pointer-events:none}.actions-bar{display:flex;justify-content:flex-end;margin-bottom:20px;padding:0 4px}.create-pane-button{display:flex;align-items:center;gap:8px;padding:10px 20px;background:linear-gradient(135deg,#60a5fa,#3b82f6);color:#000;border:none;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s ease;box-shadow:0 2px 8px #60a5fa4d}.create-pane-button:hover:not(:disabled){transform:translateY(-1px);box-shadow:0 4px 12px #60a5fa66}.create-pane-button:disabled{opacity:.5;cursor:not-allowed;transform:none}.create-pane-button svg{width:16px;height:16px;fill:none;stroke-width:2.5}.modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:#000000b3;backdrop-filter:blur(8px);-webkit-backdrop-filter:blur(8px);display:flex;align-items:center;justify-content:center;z-index:2000;animation:fadeIn .2s ease-out}.modal-dialog{background:var(--card-bg);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);border:1px solid var(--card-border);border-radius:16px;width:90%;max-width:600px;max-height:90vh;overflow:hidden;display:flex;flex-direction:column;box-shadow:0 20px 60px #0006;animation:slideUp .3s ease-out}@keyframes slideUp{0%{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}.modal-header{display:flex;align-items:center;justify-content:space-between;padding:20px 24px;border-bottom:1px solid var(--border-color)}.modal-header h2{font-size:20px;font-weight:600;color:var(--text-primary);margin:0}.modal-close{background:none;border:none;color:var(--text-secondary);font-size:32px;line-height:1;cursor:pointer;padding:0;width:32px;height:32px;display:flex;align-items:center;justify-content:center;border-radius:6px;transition:all .2s ease}.modal-close:hover{background:var(--button-hover-bg);color:var(--text-primary)}.modal-body{padding:24px;overflow-y:auto;flex:1}.form-group{margin-bottom:20px}.form-group:last-child{margin-bottom:0}.form-group label{display:block;font-size:14px;font-weight:600;color:var(--text-primary);margin-bottom:8px}.modal-textarea{width:100%;padding:12px;background:var(--input-bg);border:1px solid var(--input-border);border-radius:8px;color:var(--text-primary);font-size:14px;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,sans-serif;resize:vertical;min-height:100px;transition:all .2s ease}.modal-textarea:focus{outline:none;border-color:var(--input-focus-border);background:var(--input-focus-bg);box-shadow:0 0 0 3px var(--input-focus-shadow)}.modal-textarea:disabled{opacity:.5;cursor:not-allowed}.input-hint{font-size:12px;color:var(--text-tertiary);margin-top:6px}.agent-selector{display:flex;gap:12px}.agent-option{flex:1;display:flex;align-items:center;gap:12px;padding:12px 20px;background:var(--button-bg);border:2px solid var(--button-border);border-radius:8px;color:var(--text-primary);font-size:14px;font-weight:600;text-transform:capitalize;cursor:pointer;transition:all .2s ease}.agent-logo{width:40px;height:40px;flex-shrink:0}.agent-option:hover:not(:disabled){background:var(--button-hover-bg);border-color:var(--button-hover-border)}.agent-option.selected{background:var(--input-focus-bg);border-color:var(--input-focus-border);color:var(--text-bright)}.agent-option:disabled{opacity:.5;cursor:not-allowed}.modal-footer{display:flex;gap:12px;padding:20px 24px;border-top:1px solid var(--border-color);justify-content:flex-end}.modal-button{padding:10px 24px;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:all .2s ease;border:none;display:flex;align-items:center;gap:8px}.modal-button-secondary{background:var(--button-bg);color:var(--text-primary);border:1px solid var(--button-border)}.modal-button-secondary:hover:not(:disabled){background:var(--button-hover-bg);border-color:var(--button-hover-border)}.modal-button-primary{background:var(--input-focus-bg);color:var(--text-bright);border:1px solid var(--input-focus-border)}.modal-button-primary:hover:not(:disabled){background:var(--button-hover-bg);border-color:var(--button-hover-border)}.modal-button:disabled{opacity:.5;cursor:not-allowed}.button-loader{width:16px;height:16px;border:2px solid rgba(255,255,255,.3);border-top-color:#fff;border-radius:50%;animation:spin .6s linear infinite}@keyframes spin{to{transform:rotate(360deg)}}
`,
    mimeType: 'text/css',
    size: 25176
  },
  'chunks/_plugin-vue_export-helper-Cvoq67hi.js': {
    content: `(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const o of r)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?o.credentials="include":r.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(r){if(r.ep)return;r.ep=!0;const o=n(r);fetch(r.href,o)}})();/**
* @vue/shared v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Ge(e){const t=Object.create(null);for(const n of e.split(","))t[n]=1;return n=>n in t}const U=Object.freeze({}),_t=Object.freeze([]),ne=()=>{},wr=()=>!1,Bt=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97),cn=e=>e.startsWith("onUpdate:"),Y=Object.assign,as=(e,t)=>{const n=e.indexOf(t);n>-1&&e.splice(n,1)},Ho=Object.prototype.hasOwnProperty,H=(e,t)=>Ho.call(e,t),M=Array.isArray,it=e=>wn(e)==="[object Map]",xr=e=>wn(e)==="[object Set]",P=e=>typeof e=="function",q=e=>typeof e=="string",tt=e=>typeof e=="symbol",W=e=>e!==null&&typeof e=="object",ds=e=>(W(e)||P(e))&&P(e.then)&&P(e.catch),Sr=Object.prototype.toString,wn=e=>Sr.call(e),ps=e=>wn(e).slice(8,-1),Cr=e=>wn(e)==="[object Object]",hs=e=>q(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,It=Ge(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),Lo=Ge("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"),xn=e=>{const t=Object.create(null);return(n=>t[n]||(t[n]=e(n)))},No=/-\\w/g,ve=xn(e=>e.replace(No,t=>t.slice(1).toUpperCase())),Vo=/\\B([A-Z])/g,ke=xn(e=>e.replace(Vo,"-$1").toLowerCase()),Sn=xn(e=>e.charAt(0).toUpperCase()+e.slice(1)),rt=xn(e=>e?\`on\${Sn(e)}\`:""),Qe=(e,t)=>!Object.is(e,t),mt=(e,...t)=>{for(let n=0;n<e.length;n++)e[n](...t)},fn=(e,t,n,s=!1)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,writable:s,value:n})},Jn=e=>{const t=parseFloat(e);return isNaN(t)?e:t};let Hs;const Wt=()=>Hs||(Hs=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});function gs(e){if(M(e)){const t={};for(let n=0;n<e.length;n++){const s=e[n],r=q(s)?Wo(s):gs(s);if(r)for(const o in r)t[o]=r[o]}return t}else if(q(e)||W(e))return e}const Ko=/;(?![^(]*\\))/g,Uo=/:([^]+)/,Bo=/\\/\\*[^]*?\\*\\//g;function Wo(e){const t={};return e.replace(Bo,"").split(Ko).forEach(n=>{if(n){const s=n.split(Uo);s.length>1&&(t[s[0].trim()]=s[1].trim())}}),t}function ms(e){let t="";if(q(e))t=e;else if(M(e))for(let n=0;n<e.length;n++){const s=ms(e[n]);s&&(t+=s+" ")}else if(W(e))for(const n in e)e[n]&&(t+=n+" ");return t.trim()}const ko="html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot",Go="svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view",qo="annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics",Jo=Ge(ko),Yo=Ge(Go),zo=Ge(qo),Xo="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",Zo=Ge(Xo);function Or(e){return!!e||e===""}const Tr=e=>!!(e&&e.__v_isRef===!0),Qo=e=>q(e)?e:e==null?"":M(e)||W(e)&&(e.toString===Sr||!P(e.toString))?Tr(e)?Qo(e.value):JSON.stringify(e,Er,2):String(e),Er=(e,t)=>Tr(t)?Er(e,t.value):it(t)?{[\`Map(\${t.size})\`]:[...t.entries()].reduce((n,[s,r],o)=>(n[Dn(s,o)+" =>"]=r,n),{})}:xr(t)?{[\`Set(\${t.size})\`]:[...t.values()].map(n=>Dn(n))}:tt(t)?Dn(t):W(t)&&!M(t)&&!Cr(t)?String(t):t,Dn=(e,t="")=>{var n;return tt(e)?\`Symbol(\${(n=e.description)!=null?n:t})\`:e};/**
* @vue/reactivity v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function xe(e,...t){console.warn(\`[Vue warn] \${e}\`,...t)}let de;class ei{constructor(t=!1){this.detached=t,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=de,!t&&de&&(this.index=(de.scopes||(de.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].pause();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].resume();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].resume()}}run(t){if(this._active){const n=de;try{return de=this,t()}finally{de=n}}else xe("cannot run an inactive effect scope.")}on(){++this._on===1&&(this.prevScope=de,de=this)}off(){this._on>0&&--this._on===0&&(de=this.prevScope,this.prevScope=void 0)}stop(t){if(this._active){this._active=!1;let n,s;for(n=0,s=this.effects.length;n<s;n++)this.effects[n].stop();for(this.effects.length=0,n=0,s=this.cleanups.length;n<s;n++)this.cleanups[n]();if(this.cleanups.length=0,this.scopes){for(n=0,s=this.scopes.length;n<s;n++)this.scopes[n].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!t){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0}}}function ti(){return de}let K;const Hn=new WeakSet;class $r{constructor(t){this.fn=t,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,de&&de.active&&de.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,Hn.has(this)&&(Hn.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||Ar(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,Ls(this),Pr(this);const t=K,n=we;K=this,we=!0;try{return this.fn()}finally{K!==this&&xe("Active effect was not restored correctly - this is likely a Vue internal bug."),Ir(this),K=t,we=n,this.flags&=-3}}stop(){if(this.flags&1){for(let t=this.deps;t;t=t.nextDep)_s(t);this.deps=this.depsTail=void 0,Ls(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?Hn.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){Yn(this)&&this.run()}get dirty(){return Yn(this)}}let Mr=0,Rt,Ft;function Ar(e,t=!1){if(e.flags|=8,t){e.next=Ft,Ft=e;return}e.next=Rt,Rt=e}function bs(){Mr++}function ys(){if(--Mr>0)return;if(Ft){let t=Ft;for(Ft=void 0;t;){const n=t.next;t.next=void 0,t.flags&=-9,t=n}}let e;for(;Rt;){let t=Rt;for(Rt=void 0;t;){const n=t.next;if(t.next=void 0,t.flags&=-9,t.flags&1)try{t.trigger()}catch(s){e||(e=s)}t=n}}if(e)throw e}function Pr(e){for(let t=e.deps;t;t=t.nextDep)t.version=-1,t.prevActiveLink=t.dep.activeLink,t.dep.activeLink=t}function Ir(e){let t,n=e.depsTail,s=n;for(;s;){const r=s.prevDep;s.version===-1?(s===n&&(n=r),_s(s),ni(s)):t=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=r}e.deps=t,e.depsTail=n}function Yn(e){for(let t=e.deps;t;t=t.nextDep)if(t.dep.version!==t.version||t.dep.computed&&(Rr(t.dep.computed)||t.dep.version!==t.version))return!0;return!!e._dirty}function Rr(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===Lt)||(e.globalVersion=Lt,!e.isSSR&&e.flags&128&&(!e.deps&&!e._dirty||!Yn(e))))return;e.flags|=2;const t=e.dep,n=K,s=we;K=e,we=!0;try{Pr(e);const r=e.fn(e._value);(t.version===0||Qe(r,e._value))&&(e.flags|=128,e._value=r,t.version++)}catch(r){throw t.version++,r}finally{K=n,we=s,Ir(e),e.flags&=-3}}function _s(e,t=!1){const{dep:n,prevSub:s,nextSub:r}=e;if(s&&(s.nextSub=r,e.prevSub=void 0),r&&(r.prevSub=s,e.nextSub=void 0),n.subsHead===e&&(n.subsHead=r),n.subs===e&&(n.subs=s,!s&&n.computed)){n.computed.flags&=-5;for(let o=n.computed.deps;o;o=o.nextDep)_s(o,!0)}!t&&!--n.sc&&n.map&&n.map.delete(n.key)}function ni(e){const{prevDep:t,nextDep:n}=e;t&&(t.nextDep=n,e.prevDep=void 0),n&&(n.prevDep=t,e.nextDep=void 0)}let we=!0;const Fr=[];function Se(){Fr.push(we),we=!1}function Ce(){const e=Fr.pop();we=e===void 0?!0:e}function Ls(e){const{cleanup:t}=e;if(e.cleanup=void 0,t){const n=K;K=void 0;try{t()}finally{K=n}}}let Lt=0;class si{constructor(t,n){this.sub=t,this.dep=n,this.version=n.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class vs{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0,this.subsHead=void 0}track(t){if(!K||!we||K===this.computed)return;let n=this.activeLink;if(n===void 0||n.sub!==K)n=this.activeLink=new si(K,this),K.deps?(n.prevDep=K.depsTail,K.depsTail.nextDep=n,K.depsTail=n):K.deps=K.depsTail=n,jr(n);else if(n.version===-1&&(n.version=this.version,n.nextDep)){const s=n.nextDep;s.prevDep=n.prevDep,n.prevDep&&(n.prevDep.nextDep=s),n.prevDep=K.depsTail,n.nextDep=void 0,K.depsTail.nextDep=n,K.depsTail=n,K.deps===n&&(K.deps=s)}return K.onTrack&&K.onTrack(Y({effect:K},t)),n}trigger(t){this.version++,Lt++,this.notify(t)}notify(t){bs();try{for(let n=this.subsHead;n;n=n.nextSub)n.sub.onTrigger&&!(n.sub.flags&8)&&n.sub.onTrigger(Y({effect:n.sub},t));for(let n=this.subs;n;n=n.prevSub)n.sub.notify()&&n.sub.dep.notify()}finally{ys()}}}function jr(e){if(e.dep.sc++,e.sub.flags&4){const t=e.dep.computed;if(t&&!e.dep.subs){t.flags|=20;for(let s=t.deps;s;s=s.nextDep)jr(s)}const n=e.dep.subs;n!==e&&(e.prevSub=n,n&&(n.nextSub=e)),e.dep.subsHead===void 0&&(e.dep.subsHead=e),e.dep.subs=e}}const zn=new WeakMap,lt=Symbol("Object iterate"),Xn=Symbol("Map keys iterate"),Nt=Symbol("Array iterate");function Z(e,t,n){if(we&&K){let s=zn.get(e);s||zn.set(e,s=new Map);let r=s.get(n);r||(s.set(n,r=new vs),r.map=s,r.key=n),r.track({target:e,type:t,key:n})}}function Ie(e,t,n,s,r,o){const i=zn.get(e);if(!i){Lt++;return}const l=f=>{f&&f.trigger({target:e,type:t,key:n,newValue:s,oldValue:r,oldTarget:o})};if(bs(),t==="clear")i.forEach(l);else{const f=M(e),p=f&&hs(n);if(f&&n==="length"){const d=Number(s);i.forEach((a,g)=>{(g==="length"||g===Nt||!tt(g)&&g>=d)&&l(a)})}else switch((n!==void 0||i.has(void 0))&&l(i.get(n)),p&&l(i.get(Nt)),t){case"add":f?p&&l(i.get("length")):(l(i.get(lt)),it(e)&&l(i.get(Xn)));break;case"delete":f||(l(i.get(lt)),it(e)&&l(i.get(Xn)));break;case"set":it(e)&&l(i.get(lt));break}}ys()}function pt(e){const t=F(e);return t===e?t:(Z(t,"iterate",Nt),le(e)?t:t.map(Q))}function Cn(e){return Z(e=F(e),"iterate",Nt),e}const ri={__proto__:null,[Symbol.iterator](){return Ln(this,Symbol.iterator,Q)},concat(...e){return pt(this).concat(...e.map(t=>M(t)?pt(t):t))},entries(){return Ln(this,"entries",e=>(e[1]=Q(e[1]),e))},every(e,t){return Ne(this,"every",e,t,void 0,arguments)},filter(e,t){return Ne(this,"filter",e,t,n=>n.map(Q),arguments)},find(e,t){return Ne(this,"find",e,t,Q,arguments)},findIndex(e,t){return Ne(this,"findIndex",e,t,void 0,arguments)},findLast(e,t){return Ne(this,"findLast",e,t,Q,arguments)},findLastIndex(e,t){return Ne(this,"findLastIndex",e,t,void 0,arguments)},forEach(e,t){return Ne(this,"forEach",e,t,void 0,arguments)},includes(...e){return Nn(this,"includes",e)},indexOf(...e){return Nn(this,"indexOf",e)},join(e){return pt(this).join(e)},lastIndexOf(...e){return Nn(this,"lastIndexOf",e)},map(e,t){return Ne(this,"map",e,t,void 0,arguments)},pop(){return Et(this,"pop")},push(...e){return Et(this,"push",e)},reduce(e,...t){return Ns(this,"reduce",e,t)},reduceRight(e,...t){return Ns(this,"reduceRight",e,t)},shift(){return Et(this,"shift")},some(e,t){return Ne(this,"some",e,t,void 0,arguments)},splice(...e){return Et(this,"splice",e)},toReversed(){return pt(this).toReversed()},toSorted(e){return pt(this).toSorted(e)},toSpliced(...e){return pt(this).toSpliced(...e)},unshift(...e){return Et(this,"unshift",e)},values(){return Ln(this,"values",Q)}};function Ln(e,t,n){const s=Cn(e),r=s[t]();return s!==e&&!le(e)&&(r._next=r.next,r.next=()=>{const o=r._next();return o.done||(o.value=n(o.value)),o}),r}const oi=Array.prototype;function Ne(e,t,n,s,r,o){const i=Cn(e),l=i!==e&&!le(e),f=i[t];if(f!==oi[t]){const a=f.apply(e,o);return l?Q(a):a}let p=n;i!==e&&(l?p=function(a,g){return n.call(this,Q(a),g,e)}:n.length>2&&(p=function(a,g){return n.call(this,a,g,e)}));const d=f.call(i,p,s);return l&&r?r(d):d}function Ns(e,t,n,s){const r=Cn(e);let o=n;return r!==e&&(le(e)?n.length>3&&(o=function(i,l,f){return n.call(this,i,l,f,e)}):o=function(i,l,f){return n.call(this,i,Q(l),f,e)}),r[t](o,...s)}function Nn(e,t,n){const s=F(e);Z(s,"iterate",Nt);const r=s[t](...n);return(r===-1||r===!1)&&un(n[0])?(n[0]=F(n[0]),s[t](...n)):r}function Et(e,t,n=[]){Se(),bs();const s=F(e)[t].apply(e,n);return ys(),Ce(),s}const ii=Ge("__proto__,__v_isRef,__isVue"),Dr=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(tt));function li(e){tt(e)||(e=String(e));const t=F(this);return Z(t,"has",e),t.hasOwnProperty(e)}class Hr{constructor(t=!1,n=!1){this._isReadonly=t,this._isShallow=n}get(t,n,s){if(n==="__v_skip")return t.__v_skip;const r=this._isReadonly,o=this._isShallow;if(n==="__v_isReactive")return!r;if(n==="__v_isReadonly")return r;if(n==="__v_isShallow")return o;if(n==="__v_raw")return s===(r?o?Br:Ur:o?Kr:Vr).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(s)?t:void 0;const i=M(t);if(!r){let f;if(i&&(f=ri[n]))return f;if(n==="hasOwnProperty")return li}const l=Reflect.get(t,n,J(t)?t:s);if((tt(n)?Dr.has(n):ii(n))||(r||Z(t,"get",n),o))return l;if(J(l)){const f=i&&hs(n)?l:l.value;return r&&W(f)?Qn(f):f}return W(l)?r?Qn(l):ws(l):l}}class Lr extends Hr{constructor(t=!1){super(!1,t)}set(t,n,s,r){let o=t[n];if(!this._isShallow){const f=De(o);if(!le(s)&&!De(s)&&(o=F(o),s=F(s)),!M(t)&&J(o)&&!J(s))return f?(xe(\`Set operation on key "\${String(n)}" failed: target is readonly.\`,t[n]),!0):(o.value=s,!0)}const i=M(t)&&hs(n)?Number(n)<t.length:H(t,n),l=Reflect.set(t,n,s,J(t)?t:r);return t===F(r)&&(i?Qe(s,o)&&Ie(t,"set",n,s,o):Ie(t,"add",n,s)),l}deleteProperty(t,n){const s=H(t,n),r=t[n],o=Reflect.deleteProperty(t,n);return o&&s&&Ie(t,"delete",n,void 0,r),o}has(t,n){const s=Reflect.has(t,n);return(!tt(n)||!Dr.has(n))&&Z(t,"has",n),s}ownKeys(t){return Z(t,"iterate",M(t)?"length":lt),Reflect.ownKeys(t)}}class Nr extends Hr{constructor(t=!1){super(!0,t)}set(t,n){return xe(\`Set operation on key "\${String(n)}" failed: target is readonly.\`,t),!0}deleteProperty(t,n){return xe(\`Delete operation on key "\${String(n)}" failed: target is readonly.\`,t),!0}}const ci=new Lr,fi=new Nr,ui=new Lr(!0),ai=new Nr(!0),Zn=e=>e,Xt=e=>Reflect.getPrototypeOf(e);function di(e,t,n){return function(...s){const r=this.__v_raw,o=F(r),i=it(o),l=e==="entries"||e===Symbol.iterator&&i,f=e==="keys"&&i,p=r[e](...s),d=n?Zn:t?an:Q;return!t&&Z(o,"iterate",f?Xn:lt),{next(){const{value:a,done:g}=p.next();return g?{value:a,done:g}:{value:l?[d(a[0]),d(a[1])]:d(a),done:g}},[Symbol.iterator](){return this}}}}function Zt(e){return function(...t){{const n=t[0]?\`on key "\${t[0]}" \`:"";xe(\`\${Sn(e)} operation \${n}failed: target is readonly.\`,F(this))}return e==="delete"?!1:e==="clear"?void 0:this}}function pi(e,t){const n={get(r){const o=this.__v_raw,i=F(o),l=F(r);e||(Qe(r,l)&&Z(i,"get",r),Z(i,"get",l));const{has:f}=Xt(i),p=t?Zn:e?an:Q;if(f.call(i,r))return p(o.get(r));if(f.call(i,l))return p(o.get(l));o!==i&&o.get(r)},get size(){const r=this.__v_raw;return!e&&Z(F(r),"iterate",lt),r.size},has(r){const o=this.__v_raw,i=F(o),l=F(r);return e||(Qe(r,l)&&Z(i,"has",r),Z(i,"has",l)),r===l?o.has(r):o.has(r)||o.has(l)},forEach(r,o){const i=this,l=i.__v_raw,f=F(l),p=t?Zn:e?an:Q;return!e&&Z(f,"iterate",lt),l.forEach((d,a)=>r.call(o,p(d),p(a),i))}};return Y(n,e?{add:Zt("add"),set:Zt("set"),delete:Zt("delete"),clear:Zt("clear")}:{add(r){!t&&!le(r)&&!De(r)&&(r=F(r));const o=F(this);return Xt(o).has.call(o,r)||(o.add(r),Ie(o,"add",r,r)),this},set(r,o){!t&&!le(o)&&!De(o)&&(o=F(o));const i=F(this),{has:l,get:f}=Xt(i);let p=l.call(i,r);p?Vs(i,l,r):(r=F(r),p=l.call(i,r));const d=f.call(i,r);return i.set(r,o),p?Qe(o,d)&&Ie(i,"set",r,o,d):Ie(i,"add",r,o),this},delete(r){const o=F(this),{has:i,get:l}=Xt(o);let f=i.call(o,r);f?Vs(o,i,r):(r=F(r),f=i.call(o,r));const p=l?l.call(o,r):void 0,d=o.delete(r);return f&&Ie(o,"delete",r,void 0,p),d},clear(){const r=F(this),o=r.size!==0,i=it(r)?new Map(r):new Set(r),l=r.clear();return o&&Ie(r,"clear",void 0,void 0,i),l}}),["keys","values","entries",Symbol.iterator].forEach(r=>{n[r]=di(r,e,t)}),n}function On(e,t){const n=pi(e,t);return(s,r,o)=>r==="__v_isReactive"?!e:r==="__v_isReadonly"?e:r==="__v_raw"?s:Reflect.get(H(n,r)&&r in s?n:s,r,o)}const hi={get:On(!1,!1)},gi={get:On(!1,!0)},mi={get:On(!0,!1)},bi={get:On(!0,!0)};function Vs(e,t,n){const s=F(n);if(s!==n&&t.call(e,s)){const r=ps(e);xe(\`Reactive \${r} contains both the raw and reactive versions of the same object\${r==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.\`)}}const Vr=new WeakMap,Kr=new WeakMap,Ur=new WeakMap,Br=new WeakMap;function yi(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function _i(e){return e.__v_skip||!Object.isExtensible(e)?0:yi(ps(e))}function ws(e){return De(e)?e:Tn(e,!1,ci,hi,Vr)}function vi(e){return Tn(e,!1,ui,gi,Kr)}function Qn(e){return Tn(e,!0,fi,mi,Ur)}function Fe(e){return Tn(e,!0,ai,bi,Br)}function Tn(e,t,n,s,r){if(!W(e))return xe(\`value cannot be made \${t?"readonly":"reactive"}: \${String(e)}\`),e;if(e.__v_raw&&!(t&&e.__v_isReactive))return e;const o=_i(e);if(o===0)return e;const i=r.get(e);if(i)return i;const l=new Proxy(e,o===2?s:n);return r.set(e,l),l}function ct(e){return De(e)?ct(e.__v_raw):!!(e&&e.__v_isReactive)}function De(e){return!!(e&&e.__v_isReadonly)}function le(e){return!!(e&&e.__v_isShallow)}function un(e){return e?!!e.__v_raw:!1}function F(e){const t=e&&e.__v_raw;return t?F(t):e}function wi(e){return!H(e,"__v_skip")&&Object.isExtensible(e)&&fn(e,"__v_skip",!0),e}const Q=e=>W(e)?ws(e):e,an=e=>W(e)?Qn(e):e;function J(e){return e?e.__v_isRef===!0:!1}function ef(e){return xi(e,!1)}function xi(e,t){return J(e)?e:new Si(e,t)}class Si{constructor(t,n){this.dep=new vs,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=n?t:F(t),this._value=n?t:Q(t),this.__v_isShallow=n}get value(){return this.dep.track({target:this,type:"get",key:"value"}),this._value}set value(t){const n=this._rawValue,s=this.__v_isShallow||le(t)||De(t);t=s?t:F(t),Qe(t,n)&&(this._rawValue=t,this._value=s?t:Q(t),this.dep.trigger({target:this,type:"set",key:"value",newValue:t,oldValue:n}))}}function Ci(e){return J(e)?e.value:e}const Oi={get:(e,t,n)=>t==="__v_raw"?e:Ci(Reflect.get(e,t,n)),set:(e,t,n,s)=>{const r=e[t];return J(r)&&!J(n)?(r.value=n,!0):Reflect.set(e,t,n,s)}};function Wr(e){return ct(e)?e:new Proxy(e,Oi)}class Ti{constructor(t,n,s){this.fn=t,this.setter=n,this._value=void 0,this.dep=new vs(this),this.__v_isRef=!0,this.deps=void 0,this.depsTail=void 0,this.flags=16,this.globalVersion=Lt-1,this.next=void 0,this.effect=this,this.__v_isReadonly=!n,this.isSSR=s}notify(){if(this.flags|=16,!(this.flags&8)&&K!==this)return Ar(this,!0),!0}get value(){const t=this.dep.track({target:this,type:"get",key:"value"});return Rr(this),t&&(t.version=this.dep.version),this._value}set value(t){this.setter?this.setter(t):xe("Write operation failed: computed value is readonly")}}function Ei(e,t,n=!1){let s,r;return P(e)?s=e:(s=e.get,r=e.set),new Ti(s,r,n)}const Qt={},dn=new WeakMap;let ot;function $i(e,t=!1,n=ot){if(n){let s=dn.get(n);s||dn.set(n,s=[]),s.push(e)}else t||xe("onWatcherCleanup() was called when there was no active watcher to associate with.")}function Mi(e,t,n=U){const{immediate:s,deep:r,once:o,scheduler:i,augmentJob:l,call:f}=n,p=$=>{(n.onWarn||xe)("Invalid watch source: ",$,"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")},d=$=>r?$:le($)||r===!1||r===0?Ue($,1):Ue($);let a,g,C,I,E=!1,z=!1;if(J(e)?(g=()=>e.value,E=le(e)):ct(e)?(g=()=>d(e),E=!0):M(e)?(z=!0,E=e.some($=>ct($)||le($)),g=()=>e.map($=>{if(J($))return $.value;if(ct($))return d($);if(P($))return f?f($,2):$();p($)})):P(e)?t?g=f?()=>f(e,2):e:g=()=>{if(C){Se();try{C()}finally{Ce()}}const $=ot;ot=a;try{return f?f(e,3,[I]):e(I)}finally{ot=$}}:(g=ne,p(e)),t&&r){const $=g,X=r===!0?1/0:r;g=()=>Ue($(),X)}const G=ti(),V=()=>{a.stop(),G&&G.active&&as(G.effects,a)};if(o&&t){const $=t;t=(...X)=>{$(...X),V()}}let N=z?new Array(e.length).fill(Qt):Qt;const pe=$=>{if(!(!(a.flags&1)||!a.dirty&&!$))if(t){const X=a.run();if(r||E||(z?X.some((be,te)=>Qe(be,N[te])):Qe(X,N))){C&&C();const be=ot;ot=a;try{const te=[X,N===Qt?void 0:z&&N[0]===Qt?[]:N,I];N=X,f?f(t,3,te):t(...te)}finally{ot=be}}}else a.run()};return l&&l(pe),a=new $r(g),a.scheduler=i?()=>i(pe,!1):pe,I=$=>$i($,!1,a),C=a.onStop=()=>{const $=dn.get(a);if($){if(f)f($,4);else for(const X of $)X();dn.delete(a)}},a.onTrack=n.onTrack,a.onTrigger=n.onTrigger,t?s?pe(!0):N=a.run():i?i(pe.bind(null,!0),!0):a.run(),V.pause=a.pause.bind(a),V.resume=a.resume.bind(a),V.stop=V,V}function Ue(e,t=1/0,n){if(t<=0||!W(e)||e.__v_skip||(n=n||new Map,(n.get(e)||0)>=t))return e;if(n.set(e,t),t--,J(e))Ue(e.value,t,n);else if(M(e))for(let s=0;s<e.length;s++)Ue(e[s],t,n);else if(xr(e)||it(e))e.forEach(s=>{Ue(s,t,n)});else if(Cr(e)){for(const s in e)Ue(e[s],t,n);for(const s of Object.getOwnPropertySymbols(e))Object.prototype.propertyIsEnumerable.call(e,s)&&Ue(e[s],t,n)}return e}/**
* @vue/runtime-core v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const ft=[];function en(e){ft.push(e)}function tn(){ft.pop()}let Vn=!1;function x(e,...t){if(Vn)return;Vn=!0,Se();const n=ft.length?ft[ft.length-1].component:null,s=n&&n.appContext.config.warnHandler,r=Ai();if(s)xt(s,n,11,[e+t.map(o=>{var i,l;return(l=(i=o.toString)==null?void 0:i.call(o))!=null?l:JSON.stringify(o)}).join(""),n&&n.proxy,r.map(({vnode:o})=>\`at <\${In(n,o.type)}>\`).join(\`
\`),r]);else{const o=[\`[Vue warn]: \${e}\`,...t];r.length&&o.push(\`
\`,...Pi(r)),console.warn(...o)}Ce(),Vn=!1}function Ai(){let e=ft[ft.length-1];if(!e)return[];const t=[];for(;e;){const n=t[0];n&&n.vnode===e?n.recurseCount++:t.push({vnode:e,recurseCount:0});const s=e.component&&e.component.parent;e=s&&s.vnode}return t}function Pi(e){const t=[];return e.forEach((n,s)=>{t.push(...s===0?[]:[\`
\`],...Ii(n))}),t}function Ii({vnode:e,recurseCount:t}){const n=t>0?\`... (\${t} recursive calls)\`:"",s=e.component?e.component.parent==null:!1,r=\` at <\${In(e.component,e.type,s)}\`,o=">"+n;return e.props?[r,...Ri(e.props),o]:[r+o]}function Ri(e){const t=[],n=Object.keys(e);return n.slice(0,3).forEach(s=>{t.push(...kr(s,e[s]))}),n.length>3&&t.push(" ..."),t}function kr(e,t,n){return q(t)?(t=JSON.stringify(t),n?t:[\`\${e}=\${t}\`]):typeof t=="number"||typeof t=="boolean"||t==null?n?t:[\`\${e}=\${t}\`]:J(t)?(t=kr(e,F(t.value),!0),n?t:[\`\${e}=Ref<\`,t,">"]):P(t)?[\`\${e}=fn\${t.name?\`<\${t.name}>\`:""}\`]:(t=F(t),n?t:[\`\${e}=\`,t])}const xs={sp:"serverPrefetch hook",bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush",15:"component update",16:"app unmount cleanup function"};function xt(e,t,n,s){try{return s?e(...s):e()}catch(r){kt(r,t,n)}}function He(e,t,n,s){if(P(e)){const r=xt(e,t,n,s);return r&&ds(r)&&r.catch(o=>{kt(o,t,n)}),r}if(M(e)){const r=[];for(let o=0;o<e.length;o++)r.push(He(e[o],t,n,s));return r}else x(\`Invalid value type passed to callWithAsyncErrorHandling(): \${typeof e}\`)}function kt(e,t,n,s=!0){const r=t?t.vnode:null,{errorHandler:o,throwUnhandledErrorInProduction:i}=t&&t.appContext.config||U;if(t){let l=t.parent;const f=t.proxy,p=xs[n];for(;l;){const d=l.ec;if(d){for(let a=0;a<d.length;a++)if(d[a](e,f,p)===!1)return}l=l.parent}if(o){Se(),xt(o,null,10,[e,f,p]),Ce();return}}Fi(e,n,r,s,i)}function Fi(e,t,n,s=!0,r=!1){{const o=xs[t];if(n&&en(n),x(\`Unhandled error\${o?\` during execution of \${o}\`:""}\`),n&&tn(),s)throw e;console.error(e)}}const oe=[];let Ae=-1;const vt=[];let Xe=null,bt=0;const Gr=Promise.resolve();let pn=null;const ji=100;function Di(e){const t=pn||Gr;return e?t.then(this?e.bind(this):e):t}function Hi(e){let t=Ae+1,n=oe.length;for(;t<n;){const s=t+n>>>1,r=oe[s],o=Vt(r);o<e||o===e&&r.flags&2?t=s+1:n=s}return t}function En(e){if(!(e.flags&1)){const t=Vt(e),n=oe[oe.length-1];!n||!(e.flags&2)&&t>=Vt(n)?oe.push(e):oe.splice(Hi(t),0,e),e.flags|=1,qr()}}function qr(){pn||(pn=Gr.then(zr))}function Jr(e){M(e)?vt.push(...e):Xe&&e.id===-1?Xe.splice(bt+1,0,e):e.flags&1||(vt.push(e),e.flags|=1),qr()}function Ks(e,t,n=Ae+1){for(t=t||new Map;n<oe.length;n++){const s=oe[n];if(s&&s.flags&2){if(e&&s.id!==e.uid||Ss(t,s))continue;oe.splice(n,1),n--,s.flags&4&&(s.flags&=-2),s(),s.flags&4||(s.flags&=-2)}}}function Yr(e){if(vt.length){const t=[...new Set(vt)].sort((n,s)=>Vt(n)-Vt(s));if(vt.length=0,Xe){Xe.push(...t);return}for(Xe=t,e=e||new Map,bt=0;bt<Xe.length;bt++){const n=Xe[bt];Ss(e,n)||(n.flags&4&&(n.flags&=-2),n.flags&8||n(),n.flags&=-2)}Xe=null,bt=0}}const Vt=e=>e.id==null?e.flags&2?-1:1/0:e.id;function zr(e){e=e||new Map;const t=n=>Ss(e,n);try{for(Ae=0;Ae<oe.length;Ae++){const n=oe[Ae];if(n&&!(n.flags&8)){if(t(n))continue;n.flags&4&&(n.flags&=-2),xt(n,n.i,n.i?15:14),n.flags&4||(n.flags&=-2)}}}finally{for(;Ae<oe.length;Ae++){const n=oe[Ae];n&&(n.flags&=-2)}Ae=-1,oe.length=0,Yr(e),pn=null,(oe.length||vt.length)&&zr(e)}}function Ss(e,t){const n=e.get(t)||0;if(n>ji){const s=t.i,r=s&&Io(s.type);return kt(\`Maximum recursive updates exceeded\${r?\` in component <\${r}>\`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.\`,null,10),!0}return e.set(t,n+1),!1}let je=!1;const nn=new Map;Wt().__VUE_HMR_RUNTIME__={createRecord:Kn(Xr),rerender:Kn(Vi),reload:Kn(Ki)};const at=new Map;function Li(e){const t=e.type.__hmrId;let n=at.get(t);n||(Xr(t,e.type),n=at.get(t)),n.instances.add(e)}function Ni(e){at.get(e.type.__hmrId).instances.delete(e)}function Xr(e,t){return at.has(e)?!1:(at.set(e,{initialDef:hn(t),instances:new Set}),!0)}function hn(e){return Ro(e)?e.__vccOpts:e}function Vi(e,t){const n=at.get(e);n&&(n.initialDef.render=t,[...n.instances].forEach(s=>{t&&(s.render=t,hn(s.type).render=t),s.renderCache=[],je=!0,s.job.flags&8||s.update(),je=!1}))}function Ki(e,t){const n=at.get(e);if(!n)return;t=hn(t),Us(n.initialDef,t);const s=[...n.instances];for(let r=0;r<s.length;r++){const o=s[r],i=hn(o.type);let l=nn.get(i);l||(i!==n.initialDef&&Us(i,t),nn.set(i,l=new Set)),l.add(o),o.appContext.propsCache.delete(o.type),o.appContext.emitsCache.delete(o.type),o.appContext.optionsCache.delete(o.type),o.ceReload?(l.add(o),o.ceReload(t.styles),l.delete(o)):o.parent?En(()=>{o.job.flags&8||(je=!0,o.parent.update(),je=!1,l.delete(o))}):o.appContext.reload?o.appContext.reload():typeof window<"u"?window.location.reload():console.warn("[HMR] Root or manually mounted instance modified. Full reload required."),o.root.ce&&o!==o.root&&o.root.ce._removeChildStyle(i)}Jr(()=>{nn.clear()})}function Us(e,t){Y(e,t);for(const n in e)n!=="__file"&&!(n in t)&&delete e[n]}function Kn(e){return(t,n)=>{try{return e(t,n)}catch(s){console.error(s),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}}let Re,At=[],es=!1;function Gt(e,...t){Re?Re.emit(e,...t):es||At.push({event:e,args:t})}function Zr(e,t){var n,s;Re=e,Re?(Re.enabled=!0,At.forEach(({event:r,args:o})=>Re.emit(r,...o)),At=[]):typeof window<"u"&&window.HTMLElement&&!((s=(n=window.navigator)==null?void 0:n.userAgent)!=null&&s.includes("jsdom"))?((t.__VUE_DEVTOOLS_HOOK_REPLAY__=t.__VUE_DEVTOOLS_HOOK_REPLAY__||[]).push(o=>{Zr(o,t)}),setTimeout(()=>{Re||(t.__VUE_DEVTOOLS_HOOK_REPLAY__=null,es=!0,At=[])},3e3)):(es=!0,At=[])}function Ui(e,t){Gt("app:init",e,t,{Fragment:Pe,Text:qt,Comment:me,Static:rn})}function Bi(e){Gt("app:unmount",e)}const Wi=Cs("component:added"),Qr=Cs("component:updated"),ki=Cs("component:removed"),Gi=e=>{Re&&typeof Re.cleanupBuffer=="function"&&!Re.cleanupBuffer(e)&&ki(e)};function Cs(e){return t=>{Gt(e,t.appContext.app,t.uid,t.parent?t.parent.uid:void 0,t)}}const qi=eo("perf:start"),Ji=eo("perf:end");function eo(e){return(t,n,s)=>{Gt(e,t.appContext.app,t.uid,t,n,s)}}function Yi(e,t,n){Gt("component:emit",e.appContext.app,e,t,n)}let ie=null,to=null;function gn(e){const t=ie;return ie=e,to=e&&e.type.__scopeId||null,t}function zi(e,t=ie,n){if(!t||e._n)return e;const s=(...r)=>{s._d&&nr(-1);const o=gn(t);let i;try{i=e(...r)}finally{gn(o),s._d&&nr(1)}return Qr(t),i};return s._n=!0,s._c=!0,s._d=!0,s}function no(e){Lo(e)&&x("Do not use built-in directive ids as custom directive id: "+e)}function tf(e,t){if(ie===null)return x("withDirectives can only be used inside render functions."),e;const n=Pn(ie),s=e.dirs||(e.dirs=[]);for(let r=0;r<t.length;r++){let[o,i,l,f=U]=t[r];o&&(P(o)&&(o={mounted:o,updated:o}),o.deep&&Ue(i),s.push({dir:o,instance:n,value:i,oldValue:void 0,arg:l,modifiers:f}))}return e}function nt(e,t,n,s){const r=e.dirs,o=t&&t.dirs;for(let i=0;i<r.length;i++){const l=r[i];o&&(l.oldValue=o[i].value);let f=l.dir[s];f&&(Se(),He(f,n,8,[e.el,l,e,t]),Ce())}}const Xi=Symbol("_vte"),Zi=e=>e.__isTeleport,Qi=Symbol("_leaveCb");function Os(e,t){e.shapeFlag&6&&e.component?(e.transition=t,Os(e.component.subTree,t)):e.shapeFlag&128?(e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t}function nf(e,t){return P(e)?Y({name:e.name},t,{setup:e}):e}function so(e){e.ids=[e.ids[0]+e.ids[2]+++"-",0,0]}const Bs=new WeakSet,mn=new WeakMap;function jt(e,t,n,s,r=!1){if(M(e)){e.forEach((E,z)=>jt(E,t&&(M(t)?t[z]:t),n,s,r));return}if(Dt(s)&&!r){s.shapeFlag&512&&s.type.__asyncResolved&&s.component.subTree.component&&jt(e,t,n,s.component.subTree);return}const o=s.shapeFlag&4?Pn(s.component):s.el,i=r?null:o,{i:l,r:f}=e;if(!l){x("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");return}const p=t&&t.r,d=l.refs===U?l.refs={}:l.refs,a=l.setupState,g=F(a),C=a===U?wr:E=>(H(g,E)&&!J(g[E])&&x(\`Template ref "\${E}" used on a non-ref value. It will not work in the production build.\`),Bs.has(g[E])?!1:H(g,E)),I=E=>!Bs.has(E);if(p!=null&&p!==f){if(Ws(t),q(p))d[p]=null,C(p)&&(a[p]=null);else if(J(p)){I(p)&&(p.value=null);const E=t;E.k&&(d[E.k]=null)}}if(P(f))xt(f,l,12,[i,d]);else{const E=q(f),z=J(f);if(E||z){const G=()=>{if(e.f){const V=E?C(f)?a[f]:d[f]:I(f)||!e.k?f.value:d[e.k];if(r)M(V)&&as(V,o);else if(M(V))V.includes(o)||V.push(o);else if(E)d[f]=[o],C(f)&&(a[f]=d[f]);else{const N=[o];I(f)&&(f.value=N),e.k&&(d[e.k]=N)}}else E?(d[f]=i,C(f)&&(a[f]=i)):z?(I(f)&&(f.value=i),e.k&&(d[e.k]=i)):x("Invalid template ref type:",f,\`(\${typeof f})\`)};if(i){const V=()=>{G(),mn.delete(e)};V.id=-1,mn.set(e,V),he(V,n)}else Ws(e),G()}else x("Invalid template ref type:",f,\`(\${typeof f})\`)}}function Ws(e){const t=mn.get(e);t&&(t.flags|=8,mn.delete(e))}Wt().requestIdleCallback;Wt().cancelIdleCallback;const Dt=e=>!!e.type.__asyncLoader,Ts=e=>e.type.__isKeepAlive;function el(e,t){ro(e,"a",t)}function tl(e,t){ro(e,"da",t)}function ro(e,t,n=ee){const s=e.__wdc||(e.__wdc=()=>{let r=n;for(;r;){if(r.isDeactivated)return;r=r.parent}return e()});if($n(t,s,n),n){let r=n.parent;for(;r&&r.parent;)Ts(r.parent.vnode)&&nl(s,t,n,r),r=r.parent}}function nl(e,t,n,s){const r=$n(t,e,s,!0);oo(()=>{as(s[t],r)},n)}function $n(e,t,n=ee,s=!1){if(n){const r=n[e]||(n[e]=[]),o=t.__weh||(t.__weh=(...i)=>{Se();const l=Jt(n),f=He(t,n,e,i);return l(),Ce(),f});return s?r.unshift(o):r.push(o),o}else{const r=rt(xs[e].replace(/ hook$/,""));x(\`\${r} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.\`)}}const qe=e=>(t,n=ee)=>{(!Ut||e==="sp")&&$n(e,(...s)=>t(...s),n)},sl=qe("bm"),rl=qe("m"),ol=qe("bu"),il=qe("u"),ll=qe("bum"),oo=qe("um"),cl=qe("sp"),fl=qe("rtg"),ul=qe("rtc");function al(e,t=ee){$n("ec",e,t)}const dl=Symbol.for("v-ndc");function sf(e,t,n,s){let r;const o=n,i=M(e);if(i||q(e)){const l=i&&ct(e);let f=!1,p=!1;l&&(f=!le(e),p=De(e),e=Cn(e)),r=new Array(e.length);for(let d=0,a=e.length;d<a;d++)r[d]=t(f?p?an(Q(e[d])):Q(e[d]):e[d],d,void 0,o)}else if(typeof e=="number"){Number.isInteger(e)||x(\`The v-for range expect an integer value but got \${e}.\`),r=new Array(e);for(let l=0;l<e;l++)r[l]=t(l+1,l,void 0,o)}else if(W(e))if(e[Symbol.iterator])r=Array.from(e,(l,f)=>t(l,f,void 0,o));else{const l=Object.keys(e);r=new Array(l.length);for(let f=0,p=l.length;f<p;f++){const d=l[f];r[f]=t(e[d],d,f,o)}}else r=[];return r}const ts=e=>e?Ao(e)?Pn(e):ts(e.parent):null,ut=Y(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>Fe(e.props),$attrs:e=>Fe(e.attrs),$slots:e=>Fe(e.slots),$refs:e=>Fe(e.refs),$parent:e=>ts(e.parent),$root:e=>ts(e.root),$host:e=>e.ce,$emit:e=>e.emit,$options:e=>co(e),$forceUpdate:e=>e.f||(e.f=()=>{En(e.update)}),$nextTick:e=>e.n||(e.n=Di.bind(e.proxy)),$watch:e=>kl.bind(e)}),Es=e=>e==="_"||e==="$",Un=(e,t)=>e!==U&&!e.__isScriptSetup&&H(e,t),io={get({_:e},t){if(t==="__v_skip")return!0;const{ctx:n,setupState:s,data:r,props:o,accessCache:i,type:l,appContext:f}=e;if(t==="__isVue")return!0;let p;if(t[0]!=="$"){const C=i[t];if(C!==void 0)switch(C){case 1:return s[t];case 2:return r[t];case 4:return n[t];case 3:return o[t]}else{if(Un(s,t))return i[t]=1,s[t];if(r!==U&&H(r,t))return i[t]=2,r[t];if((p=e.propsOptions[0])&&H(p,t))return i[t]=3,o[t];if(n!==U&&H(n,t))return i[t]=4,n[t];ns&&(i[t]=0)}}const d=ut[t];let a,g;if(d)return t==="$attrs"?(Z(e.attrs,"get",""),_n()):t==="$slots"&&Z(e,"get",t),d(e);if((a=l.__cssModules)&&(a=a[t]))return a;if(n!==U&&H(n,t))return i[t]=4,n[t];if(g=f.config.globalProperties,H(g,t))return g[t];ie&&(!q(t)||t.indexOf("__v")!==0)&&(r!==U&&Es(t[0])&&H(r,t)?x(\`Property \${JSON.stringify(t)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.\`):e===ie&&x(\`Property \${JSON.stringify(t)} was accessed during render but is not defined on instance.\`))},set({_:e},t,n){const{data:s,setupState:r,ctx:o}=e;return Un(r,t)?(r[t]=n,!0):r.__isScriptSetup&&H(r,t)?(x(\`Cannot mutate <script setup> binding "\${t}" from Options API.\`),!1):s!==U&&H(s,t)?(s[t]=n,!0):H(e.props,t)?(x(\`Attempting to mutate prop "\${t}". Props are readonly.\`),!1):t[0]==="$"&&t.slice(1)in e?(x(\`Attempting to mutate public property "\${t}". Properties starting with $ are reserved and readonly.\`),!1):(t in e.appContext.config.globalProperties?Object.defineProperty(o,t,{enumerable:!0,configurable:!0,value:n}):o[t]=n,!0)},has({_:{data:e,setupState:t,accessCache:n,ctx:s,appContext:r,propsOptions:o,type:i}},l){let f,p;return!!(n[l]||e!==U&&l[0]!=="$"&&H(e,l)||Un(t,l)||(f=o[0])&&H(f,l)||H(s,l)||H(ut,l)||H(r.config.globalProperties,l)||(p=i.__cssModules)&&p[l])},defineProperty(e,t,n){return n.get!=null?e._.accessCache[t]=0:H(n,"value")&&this.set(e,t,n.value,null),Reflect.defineProperty(e,t,n)}};io.ownKeys=e=>(x("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."),Reflect.ownKeys(e));function pl(e){const t={};return Object.defineProperty(t,"_",{configurable:!0,enumerable:!1,get:()=>e}),Object.keys(ut).forEach(n=>{Object.defineProperty(t,n,{configurable:!0,enumerable:!1,get:()=>ut[n](e),set:ne})}),t}function hl(e){const{ctx:t,propsOptions:[n]}=e;n&&Object.keys(n).forEach(s=>{Object.defineProperty(t,s,{enumerable:!0,configurable:!0,get:()=>e.props[s],set:ne})})}function gl(e){const{ctx:t,setupState:n}=e;Object.keys(F(n)).forEach(s=>{if(!n.__isScriptSetup){if(Es(s[0])){x(\`setup() return property \${JSON.stringify(s)} should not start with "$" or "_" which are reserved prefixes for Vue internals.\`);return}Object.defineProperty(t,s,{enumerable:!0,configurable:!0,get:()=>n[s],set:ne})}})}function ks(e){return M(e)?e.reduce((t,n)=>(t[n]=null,t),{}):e}function ml(){const e=Object.create(null);return(t,n)=>{e[n]?x(\`\${t} property "\${n}" is already defined in \${e[n]}.\`):e[n]=t}}let ns=!0;function bl(e){const t=co(e),n=e.proxy,s=e.ctx;ns=!1,t.beforeCreate&&Gs(t.beforeCreate,e,"bc");const{data:r,computed:o,methods:i,watch:l,provide:f,inject:p,created:d,beforeMount:a,mounted:g,beforeUpdate:C,updated:I,activated:E,deactivated:z,beforeDestroy:G,beforeUnmount:V,destroyed:N,unmounted:pe,render:$,renderTracked:X,renderTriggered:be,errorCaptured:te,serverPrefetch:ce,expose:Le,inheritAttrs:Je,components:ye,directives:Yt,filters:Is}=t,Ye=ml();{const[L]=e.propsOptions;if(L)for(const j in L)Ye("Props",j)}if(p&&yl(p,s,Ye),i)for(const L in i){const j=i[L];P(j)?(Object.defineProperty(s,L,{value:j.bind(n),configurable:!0,enumerable:!0,writable:!0}),Ye("Methods",L)):x(\`Method "\${L}" has type "\${typeof j}" in the component definition. Did you reference the function correctly?\`)}if(r){P(r)||x("The data option must be a function. Plain object usage is no longer supported.");const L=r.call(n,n);if(ds(L)&&x("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."),!W(L))x("data() should return an object.");else{e.data=ws(L);for(const j in L)Ye("Data",j),Es(j[0])||Object.defineProperty(s,j,{configurable:!0,enumerable:!0,get:()=>L[j],set:ne})}}if(ns=!0,o)for(const L in o){const j=o[L],Oe=P(j)?j.bind(n,n):P(j.get)?j.get.bind(n,n):ne;Oe===ne&&x(\`Computed property "\${L}" has no getter.\`);const Rn=!P(j)&&P(j.set)?j.set.bind(n):()=>{x(\`Write operation failed: computed property "\${L}" is readonly.\`)},St=vc({get:Oe,set:Rn});Object.defineProperty(s,L,{enumerable:!0,configurable:!0,get:()=>St.value,set:dt=>St.value=dt}),Ye("Computed",L)}if(l)for(const L in l)lo(l[L],s,n,L);if(f){const L=P(f)?f.call(n):f;Reflect.ownKeys(L).forEach(j=>{Cl(j,L[j])})}d&&Gs(d,e,"c");function fe(L,j){M(j)?j.forEach(Oe=>L(Oe.bind(n))):j&&L(j.bind(n))}if(fe(sl,a),fe(rl,g),fe(ol,C),fe(il,I),fe(el,E),fe(tl,z),fe(al,te),fe(ul,X),fe(fl,be),fe(ll,V),fe(oo,pe),fe(cl,ce),M(Le))if(Le.length){const L=e.exposed||(e.exposed={});Le.forEach(j=>{Object.defineProperty(L,j,{get:()=>n[j],set:Oe=>n[j]=Oe,enumerable:!0})})}else e.exposed||(e.exposed={});$&&e.render===ne&&(e.render=$),Je!=null&&(e.inheritAttrs=Je),ye&&(e.components=ye),Yt&&(e.directives=Yt),ce&&so(e)}function yl(e,t,n=ne){M(e)&&(e=ss(e));for(const s in e){const r=e[s];let o;W(r)?"default"in r?o=sn(r.from||s,r.default,!0):o=sn(r.from||s):o=sn(r),J(o)?Object.defineProperty(t,s,{enumerable:!0,configurable:!0,get:()=>o.value,set:i=>o.value=i}):t[s]=o,n("Inject",s)}}function Gs(e,t,n){He(M(e)?e.map(s=>s.bind(t.proxy)):e.bind(t.proxy),t,n)}function lo(e,t,n,s){let r=s.includes(".")?wo(n,s):()=>n[s];if(q(e)){const o=t[e];P(o)?Wn(r,o):x(\`Invalid watch handler specified by key "\${e}"\`,o)}else if(P(e))Wn(r,e.bind(n));else if(W(e))if(M(e))e.forEach(o=>lo(o,t,n,s));else{const o=P(e.handler)?e.handler.bind(n):t[e.handler];P(o)?Wn(r,o,e):x(\`Invalid watch handler specified by key "\${e.handler}"\`,o)}else x(\`Invalid watch option: "\${s}"\`,e)}function co(e){const t=e.type,{mixins:n,extends:s}=t,{mixins:r,optionsCache:o,config:{optionMergeStrategies:i}}=e.appContext,l=o.get(t);let f;return l?f=l:!r.length&&!n&&!s?f=t:(f={},r.length&&r.forEach(p=>bn(f,p,i,!0)),bn(f,t,i)),W(t)&&o.set(t,f),f}function bn(e,t,n,s=!1){const{mixins:r,extends:o}=t;o&&bn(e,o,n,!0),r&&r.forEach(i=>bn(e,i,n,!0));for(const i in t)if(s&&i==="expose")x('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');else{const l=_l[i]||n&&n[i];e[i]=l?l(e[i],t[i]):t[i]}return e}const _l={data:qs,props:Js,emits:Js,methods:Pt,computed:Pt,beforeCreate:re,created:re,beforeMount:re,mounted:re,beforeUpdate:re,updated:re,beforeDestroy:re,beforeUnmount:re,destroyed:re,unmounted:re,activated:re,deactivated:re,errorCaptured:re,serverPrefetch:re,components:Pt,directives:Pt,watch:wl,provide:qs,inject:vl};function qs(e,t){return t?e?function(){return Y(P(e)?e.call(this,this):e,P(t)?t.call(this,this):t)}:t:e}function vl(e,t){return Pt(ss(e),ss(t))}function ss(e){if(M(e)){const t={};for(let n=0;n<e.length;n++)t[e[n]]=e[n];return t}return e}function re(e,t){return e?[...new Set([].concat(e,t))]:t}function Pt(e,t){return e?Y(Object.create(null),e,t):t}function Js(e,t){return e?M(e)&&M(t)?[...new Set([...e,...t])]:Y(Object.create(null),ks(e),ks(t??{})):t}function wl(e,t){if(!e)return t;if(!t)return e;const n=Y(Object.create(null),e);for(const s in t)n[s]=re(e[s],t[s]);return n}function fo(){return{app:null,config:{isNativeTag:wr,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let xl=0;function Sl(e,t){return function(s,r=null){P(s)||(s=Y({},s)),r!=null&&!W(r)&&(x("root props passed to app.mount() must be an object."),r=null);const o=fo(),i=new WeakSet,l=[];let f=!1;const p=o.app={_uid:xl++,_component:s,_props:r,_container:null,_context:o,_instance:null,version:or,get config(){return o.config},set config(d){x("app.config cannot be replaced. Modify individual options instead.")},use(d,...a){return i.has(d)?x("Plugin has already been applied to target app."):d&&P(d.install)?(i.add(d),d.install(p,...a)):P(d)?(i.add(d),d(p,...a)):x('A plugin must either be a function or an object with an "install" function.'),p},mixin(d){return o.mixins.includes(d)?x("Mixin has already been applied to target app"+(d.name?\`: \${d.name}\`:"")):o.mixins.push(d),p},component(d,a){return fs(d,o.config),a?(o.components[d]&&x(\`Component "\${d}" has already been registered in target app.\`),o.components[d]=a,p):o.components[d]},directive(d,a){return no(d),a?(o.directives[d]&&x(\`Directive "\${d}" has already been registered in target app.\`),o.directives[d]=a,p):o.directives[d]},mount(d,a,g){if(f)x("App has already been mounted.\\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\`");else{d.__vue_app__&&x("There is already an app instance mounted on the host container.\\n If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.");const C=p._ceVNode||Be(s,r);return C.appContext=o,g===!0?g="svg":g===!1&&(g=void 0),o.reload=()=>{const I=et(C);I.el=null,e(I,d,g)},e(C,d,g),f=!0,p._container=d,d.__vue_app__=p,p._instance=C.component,Ui(p,or),Pn(C.component)}},onUnmount(d){typeof d!="function"&&x(\`Expected function as first argument to app.onUnmount(), but got \${typeof d}\`),l.push(d)},unmount(){f?(He(l,p._instance,16),e(null,p._container),p._instance=null,Bi(p),delete p._container.__vue_app__):x("Cannot unmount an app that is not mounted.")},provide(d,a){return d in o.provides&&(H(o.provides,d)?x(\`App already provides property with key "\${String(d)}". It will be overwritten with the new value.\`):x(\`App already provides property with key "\${String(d)}" inherited from its parent element. It will be overwritten with the new value.\`)),o.provides[d]=a,p},runWithContext(d){const a=wt;wt=p;try{return d()}finally{wt=a}}};return p}}let wt=null;function Cl(e,t){if(!ee)x("provide() can only be used inside setup().");else{let n=ee.provides;const s=ee.parent&&ee.parent.provides;s===n&&(n=ee.provides=Object.create(s)),n[e]=t}}function sn(e,t,n=!1){const s=Mo();if(s||wt){let r=wt?wt._context.provides:s?s.parent==null||s.ce?s.vnode.appContext&&s.vnode.appContext.provides:s.parent.provides:void 0;if(r&&e in r)return r[e];if(arguments.length>1)return n&&P(t)?t.call(s&&s.proxy):t;x(\`injection "\${String(e)}" not found.\`)}else x("inject() can only be used inside setup() or functional components.")}const uo={},ao=()=>Object.create(uo),po=e=>Object.getPrototypeOf(e)===uo;function Ol(e,t,n,s=!1){const r={},o=ao();e.propsDefaults=Object.create(null),ho(e,t,r,o);for(const i in e.propsOptions[0])i in r||(r[i]=void 0);mo(t||{},r,e),n?e.props=s?r:vi(r):e.type.props?e.props=r:e.props=o,e.attrs=o}function Tl(e){for(;e;){if(e.type.__hmrId)return!0;e=e.parent}}function El(e,t,n,s){const{props:r,attrs:o,vnode:{patchFlag:i}}=e,l=F(r),[f]=e.propsOptions;let p=!1;if(!Tl(e)&&(s||i>0)&&!(i&16)){if(i&8){const d=e.vnode.dynamicProps;for(let a=0;a<d.length;a++){let g=d[a];if(Mn(e.emitsOptions,g))continue;const C=t[g];if(f)if(H(o,g))C!==o[g]&&(o[g]=C,p=!0);else{const I=ve(g);r[I]=rs(f,l,I,C,e,!1)}else C!==o[g]&&(o[g]=C,p=!0)}}}else{ho(e,t,r,o)&&(p=!0);let d;for(const a in l)(!t||!H(t,a)&&((d=ke(a))===a||!H(t,d)))&&(f?n&&(n[a]!==void 0||n[d]!==void 0)&&(r[a]=rs(f,l,a,void 0,e,!0)):delete r[a]);if(o!==l)for(const a in o)(!t||!H(t,a))&&(delete o[a],p=!0)}p&&Ie(e.attrs,"set",""),mo(t||{},r,e)}function ho(e,t,n,s){const[r,o]=e.propsOptions;let i=!1,l;if(t)for(let f in t){if(It(f))continue;const p=t[f];let d;r&&H(r,d=ve(f))?!o||!o.includes(d)?n[d]=p:(l||(l={}))[d]=p:Mn(e.emitsOptions,f)||(!(f in s)||p!==s[f])&&(s[f]=p,i=!0)}if(o){const f=F(n),p=l||U;for(let d=0;d<o.length;d++){const a=o[d];n[a]=rs(r,f,a,p[a],e,!H(p,a))}}return i}function rs(e,t,n,s,r,o){const i=e[n];if(i!=null){const l=H(i,"default");if(l&&s===void 0){const f=i.default;if(i.type!==Function&&!i.skipFactory&&P(f)){const{propsDefaults:p}=r;if(n in p)s=p[n];else{const d=Jt(r);s=p[n]=f.call(null,t),d()}}else s=f;r.ce&&r.ce._setProp(n,s)}i[0]&&(o&&!l?s=!1:i[1]&&(s===""||s===ke(n))&&(s=!0))}return s}const $l=new WeakMap;function go(e,t,n=!1){const s=n?$l:t.propsCache,r=s.get(e);if(r)return r;const o=e.props,i={},l=[];let f=!1;if(!P(e)){const d=a=>{f=!0;const[g,C]=go(a,t,!0);Y(i,g),C&&l.push(...C)};!n&&t.mixins.length&&t.mixins.forEach(d),e.extends&&d(e.extends),e.mixins&&e.mixins.forEach(d)}if(!o&&!f)return W(e)&&s.set(e,_t),_t;if(M(o))for(let d=0;d<o.length;d++){q(o[d])||x("props must be strings when using array syntax.",o[d]);const a=ve(o[d]);Ys(a)&&(i[a]=U)}else if(o){W(o)||x("invalid props options",o);for(const d in o){const a=ve(d);if(Ys(a)){const g=o[d],C=i[a]=M(g)||P(g)?{type:g}:Y({},g),I=C.type;let E=!1,z=!0;if(M(I))for(let G=0;G<I.length;++G){const V=I[G],N=P(V)&&V.name;if(N==="Boolean"){E=!0;break}else N==="String"&&(z=!1)}else E=P(I)&&I.name==="Boolean";C[0]=E,C[1]=z,(E||H(C,"default"))&&l.push(a)}}}const p=[i,l];return W(e)&&s.set(e,p),p}function Ys(e){return e[0]!=="$"&&!It(e)?!0:(x(\`Invalid prop name: "\${e}" is a reserved property.\`),!1)}function Ml(e){return e===null?"null":typeof e=="function"?e.name||"":typeof e=="object"&&e.constructor&&e.constructor.name||""}function mo(e,t,n){const s=F(t),r=n.propsOptions[0],o=Object.keys(e).map(i=>ve(i));for(const i in r){let l=r[i];l!=null&&Al(i,s[i],l,Fe(s),!o.includes(i))}}function Al(e,t,n,s,r){const{type:o,required:i,validator:l,skipCheck:f}=n;if(i&&r){x('Missing required prop: "'+e+'"');return}if(!(t==null&&!i)){if(o!=null&&o!==!0&&!f){let p=!1;const d=M(o)?o:[o],a=[];for(let g=0;g<d.length&&!p;g++){const{valid:C,expectedType:I}=Il(t,d[g]);a.push(I||""),p=C}if(!p){x(Rl(e,t,a));return}}l&&!l(t,s)&&x('Invalid prop: custom validator check failed for prop "'+e+'".')}}const Pl=Ge("String,Number,Boolean,Function,Symbol,BigInt");function Il(e,t){let n;const s=Ml(t);if(s==="null")n=e===null;else if(Pl(s)){const r=typeof e;n=r===s.toLowerCase(),!n&&r==="object"&&(n=e instanceof t)}else s==="Object"?n=W(e):s==="Array"?n=M(e):n=e instanceof t;return{valid:n,expectedType:s}}function Rl(e,t,n){if(n.length===0)return\`Prop type [] for prop "\${e}" won't match anything. Did you mean to use type Array instead?\`;let s=\`Invalid prop: type check failed for prop "\${e}". Expected \${n.map(Sn).join(" | ")}\`;const r=n[0],o=ps(t),i=zs(t,r),l=zs(t,o);return n.length===1&&Xs(r)&&!Fl(r,o)&&(s+=\` with value \${i}\`),s+=\`, got \${o} \`,Xs(o)&&(s+=\`with value \${l}.\`),s}function zs(e,t){return t==="String"?\`"\${e}"\`:t==="Number"?\`\${Number(e)}\`:\`\${e}\`}function Xs(e){return["string","number","boolean"].some(n=>e.toLowerCase()===n)}function Fl(...e){return e.some(t=>t.toLowerCase()==="boolean")}const $s=e=>e==="_"||e==="_ctx"||e==="$stable",Ms=e=>M(e)?e.map(_e):[_e(e)],jl=(e,t,n)=>{if(t._n)return t;const s=zi((...r)=>(ee&&!(n===null&&ie)&&!(n&&n.root!==ee.root)&&x(\`Slot "\${e}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.\`),Ms(t(...r))),n);return s._c=!1,s},bo=(e,t,n)=>{const s=e._ctx;for(const r in e){if($s(r))continue;const o=e[r];if(P(o))t[r]=jl(r,o,s);else if(o!=null){x(\`Non-function value encountered for slot "\${r}". Prefer function slots for better performance.\`);const i=Ms(o);t[r]=()=>i}}},yo=(e,t)=>{Ts(e.vnode)||x("Non-function value encountered for default slot. Prefer function slots for better performance.");const n=Ms(t);e.slots.default=()=>n},os=(e,t,n)=>{for(const s in t)(n||!$s(s))&&(e[s]=t[s])},Dl=(e,t,n)=>{const s=e.slots=ao();if(e.vnode.shapeFlag&32){const r=t._;r?(os(s,t,n),n&&fn(s,"_",r,!0)):bo(t,s)}else t&&yo(e,t)},Hl=(e,t,n)=>{const{vnode:s,slots:r}=e;let o=!0,i=U;if(s.shapeFlag&32){const l=t._;l?je?(os(r,t,n),Ie(e,"set","$slots")):n&&l===1?o=!1:os(r,t,n):(o=!t.$stable,bo(t,r)),i=t}else t&&(yo(e,t),i={default:1});if(o)for(const l in r)!$s(l)&&i[l]==null&&delete r[l]};let $t,Ke;function ht(e,t){e.appContext.config.performance&&yn()&&Ke.mark(\`vue-\${t}-\${e.uid}\`),qi(e,t,yn()?Ke.now():Date.now())}function gt(e,t){if(e.appContext.config.performance&&yn()){const n=\`vue-\${t}-\${e.uid}\`,s=n+":end",r=\`<\${In(e,e.type)}> \${t}\`;Ke.mark(s),Ke.measure(r,n,s),Ke.clearMeasures(r),Ke.clearMarks(n),Ke.clearMarks(s)}Ji(e,t,yn()?Ke.now():Date.now())}function yn(){return $t!==void 0||(typeof window<"u"&&window.performance?($t=!0,Ke=window.performance):$t=!1),$t}function Ll(){const e=[];if(e.length){const t=e.length>1;console.warn(\`Feature flag\${t?"s":""} \${e.join(", ")} \${t?"are":"is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.\`)}}const he=Ql;function Nl(e){return Vl(e)}function Vl(e,t){Ll();const n=Wt();n.__VUE__=!0,Zr(n.__VUE_DEVTOOLS_GLOBAL_HOOK__,n);const{insert:s,remove:r,patchProp:o,createElement:i,createText:l,createComment:f,setText:p,setElementText:d,parentNode:a,nextSibling:g,setScopeId:C=ne,insertStaticContent:I}=e,E=(c,u,h,y=null,b=null,m=null,S=void 0,w=null,v=je?!1:!!u.dynamicChildren)=>{if(c===u)return;c&&!Mt(c,u)&&(y=zt(c),ze(c,b,m,!0),c=null),u.patchFlag===-2&&(v=!1,u.dynamicChildren=null);const{type:_,ref:A,shapeFlag:O}=u;switch(_){case qt:z(c,u,h,y);break;case me:G(c,u,h,y);break;case rn:c==null?V(u,h,y,S):N(c,u,h,S);break;case Pe:Yt(c,u,h,y,b,m,S,w,v);break;default:O&1?X(c,u,h,y,b,m,S,w,v):O&6?Is(c,u,h,y,b,m,S,w,v):O&64||O&128?_.process(c,u,h,y,b,m,S,w,v,Ot):x("Invalid VNode type:",_,\`(\${typeof _})\`)}A!=null&&b?jt(A,c&&c.ref,m,u||c,!u):A==null&&c&&c.ref!=null&&jt(c.ref,null,m,c,!0)},z=(c,u,h,y)=>{if(c==null)s(u.el=l(u.children),h,y);else{const b=u.el=c.el;u.children!==c.children&&p(b,u.children)}},G=(c,u,h,y)=>{c==null?s(u.el=f(u.children||""),h,y):u.el=c.el},V=(c,u,h,y)=>{[c.el,c.anchor]=I(c.children,u,h,y,c.el,c.anchor)},N=(c,u,h,y)=>{if(u.children!==c.children){const b=g(c.anchor);$(c),[u.el,u.anchor]=I(u.children,h,b,y)}else u.el=c.el,u.anchor=c.anchor},pe=({el:c,anchor:u},h,y)=>{let b;for(;c&&c!==u;)b=g(c),s(c,h,y),c=b;s(u,h,y)},$=({el:c,anchor:u})=>{let h;for(;c&&c!==u;)h=g(c),r(c),c=h;r(u)},X=(c,u,h,y,b,m,S,w,v)=>{u.type==="svg"?S="svg":u.type==="math"&&(S="mathml"),c==null?be(u,h,y,b,m,S,w,v):Le(c,u,b,m,S,w,v)},be=(c,u,h,y,b,m,S,w)=>{let v,_;const{props:A,shapeFlag:O,transition:T,dirs:R}=c;if(v=c.el=i(c.type,m,A&&A.is,A),O&8?d(v,c.children):O&16&&ce(c.children,v,null,y,b,Bn(c,m),S,w),R&&nt(c,null,y,"created"),te(v,c,c.scopeId,S,y),A){for(const k in A)k!=="value"&&!It(k)&&o(v,k,null,A[k],m,y);"value"in A&&o(v,"value",null,A.value,m),(_=A.onVnodeBeforeMount)&&Me(_,y,c)}fn(v,"__vnode",c,!0),fn(v,"__vueParentComponent",y,!0),R&&nt(c,null,y,"beforeMount");const D=Kl(b,T);D&&T.beforeEnter(v),s(v,u,h),((_=A&&A.onVnodeMounted)||D||R)&&he(()=>{_&&Me(_,y,c),D&&T.enter(v),R&&nt(c,null,y,"mounted")},b)},te=(c,u,h,y,b)=>{if(h&&C(c,h),y)for(let m=0;m<y.length;m++)C(c,y[m]);if(b){let m=b.subTree;if(m.patchFlag>0&&m.patchFlag&2048&&(m=As(m.children)||m),u===m||Co(m.type)&&(m.ssContent===u||m.ssFallback===u)){const S=b.vnode;te(c,S,S.scopeId,S.slotScopeIds,b.parent)}}},ce=(c,u,h,y,b,m,S,w,v=0)=>{for(let _=v;_<c.length;_++){const A=c[_]=w?Ze(c[_]):_e(c[_]);E(null,A,u,h,y,b,m,S,w)}},Le=(c,u,h,y,b,m,S)=>{const w=u.el=c.el;w.__vnode=u;let{patchFlag:v,dynamicChildren:_,dirs:A}=u;v|=c.patchFlag&16;const O=c.props||U,T=u.props||U;let R;if(h&&st(h,!1),(R=T.onVnodeBeforeUpdate)&&Me(R,h,u,c),A&&nt(u,c,h,"beforeUpdate"),h&&st(h,!0),je&&(v=0,S=!1,_=null),(O.innerHTML&&T.innerHTML==null||O.textContent&&T.textContent==null)&&d(w,""),_?(Je(c.dynamicChildren,_,w,h,y,Bn(u,b),m),is(c,u)):S||Oe(c,u,w,null,h,y,Bn(u,b),m,!1),v>0){if(v&16)ye(w,O,T,h,b);else if(v&2&&O.class!==T.class&&o(w,"class",null,T.class,b),v&4&&o(w,"style",O.style,T.style,b),v&8){const D=u.dynamicProps;for(let k=0;k<D.length;k++){const B=D[k],ue=O[B],ae=T[B];(ae!==ue||B==="value")&&o(w,B,ue,ae,b,h)}}v&1&&c.children!==u.children&&d(w,u.children)}else!S&&_==null&&ye(w,O,T,h,b);((R=T.onVnodeUpdated)||A)&&he(()=>{R&&Me(R,h,u,c),A&&nt(u,c,h,"updated")},y)},Je=(c,u,h,y,b,m,S)=>{for(let w=0;w<u.length;w++){const v=c[w],_=u[w],A=v.el&&(v.type===Pe||!Mt(v,_)||v.shapeFlag&198)?a(v.el):h;E(v,_,A,null,y,b,m,S,!0)}},ye=(c,u,h,y,b)=>{if(u!==h){if(u!==U)for(const m in u)!It(m)&&!(m in h)&&o(c,m,u[m],null,b,y);for(const m in h){if(It(m))continue;const S=h[m],w=u[m];S!==w&&m!=="value"&&o(c,m,w,S,b,y)}"value"in h&&o(c,"value",u.value,h.value,b)}},Yt=(c,u,h,y,b,m,S,w,v)=>{const _=u.el=c?c.el:l(""),A=u.anchor=c?c.anchor:l("");let{patchFlag:O,dynamicChildren:T,slotScopeIds:R}=u;(je||O&2048)&&(O=0,v=!1,T=null),R&&(w=w?w.concat(R):R),c==null?(s(_,h,y),s(A,h,y),ce(u.children||[],h,A,b,m,S,w,v)):O>0&&O&64&&T&&c.dynamicChildren?(Je(c.dynamicChildren,T,h,b,m,S,w),is(c,u)):Oe(c,u,h,A,b,m,S,w,v)},Is=(c,u,h,y,b,m,S,w,v)=>{u.slotScopeIds=w,c==null?u.shapeFlag&512?b.ctx.activate(u,h,y,S,v):Ye(u,h,y,b,m,S,v):fe(c,u,v)},Ye=(c,u,h,y,b,m,S)=>{const w=c.component=uc(c,y,b);if(w.type.__hmrId&&Li(w),en(c),ht(w,"mount"),Ts(c)&&(w.ctx.renderer=Ot),ht(w,"init"),dc(w,!1,S),gt(w,"init"),je&&(c.el=null),w.asyncDep){if(b&&b.registerDep(w,L,S),!c.el){const v=w.subTree=Be(me);G(null,v,u,h),c.placeholder=v.el}}else L(w,c,u,h,b,m,S);tn(),gt(w,"mount")},fe=(c,u,h)=>{const y=u.component=c.component;if(Xl(c,u,h))if(y.asyncDep&&!y.asyncResolved){en(u),j(y,u,h),tn();return}else y.next=u,y.update();else u.el=c.el,y.vnode=u},L=(c,u,h,y,b,m,S)=>{const w=()=>{if(c.isMounted){let{next:O,bu:T,u:R,parent:D,vnode:k}=c;{const Ee=_o(c);if(Ee){O&&(O.el=k.el,j(c,O,S)),Ee.asyncDep.then(()=>{c.isUnmounted||w()});return}}let B=O,ue;en(O||c.vnode),st(c,!1),O?(O.el=k.el,j(c,O,S)):O=k,T&&mt(T),(ue=O.props&&O.props.onVnodeBeforeUpdate)&&Me(ue,D,O,k),st(c,!0),ht(c,"render");const ae=Qs(c);gt(c,"render");const Te=c.subTree;c.subTree=ae,ht(c,"patch"),E(Te,ae,a(Te.el),zt(Te),c,b,m),gt(c,"patch"),O.el=ae.el,B===null&&Zl(c,ae.el),R&&he(R,b),(ue=O.props&&O.props.onVnodeUpdated)&&he(()=>Me(ue,D,O,k),b),Qr(c),tn()}else{let O;const{el:T,props:R}=u,{bm:D,m:k,parent:B,root:ue,type:ae}=c,Te=Dt(u);st(c,!1),D&&mt(D),!Te&&(O=R&&R.onVnodeBeforeMount)&&Me(O,B,u),st(c,!0);{ue.ce&&ue.ce._def.shadowRoot!==!1&&ue.ce._injectChildStyle(ae),ht(c,"render");const Ee=c.subTree=Qs(c);gt(c,"render"),ht(c,"patch"),E(null,Ee,h,y,c,b,m),gt(c,"patch"),u.el=Ee.el}if(k&&he(k,b),!Te&&(O=R&&R.onVnodeMounted)){const Ee=u;he(()=>Me(O,B,Ee),b)}(u.shapeFlag&256||B&&Dt(B.vnode)&&B.vnode.shapeFlag&256)&&c.a&&he(c.a,b),c.isMounted=!0,Wi(c),u=h=y=null}};c.scope.on();const v=c.effect=new $r(w);c.scope.off();const _=c.update=v.run.bind(v),A=c.job=v.runIfDirty.bind(v);A.i=c,A.id=c.uid,v.scheduler=()=>En(A),st(c,!0),v.onTrack=c.rtc?O=>mt(c.rtc,O):void 0,v.onTrigger=c.rtg?O=>mt(c.rtg,O):void 0,_()},j=(c,u,h)=>{u.component=c;const y=c.vnode.props;c.vnode=u,c.next=null,El(c,u.props,y,h),Hl(c,u.children,h),Se(),Ks(c),Ce()},Oe=(c,u,h,y,b,m,S,w,v=!1)=>{const _=c&&c.children,A=c?c.shapeFlag:0,O=u.children,{patchFlag:T,shapeFlag:R}=u;if(T>0){if(T&128){St(_,O,h,y,b,m,S,w,v);return}else if(T&256){Rn(_,O,h,y,b,m,S,w,v);return}}R&8?(A&16&&Ct(_,b,m),O!==_&&d(h,O)):A&16?R&16?St(_,O,h,y,b,m,S,w,v):Ct(_,b,m,!0):(A&8&&d(h,""),R&16&&ce(O,h,y,b,m,S,w,v))},Rn=(c,u,h,y,b,m,S,w,v)=>{c=c||_t,u=u||_t;const _=c.length,A=u.length,O=Math.min(_,A);let T;for(T=0;T<O;T++){const R=u[T]=v?Ze(u[T]):_e(u[T]);E(c[T],R,h,null,b,m,S,w,v)}_>A?Ct(c,b,m,!0,!1,O):ce(u,h,y,b,m,S,w,v,O)},St=(c,u,h,y,b,m,S,w,v)=>{let _=0;const A=u.length;let O=c.length-1,T=A-1;for(;_<=O&&_<=T;){const R=c[_],D=u[_]=v?Ze(u[_]):_e(u[_]);if(Mt(R,D))E(R,D,h,null,b,m,S,w,v);else break;_++}for(;_<=O&&_<=T;){const R=c[O],D=u[T]=v?Ze(u[T]):_e(u[T]);if(Mt(R,D))E(R,D,h,null,b,m,S,w,v);else break;O--,T--}if(_>O){if(_<=T){const R=T+1,D=R<A?u[R].el:y;for(;_<=T;)E(null,u[_]=v?Ze(u[_]):_e(u[_]),h,D,b,m,S,w,v),_++}}else if(_>T)for(;_<=O;)ze(c[_],b,m,!0),_++;else{const R=_,D=_,k=new Map;for(_=D;_<=T;_++){const se=u[_]=v?Ze(u[_]):_e(u[_]);se.key!=null&&(k.has(se.key)&&x("Duplicate keys found during update:",JSON.stringify(se.key),"Make sure keys are unique."),k.set(se.key,_))}let B,ue=0;const ae=T-D+1;let Te=!1,Ee=0;const Tt=new Array(ae);for(_=0;_<ae;_++)Tt[_]=0;for(_=R;_<=O;_++){const se=c[_];if(ue>=ae){ze(se,b,m,!0);continue}let $e;if(se.key!=null)$e=k.get(se.key);else for(B=D;B<=T;B++)if(Tt[B-D]===0&&Mt(se,u[B])){$e=B;break}$e===void 0?ze(se,b,m,!0):(Tt[$e-D]=_+1,$e>=Ee?Ee=$e:Te=!0,E(se,u[$e],h,null,b,m,S,w,v),ue++)}const Fs=Te?Ul(Tt):_t;for(B=Fs.length-1,_=ae-1;_>=0;_--){const se=D+_,$e=u[se],js=u[se+1],Ds=se+1<A?js.el||js.placeholder:y;Tt[_]===0?E(null,$e,h,Ds,b,m,S,w,v):Te&&(B<0||_!==Fs[B]?dt($e,h,Ds,2):B--)}}},dt=(c,u,h,y,b=null)=>{const{el:m,type:S,transition:w,children:v,shapeFlag:_}=c;if(_&6){dt(c.component.subTree,u,h,y);return}if(_&128){c.suspense.move(u,h,y);return}if(_&64){S.move(c,u,h,Ot);return}if(S===Pe){s(m,u,h);for(let O=0;O<v.length;O++)dt(v[O],u,h,y);s(c.anchor,u,h);return}if(S===rn){pe(c,u,h);return}if(y!==2&&_&1&&w)if(y===0)w.beforeEnter(m),s(m,u,h),he(()=>w.enter(m),b);else{const{leave:O,delayLeave:T,afterLeave:R}=w,D=()=>{c.ctx.isUnmounted?r(m):s(m,u,h)},k=()=>{m._isLeaving&&m[Qi](!0),O(m,()=>{D(),R&&R()})};T?T(m,D,k):k()}else s(m,u,h)},ze=(c,u,h,y=!1,b=!1)=>{const{type:m,props:S,ref:w,children:v,dynamicChildren:_,shapeFlag:A,patchFlag:O,dirs:T,cacheIndex:R}=c;if(O===-2&&(b=!1),w!=null&&(Se(),jt(w,null,h,c,!0),Ce()),R!=null&&(u.renderCache[R]=void 0),A&256){u.ctx.deactivate(c);return}const D=A&1&&T,k=!Dt(c);let B;if(k&&(B=S&&S.onVnodeBeforeUnmount)&&Me(B,u,c),A&6)Do(c.component,h,y);else{if(A&128){c.suspense.unmount(h,y);return}D&&nt(c,null,u,"beforeUnmount"),A&64?c.type.remove(c,u,h,Ot,y):_&&!_.hasOnce&&(m!==Pe||O>0&&O&64)?Ct(_,u,h,!1,!0):(m===Pe&&O&384||!b&&A&16)&&Ct(v,u,h),y&&Fn(c)}(k&&(B=S&&S.onVnodeUnmounted)||D)&&he(()=>{B&&Me(B,u,c),D&&nt(c,null,u,"unmounted")},h)},Fn=c=>{const{type:u,el:h,anchor:y,transition:b}=c;if(u===Pe){c.patchFlag>0&&c.patchFlag&2048&&b&&!b.persisted?c.children.forEach(S=>{S.type===me?r(S.el):Fn(S)}):jo(h,y);return}if(u===rn){$(c);return}const m=()=>{r(h),b&&!b.persisted&&b.afterLeave&&b.afterLeave()};if(c.shapeFlag&1&&b&&!b.persisted){const{leave:S,delayLeave:w}=b,v=()=>S(h,m);w?w(c.el,m,v):v()}else m()},jo=(c,u)=>{let h;for(;c!==u;)h=g(c),r(c),c=h;r(u)},Do=(c,u,h)=>{c.type.__hmrId&&Ni(c);const{bum:y,scope:b,job:m,subTree:S,um:w,m:v,a:_}=c;Zs(v),Zs(_),y&&mt(y),b.stop(),m&&(m.flags|=8,ze(S,c,u,h)),w&&he(w,u),he(()=>{c.isUnmounted=!0},u),Gi(c)},Ct=(c,u,h,y=!1,b=!1,m=0)=>{for(let S=m;S<c.length;S++)ze(c[S],u,h,y,b)},zt=c=>{if(c.shapeFlag&6)return zt(c.component.subTree);if(c.shapeFlag&128)return c.suspense.next();const u=g(c.anchor||c.el),h=u&&u[Xi];return h?g(h):u};let jn=!1;const Rs=(c,u,h)=>{c==null?u._vnode&&ze(u._vnode,null,null,!0):E(u._vnode||null,c,u,null,null,null,h),u._vnode=c,jn||(jn=!0,Ks(),Yr(),jn=!1)},Ot={p:E,um:ze,m:dt,r:Fn,mt:Ye,mc:ce,pc:Oe,pbc:Je,n:zt,o:e};return{render:Rs,hydrate:void 0,createApp:Sl(Rs)}}function Bn({type:e,props:t},n){return n==="svg"&&e==="foreignObject"||n==="mathml"&&e==="annotation-xml"&&t&&t.encoding&&t.encoding.includes("html")?void 0:n}function st({effect:e,job:t},n){n?(e.flags|=32,t.flags|=4):(e.flags&=-33,t.flags&=-5)}function Kl(e,t){return(!e||e&&!e.pendingBranch)&&t&&!t.persisted}function is(e,t,n=!1){const s=e.children,r=t.children;if(M(s)&&M(r))for(let o=0;o<s.length;o++){const i=s[o];let l=r[o];l.shapeFlag&1&&!l.dynamicChildren&&((l.patchFlag<=0||l.patchFlag===32)&&(l=r[o]=Ze(r[o]),l.el=i.el),!n&&l.patchFlag!==-2&&is(i,l)),l.type===qt&&l.patchFlag!==-1&&(l.el=i.el),l.type===me&&!l.el&&(l.el=i.el),l.el&&(l.el.__vnode=l)}}function Ul(e){const t=e.slice(),n=[0];let s,r,o,i,l;const f=e.length;for(s=0;s<f;s++){const p=e[s];if(p!==0){if(r=n[n.length-1],e[r]<p){t[s]=r,n.push(s);continue}for(o=0,i=n.length-1;o<i;)l=o+i>>1,e[n[l]]<p?o=l+1:i=l;p<e[n[o]]&&(o>0&&(t[s]=n[o-1]),n[o]=s)}}for(o=n.length,i=n[o-1];o-- >0;)n[o]=i,i=t[i];return n}function _o(e){const t=e.subTree.component;if(t)return t.asyncDep&&!t.asyncResolved?t:_o(t)}function Zs(e){if(e)for(let t=0;t<e.length;t++)e[t].flags|=8}const Bl=Symbol.for("v-scx"),Wl=()=>{{const e=sn(Bl);return e||x("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."),e}};function Wn(e,t,n){return P(t)||x("\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature."),vo(e,t,n)}function vo(e,t,n=U){const{immediate:s,deep:r,flush:o,once:i}=n;t||(s!==void 0&&x('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'),r!==void 0&&x('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'),i!==void 0&&x('watch() "once" option is only respected when using the watch(source, callback, options?) signature.'));const l=Y({},n);l.onWarn=x;const f=t&&s||!t&&o!=="post";let p;if(Ut){if(o==="sync"){const C=Wl();p=C.__watcherHandles||(C.__watcherHandles=[])}else if(!f){const C=()=>{};return C.stop=ne,C.resume=ne,C.pause=ne,C}}const d=ee;l.call=(C,I,E)=>He(C,d,I,E);let a=!1;o==="post"?l.scheduler=C=>{he(C,d&&d.suspense)}:o!=="sync"&&(a=!0,l.scheduler=(C,I)=>{I?C():En(C)}),l.augmentJob=C=>{t&&(C.flags|=4),a&&(C.flags|=2,d&&(C.id=d.uid,C.i=d))};const g=Mi(e,t,l);return Ut&&(p?p.push(g):f&&g()),g}function kl(e,t,n){const s=this.proxy,r=q(e)?e.includes(".")?wo(s,e):()=>s[e]:e.bind(s,s);let o;P(t)?o=t:(o=t.handler,n=t);const i=Jt(this),l=vo(r,o.bind(s),n);return i(),l}function wo(e,t){const n=t.split(".");return()=>{let s=e;for(let r=0;r<n.length&&s;r++)s=s[n[r]];return s}}const Gl=(e,t)=>t==="modelValue"||t==="model-value"?e.modelModifiers:e[\`\${t}Modifiers\`]||e[\`\${ve(t)}Modifiers\`]||e[\`\${ke(t)}Modifiers\`];function ql(e,t,...n){if(e.isUnmounted)return;const s=e.vnode.props||U;{const{emitsOptions:d,propsOptions:[a]}=e;if(d)if(!(t in d))(!a||!(rt(ve(t))in a))&&x(\`Component emitted event "\${t}" but it is neither declared in the emits option nor as an "\${rt(ve(t))}" prop.\`);else{const g=d[t];P(g)&&(g(...n)||x(\`Invalid event arguments: event validation failed for event "\${t}".\`))}}let r=n;const o=t.startsWith("update:"),i=o&&Gl(s,t.slice(7));i&&(i.trim&&(r=n.map(d=>q(d)?d.trim():d)),i.number&&(r=n.map(Jn))),Yi(e,t,r);{const d=t.toLowerCase();d!==t&&s[rt(d)]&&x(\`Event "\${d}" is emitted in component \${In(e,e.type)} but the handler is registered for "\${t}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "\${ke(t)}" instead of "\${t}".\`)}let l,f=s[l=rt(t)]||s[l=rt(ve(t))];!f&&o&&(f=s[l=rt(ke(t))]),f&&He(f,e,6,r);const p=s[l+"Once"];if(p){if(!e.emitted)e.emitted={};else if(e.emitted[l])return;e.emitted[l]=!0,He(p,e,6,r)}}const Jl=new WeakMap;function xo(e,t,n=!1){const s=n?Jl:t.emitsCache,r=s.get(e);if(r!==void 0)return r;const o=e.emits;let i={},l=!1;if(!P(e)){const f=p=>{const d=xo(p,t,!0);d&&(l=!0,Y(i,d))};!n&&t.mixins.length&&t.mixins.forEach(f),e.extends&&f(e.extends),e.mixins&&e.mixins.forEach(f)}return!o&&!l?(W(e)&&s.set(e,null),null):(M(o)?o.forEach(f=>i[f]=null):Y(i,o),W(e)&&s.set(e,i),i)}function Mn(e,t){return!e||!Bt(t)?!1:(t=t.slice(2).replace(/Once$/,""),H(e,t[0].toLowerCase()+t.slice(1))||H(e,ke(t))||H(e,t))}let ls=!1;function _n(){ls=!0}function Qs(e){const{type:t,vnode:n,proxy:s,withProxy:r,propsOptions:[o],slots:i,attrs:l,emit:f,render:p,renderCache:d,props:a,data:g,setupState:C,ctx:I,inheritAttrs:E}=e,z=gn(e);let G,V;ls=!1;try{if(n.shapeFlag&4){const $=r||s,X=C.__isScriptSetup?new Proxy($,{get(be,te,ce){return x(\`Property '\${String(te)}' was accessed via 'this'. Avoid using 'this' in templates.\`),Reflect.get(be,te,ce)}}):$;G=_e(p.call(X,$,d,Fe(a),C,g,I)),V=l}else{const $=t;l===a&&_n(),G=_e($.length>1?$(Fe(a),{get attrs(){return _n(),Fe(l)},slots:i,emit:f}):$(Fe(a),null)),V=t.props?l:Yl(l)}}catch($){Ht.length=0,kt($,e,1),G=Be(me)}let N=G,pe;if(G.patchFlag>0&&G.patchFlag&2048&&([N,pe]=So(G)),V&&E!==!1){const $=Object.keys(V),{shapeFlag:X}=N;if($.length){if(X&7)o&&$.some(cn)&&(V=zl(V,o)),N=et(N,V,!1,!0);else if(!ls&&N.type!==me){const be=Object.keys(l),te=[],ce=[];for(let Le=0,Je=be.length;Le<Je;Le++){const ye=be[Le];Bt(ye)?cn(ye)||te.push(ye[2].toLowerCase()+ye.slice(3)):ce.push(ye)}ce.length&&x(\`Extraneous non-props attributes (\${ce.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.\`),te.length&&x(\`Extraneous non-emits event listeners (\${te.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.\`)}}}return n.dirs&&(er(N)||x("Runtime directive used on component with non-element root node. The directives will not function as intended."),N=et(N,null,!1,!0),N.dirs=N.dirs?N.dirs.concat(n.dirs):n.dirs),n.transition&&(er(N)||x("Component inside <Transition> renders non-element root node that cannot be animated."),Os(N,n.transition)),pe?pe(N):G=N,gn(z),G}const So=e=>{const t=e.children,n=e.dynamicChildren,s=As(t,!1);if(s){if(s.patchFlag>0&&s.patchFlag&2048)return So(s)}else return[e,void 0];const r=t.indexOf(s),o=n?n.indexOf(s):-1,i=l=>{t[r]=l,n&&(o>-1?n[o]=l:l.patchFlag>0&&(e.dynamicChildren=[...n,l]))};return[_e(s),i]};function As(e,t=!0){let n;for(let s=0;s<e.length;s++){const r=e[s];if(An(r)){if(r.type!==me||r.children==="v-if"){if(n)return;if(n=r,t&&n.patchFlag>0&&n.patchFlag&2048)return As(n.children)}}else return}return n}const Yl=e=>{let t;for(const n in e)(n==="class"||n==="style"||Bt(n))&&((t||(t={}))[n]=e[n]);return t},zl=(e,t)=>{const n={};for(const s in e)(!cn(s)||!(s.slice(9)in t))&&(n[s]=e[s]);return n},er=e=>e.shapeFlag&7||e.type===me;function Xl(e,t,n){const{props:s,children:r,component:o}=e,{props:i,children:l,patchFlag:f}=t,p=o.emitsOptions;if((r||l)&&je||t.dirs||t.transition)return!0;if(n&&f>=0){if(f&1024)return!0;if(f&16)return s?tr(s,i,p):!!i;if(f&8){const d=t.dynamicProps;for(let a=0;a<d.length;a++){const g=d[a];if(i[g]!==s[g]&&!Mn(p,g))return!0}}}else return(r||l)&&(!l||!l.$stable)?!0:s===i?!1:s?i?tr(s,i,p):!0:!!i;return!1}function tr(e,t,n){const s=Object.keys(t);if(s.length!==Object.keys(e).length)return!0;for(let r=0;r<s.length;r++){const o=s[r];if(t[o]!==e[o]&&!Mn(n,o))return!0}return!1}function Zl({vnode:e,parent:t},n){for(;t;){const s=t.subTree;if(s.suspense&&s.suspense.activeBranch===e&&(s.el=e.el),s===e)(e=t.vnode).el=n,t=t.parent;else break}}const Co=e=>e.__isSuspense;function Ql(e,t){t&&t.pendingBranch?M(e)?t.effects.push(...e):t.effects.push(e):Jr(e)}const Pe=Symbol.for("v-fgt"),qt=Symbol.for("v-txt"),me=Symbol.for("v-cmt"),rn=Symbol.for("v-stc"),Ht=[];let ge=null;function ec(e=!1){Ht.push(ge=e?null:[])}function tc(){Ht.pop(),ge=Ht[Ht.length-1]||null}let Kt=1;function nr(e,t=!1){Kt+=e,e<0&&ge&&t&&(ge.hasOnce=!0)}function Oo(e){return e.dynamicChildren=Kt>0?ge||_t:null,tc(),Kt>0&&ge&&ge.push(e),e}function rf(e,t,n,s,r,o){return Oo(Eo(e,t,n,s,r,o,!0))}function nc(e,t,n,s,r){return Oo(Be(e,t,n,s,r,!0))}function An(e){return e?e.__v_isVNode===!0:!1}function Mt(e,t){if(t.shapeFlag&6&&e.component){const n=nn.get(t.type);if(n&&n.has(e.component))return e.shapeFlag&=-257,t.shapeFlag&=-513,!1}return e.type===t.type&&e.key===t.key}const sc=(...e)=>rc(...e),To=({key:e})=>e??null,on=({ref:e,ref_key:t,ref_for:n})=>(typeof e=="number"&&(e=""+e),e!=null?q(e)||J(e)||P(e)?{i:ie,r:e,k:t,f:!!n}:e:null);function Eo(e,t=null,n=null,s=0,r=null,o=e===Pe?0:1,i=!1,l=!1){const f={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&To(t),ref:t&&on(t),scopeId:to,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetStart:null,targetAnchor:null,staticCount:0,shapeFlag:o,patchFlag:s,dynamicProps:r,dynamicChildren:null,appContext:null,ctx:ie};return l?(Ps(f,n),o&128&&e.normalize(f)):n&&(f.shapeFlag|=q(n)?8:16),f.key!==f.key&&x("VNode created with invalid key (NaN). VNode type:",f.type),Kt>0&&!i&&ge&&(f.patchFlag>0||o&6)&&f.patchFlag!==32&&ge.push(f),f}const Be=sc;function rc(e,t=null,n=null,s=0,r=null,o=!1){if((!e||e===dl)&&(e||x(\`Invalid vnode type when creating vnode: \${e}.\`),e=me),An(e)){const l=et(e,t,!0);return n&&Ps(l,n),Kt>0&&!o&&ge&&(l.shapeFlag&6?ge[ge.indexOf(e)]=l:ge.push(l)),l.patchFlag=-2,l}if(Ro(e)&&(e=e.__vccOpts),t){t=oc(t);let{class:l,style:f}=t;l&&!q(l)&&(t.class=ms(l)),W(f)&&(un(f)&&!M(f)&&(f=Y({},f)),t.style=gs(f))}const i=q(e)?1:Co(e)?128:Zi(e)?64:W(e)?4:P(e)?2:0;return i&4&&un(e)&&(e=F(e),x("Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.",\`
Component that was made reactive: \`,e)),Eo(e,t,n,s,r,i,o,!0)}function oc(e){return e?un(e)||po(e)?Y({},e):e:null}function et(e,t,n=!1,s=!1){const{props:r,ref:o,patchFlag:i,children:l,transition:f}=e,p=t?lc(r||{},t):r,d={__v_isVNode:!0,__v_skip:!0,type:e.type,props:p,key:p&&To(p),ref:t&&t.ref?n&&o?M(o)?o.concat(on(t)):[o,on(t)]:on(t):o,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:i===-1&&M(l)?l.map($o):l,target:e.target,targetStart:e.targetStart,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==Pe?i===-1?16:i|16:i,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:f,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&et(e.ssContent),ssFallback:e.ssFallback&&et(e.ssFallback),placeholder:e.placeholder,el:e.el,anchor:e.anchor,ctx:e.ctx,ce:e.ce};return f&&s&&Os(d,f.clone(d)),d}function $o(e){const t=et(e);return M(e.children)&&(t.children=e.children.map($o)),t}function ic(e=" ",t=0){return Be(qt,null,e,t)}function of(e="",t=!1){return t?(ec(),nc(me,null,e)):Be(me,null,e)}function _e(e){return e==null||typeof e=="boolean"?Be(me):M(e)?Be(Pe,null,e.slice()):An(e)?Ze(e):Be(qt,null,String(e))}function Ze(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:et(e)}function Ps(e,t){let n=0;const{shapeFlag:s}=e;if(t==null)t=null;else if(M(t))n=16;else if(typeof t=="object")if(s&65){const r=t.default;r&&(r._c&&(r._d=!1),Ps(e,r()),r._c&&(r._d=!0));return}else{n=32;const r=t._;!r&&!po(t)?t._ctx=ie:r===3&&ie&&(ie.slots._===1?t._=1:(t._=2,e.patchFlag|=1024))}else P(t)?(t={default:t,_ctx:ie},n=32):(t=String(t),s&64?(n=16,t=[ic(t)]):n=8);e.children=t,e.shapeFlag|=n}function lc(...e){const t={};for(let n=0;n<e.length;n++){const s=e[n];for(const r in s)if(r==="class")t.class!==s.class&&(t.class=ms([t.class,s.class]));else if(r==="style")t.style=gs([t.style,s.style]);else if(Bt(r)){const o=t[r],i=s[r];i&&o!==i&&!(M(o)&&o.includes(i))&&(t[r]=o?[].concat(o,i):i)}else r!==""&&(t[r]=s[r])}return t}function Me(e,t,n,s=null){He(e,t,7,[n,s])}const cc=fo();let fc=0;function uc(e,t,n){const s=e.type,r=(t?t.appContext:e.appContext)||cc,o={uid:fc++,vnode:e,type:s,parent:t,appContext:r,root:null,next:null,subTree:null,effect:null,update:null,job:null,scope:new ei(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(r.provides),ids:t?t.ids:["",0,0],accessCache:null,renderCache:[],components:null,directives:null,propsOptions:go(s,r),emitsOptions:xo(s,r),emit:null,emitted:null,propsDefaults:U,inheritAttrs:s.inheritAttrs,ctx:U,data:U,props:U,attrs:U,slots:U,refs:U,setupState:U,setupContext:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return o.ctx=pl(o),o.root=t?t.root:o,o.emit=ql.bind(null,o),e.ce&&e.ce(o),o}let ee=null;const Mo=()=>ee||ie;let vn,cs;{const e=Wt(),t=(n,s)=>{let r;return(r=e[n])||(r=e[n]=[]),r.push(s),o=>{r.length>1?r.forEach(i=>i(o)):r[0](o)}};vn=t("__VUE_INSTANCE_SETTERS__",n=>ee=n),cs=t("__VUE_SSR_SETTERS__",n=>Ut=n)}const Jt=e=>{const t=ee;return vn(e),e.scope.on(),()=>{e.scope.off(),vn(t)}},sr=()=>{ee&&ee.scope.off(),vn(null)},ac=Ge("slot,component");function fs(e,{isNativeTag:t}){(ac(e)||t(e))&&x("Do not use built-in or reserved HTML elements as component id: "+e)}function Ao(e){return e.vnode.shapeFlag&4}let Ut=!1;function dc(e,t=!1,n=!1){t&&cs(t);const{props:s,children:r}=e.vnode,o=Ao(e);Ol(e,s,o,t),Dl(e,r,n||t);const i=o?pc(e,t):void 0;return t&&cs(!1),i}function pc(e,t){var n;const s=e.type;{if(s.name&&fs(s.name,e.appContext.config),s.components){const o=Object.keys(s.components);for(let i=0;i<o.length;i++)fs(o[i],e.appContext.config)}if(s.directives){const o=Object.keys(s.directives);for(let i=0;i<o.length;i++)no(o[i])}s.compilerOptions&&hc()&&x('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.')}e.accessCache=Object.create(null),e.proxy=new Proxy(e.ctx,io),hl(e);const{setup:r}=s;if(r){Se();const o=e.setupContext=r.length>1?bc(e):null,i=Jt(e),l=xt(r,e,0,[Fe(e.props),o]),f=ds(l);if(Ce(),i(),(f||e.sp)&&!Dt(e)&&so(e),f){if(l.then(sr,sr),t)return l.then(p=>{rr(e,p,t)}).catch(p=>{kt(p,e,0)});if(e.asyncDep=l,!e.suspense){const p=(n=s.name)!=null?n:"Anonymous";x(\`Component <\${p}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.\`)}}else rr(e,l,t)}else Po(e,t)}function rr(e,t,n){P(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:W(t)?(An(t)&&x("setup() should not return VNodes directly - return a render function instead."),e.devtoolsRawSetupState=t,e.setupState=Wr(t),gl(e)):t!==void 0&&x(\`setup() should return an object. Received: \${t===null?"null":typeof t}\`),Po(e,n)}const hc=()=>!0;function Po(e,t,n){const s=e.type;e.render||(e.render=s.render||ne);{const r=Jt(e);Se();try{bl(e)}finally{Ce(),r()}}!s.render&&e.render===ne&&!t&&(s.template?x('Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'):x("Component is missing template or render function: ",s))}const gc={get(e,t){return _n(),Z(e,"get",""),e[t]},set(){return x("setupContext.attrs is readonly."),!1},deleteProperty(){return x("setupContext.attrs is readonly."),!1}};function mc(e){return new Proxy(e.slots,{get(t,n){return Z(e,"get","$slots"),t[n]}})}function bc(e){const t=n=>{if(e.exposed&&x("expose() should be called only once per setup()."),n!=null){let s=typeof n;s==="object"&&(M(n)?s="array":J(n)&&(s="ref")),s!=="object"&&x(\`expose() should be passed a plain object, received \${s}.\`)}e.exposed=n||{}};{let n,s;return Object.freeze({get attrs(){return n||(n=new Proxy(e.attrs,gc))},get slots(){return s||(s=mc(e))},get emit(){return(r,...o)=>e.emit(r,...o)},expose:t})}}function Pn(e){return e.exposed?e.exposeProxy||(e.exposeProxy=new Proxy(Wr(wi(e.exposed)),{get(t,n){if(n in t)return t[n];if(n in ut)return ut[n](e)},has(t,n){return n in t||n in ut}})):e.proxy}const yc=/(?:^|[-_])\\w/g,_c=e=>e.replace(yc,t=>t.toUpperCase()).replace(/[-_]/g,"");function Io(e,t=!0){return P(e)?e.displayName||e.name:e.name||t&&e.__name}function In(e,t,n=!1){let s=Io(t);if(!s&&t.__file){const r=t.__file.match(/([^/\\\\]+)\\.\\w+$/);r&&(s=r[1])}if(!s&&e&&e.parent){const r=o=>{for(const i in o)if(o[i]===t)return i};s=r(e.components||e.parent.type.components)||r(e.appContext.components)}return s?_c(s):n?"App":"Anonymous"}function Ro(e){return P(e)&&"__vccOpts"in e}const vc=(e,t)=>{const n=Ei(e,t,Ut);{const s=Mo();s&&s.appContext.config.warnRecursiveComputed&&(n._warnRecursive=!0)}return n};function wc(){if(typeof window>"u")return;const e={style:"color:#3ba776"},t={style:"color:#1677ff"},n={style:"color:#f5222d"},s={style:"color:#eb2f96"},r={__vue_custom_formatter:!0,header(a){if(!W(a))return null;if(a.__isVue)return["div",e,"VueInstance"];if(J(a)){Se();const g=a.value;return Ce(),["div",{},["span",e,d(a)],"<",l(g),">"]}else{if(ct(a))return["div",{},["span",e,le(a)?"ShallowReactive":"Reactive"],"<",l(a),\`>\${De(a)?" (readonly)":""}\`];if(De(a))return["div",{},["span",e,le(a)?"ShallowReadonly":"Readonly"],"<",l(a),">"]}return null},hasBody(a){return a&&a.__isVue},body(a){if(a&&a.__isVue)return["div",{},...o(a.$)]}};function o(a){const g=[];a.type.props&&a.props&&g.push(i("props",F(a.props))),a.setupState!==U&&g.push(i("setup",a.setupState)),a.data!==U&&g.push(i("data",F(a.data)));const C=f(a,"computed");C&&g.push(i("computed",C));const I=f(a,"inject");return I&&g.push(i("injected",I)),g.push(["div",{},["span",{style:s.style+";opacity:0.66"},"$ (internal): "],["object",{object:a}]]),g}function i(a,g){return g=Y({},g),Object.keys(g).length?["div",{style:"line-height:1.25em;margin-bottom:0.6em"},["div",{style:"color:#476582"},a],["div",{style:"padding-left:1.25em"},...Object.keys(g).map(C=>["div",{},["span",s,C+": "],l(g[C],!1)])]]:["span",{}]}function l(a,g=!0){return typeof a=="number"?["span",t,a]:typeof a=="string"?["span",n,JSON.stringify(a)]:typeof a=="boolean"?["span",s,a]:W(a)?["object",{object:g?F(a):a}]:["span",n,String(a)]}function f(a,g){const C=a.type;if(P(C))return;const I={};for(const E in a.ctx)p(C,E,g)&&(I[E]=a.ctx[E]);return I}function p(a,g,C){const I=a[C];if(M(I)&&I.includes(g)||W(I)&&g in I||a.extends&&p(a.extends,g,C)||a.mixins&&a.mixins.some(E=>p(E,g,C)))return!0}function d(a){return le(a)?"ShallowRef":a.effect?"ComputedRef":"Ref"}window.devtoolsFormatters?window.devtoolsFormatters.push(r):window.devtoolsFormatters=[r]}const or="3.5.22",We=x;/**
* @vue/runtime-dom v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let us;const ir=typeof window<"u"&&window.trustedTypes;if(ir)try{us=ir.createPolicy("vue",{createHTML:e=>e})}catch(e){We(\`Error creating trusted types policy: \${e}\`)}const Fo=us?e=>us.createHTML(e):e=>e,xc="http://www.w3.org/2000/svg",Sc="http://www.w3.org/1998/Math/MathML",Ve=typeof document<"u"?document:null,lr=Ve&&Ve.createElement("template"),Cc={insert:(e,t,n)=>{t.insertBefore(e,n||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,n,s)=>{const r=t==="svg"?Ve.createElementNS(xc,e):t==="mathml"?Ve.createElementNS(Sc,e):n?Ve.createElement(e,{is:n}):Ve.createElement(e);return e==="select"&&s&&s.multiple!=null&&r.setAttribute("multiple",s.multiple),r},createText:e=>Ve.createTextNode(e),createComment:e=>Ve.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>Ve.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},insertStaticContent(e,t,n,s,r,o){const i=n?n.previousSibling:t.lastChild;if(r&&(r===o||r.nextSibling))for(;t.insertBefore(r.cloneNode(!0),n),!(r===o||!(r=r.nextSibling)););else{lr.innerHTML=Fo(s==="svg"?\`<svg>\${e}</svg>\`:s==="mathml"?\`<math>\${e}</math>\`:e);const l=lr.content;if(s==="svg"||s==="mathml"){const f=l.firstChild;for(;f.firstChild;)l.appendChild(f.firstChild);l.removeChild(f)}t.insertBefore(l,n)}return[i?i.nextSibling:t.firstChild,n?n.previousSibling:t.lastChild]}},Oc=Symbol("_vtc");function Tc(e,t,n){const s=e[Oc];s&&(t=(t?[t,...s]:[...s]).join(" ")),t==null?e.removeAttribute("class"):n?e.setAttribute("class",t):e.className=t}const cr=Symbol("_vod"),Ec=Symbol("_vsh"),$c=Symbol("CSS_VAR_TEXT"),Mc=/(?:^|;)\\s*display\\s*:/;function Ac(e,t,n){const s=e.style,r=q(n);let o=!1;if(n&&!r){if(t)if(q(t))for(const i of t.split(";")){const l=i.slice(0,i.indexOf(":")).trim();n[l]==null&&ln(s,l,"")}else for(const i in t)n[i]==null&&ln(s,i,"");for(const i in n)i==="display"&&(o=!0),ln(s,i,n[i])}else if(r){if(t!==n){const i=s[$c];i&&(n+=";"+i),s.cssText=n,o=Mc.test(n)}}else t&&e.removeAttribute("style");cr in e&&(e[cr]=o?s.display:"",e[Ec]&&(s.display="none"))}const Pc=/[^\\\\];\\s*$/,fr=/\\s*!important$/;function ln(e,t,n){if(M(n))n.forEach(s=>ln(e,t,s));else if(n==null&&(n=""),Pc.test(n)&&We(\`Unexpected semicolon at the end of '\${t}' style value: '\${n}'\`),t.startsWith("--"))e.setProperty(t,n);else{const s=Ic(e,t);fr.test(n)?e.setProperty(ke(s),n.replace(fr,""),"important"):e[s]=n}}const ur=["Webkit","Moz","ms"],kn={};function Ic(e,t){const n=kn[t];if(n)return n;let s=ve(t);if(s!=="filter"&&s in e)return kn[t]=s;s=Sn(s);for(let r=0;r<ur.length;r++){const o=ur[r]+s;if(o in e)return kn[t]=o}return t}const ar="http://www.w3.org/1999/xlink";function dr(e,t,n,s,r,o=Zo(t)){s&&t.startsWith("xlink:")?n==null?e.removeAttributeNS(ar,t.slice(6,t.length)):e.setAttributeNS(ar,t,n):n==null||o&&!Or(n)?e.removeAttribute(t):e.setAttribute(t,o?"":tt(n)?String(n):n)}function pr(e,t,n,s,r){if(t==="innerHTML"||t==="textContent"){n!=null&&(e[t]=t==="innerHTML"?Fo(n):n);return}const o=e.tagName;if(t==="value"&&o!=="PROGRESS"&&!o.includes("-")){const l=o==="OPTION"?e.getAttribute("value")||"":e.value,f=n==null?e.type==="checkbox"?"on":"":String(n);(l!==f||!("_value"in e))&&(e.value=f),n==null&&e.removeAttribute(t),e._value=n;return}let i=!1;if(n===""||n==null){const l=typeof e[t];l==="boolean"?n=Or(n):n==null&&l==="string"?(n="",i=!0):l==="number"&&(n=0,i=!0)}try{e[t]=n}catch(l){i||We(\`Failed setting prop "\${t}" on <\${o.toLowerCase()}>: value \${n} is invalid.\`,l)}i&&e.removeAttribute(r||t)}function yt(e,t,n,s){e.addEventListener(t,n,s)}function Rc(e,t,n,s){e.removeEventListener(t,n,s)}const hr=Symbol("_vei");function Fc(e,t,n,s,r=null){const o=e[hr]||(e[hr]={}),i=o[t];if(s&&i)i.value=mr(s,t);else{const[l,f]=jc(t);if(s){const p=o[t]=Lc(mr(s,t),r);yt(e,l,p,f)}else i&&(Rc(e,l,i,f),o[t]=void 0)}}const gr=/(?:Once|Passive|Capture)$/;function jc(e){let t;if(gr.test(e)){t={};let s;for(;s=e.match(gr);)e=e.slice(0,e.length-s[0].length),t[s[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):ke(e.slice(2)),t]}let Gn=0;const Dc=Promise.resolve(),Hc=()=>Gn||(Dc.then(()=>Gn=0),Gn=Date.now());function Lc(e,t){const n=s=>{if(!s._vts)s._vts=Date.now();else if(s._vts<=n.attached)return;He(Nc(s,n.value),t,5,[s])};return n.value=e,n.attached=Hc(),n}function mr(e,t){return P(e)||M(e)?e:(We(\`Wrong type passed as event handler to \${t} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type \${typeof e}.\`),ne)}function Nc(e,t){if(M(t)){const n=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{n.call(e),e._stopped=!0},t.map(s=>r=>!r._stopped&&s&&s(r))}else return t}const br=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&e.charCodeAt(2)>96&&e.charCodeAt(2)<123,Vc=(e,t,n,s,r,o)=>{const i=r==="svg";t==="class"?Tc(e,s,i):t==="style"?Ac(e,n,s):Bt(t)?cn(t)||Fc(e,t,n,s,o):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):Kc(e,t,s,i))?(pr(e,t,s),!e.tagName.includes("-")&&(t==="value"||t==="checked"||t==="selected")&&dr(e,t,s,i,o,t!=="value")):e._isVueCE&&(/[A-Z]/.test(t)||!q(s))?pr(e,ve(t),s,o,t):(t==="true-value"?e._trueValue=s:t==="false-value"&&(e._falseValue=s),dr(e,t,s,i))};function Kc(e,t,n,s){if(s)return!!(t==="innerHTML"||t==="textContent"||t in e&&br(t)&&P(n));if(t==="spellcheck"||t==="draggable"||t==="translate"||t==="autocorrect"||t==="form"||t==="list"&&e.tagName==="INPUT"||t==="type"&&e.tagName==="TEXTAREA")return!1;if(t==="width"||t==="height"){const r=e.tagName;if(r==="IMG"||r==="VIDEO"||r==="CANVAS"||r==="SOURCE")return!1}return br(t)&&q(n)?!1:t in e}const yr=e=>{const t=e.props["onUpdate:modelValue"]||!1;return M(t)?n=>mt(t,n):t};function Uc(e){e.target.composing=!0}function _r(e){const t=e.target;t.composing&&(t.composing=!1,t.dispatchEvent(new Event("input")))}const qn=Symbol("_assign"),lf={created(e,{modifiers:{lazy:t,trim:n,number:s}},r){e[qn]=yr(r);const o=s||r.props&&r.props.type==="number";yt(e,t?"change":"input",i=>{if(i.target.composing)return;let l=e.value;n&&(l=l.trim()),o&&(l=Jn(l)),e[qn](l)}),n&&yt(e,"change",()=>{e.value=e.value.trim()}),t||(yt(e,"compositionstart",Uc),yt(e,"compositionend",_r),yt(e,"change",_r))},mounted(e,{value:t}){e.value=t??""},beforeUpdate(e,{value:t,oldValue:n,modifiers:{lazy:s,trim:r,number:o}},i){if(e[qn]=yr(i),e.composing)return;const l=(o||e.type==="number")&&!/^0\\d/.test(e.value)?Jn(e.value):e.value,f=t??"";l!==f&&(document.activeElement===e&&e.type!=="range"&&(s&&t===n||r&&e.value.trim()===f)||(e.value=f))}},Bc=["ctrl","shift","alt","meta"],Wc={stop:e=>e.stopPropagation(),prevent:e=>e.preventDefault(),self:e=>e.target!==e.currentTarget,ctrl:e=>!e.ctrlKey,shift:e=>!e.shiftKey,alt:e=>!e.altKey,meta:e=>!e.metaKey,left:e=>"button"in e&&e.button!==0,middle:e=>"button"in e&&e.button!==1,right:e=>"button"in e&&e.button!==2,exact:(e,t)=>Bc.some(n=>e[\`\${n}Key\`]&&!t.includes(n))},cf=(e,t)=>{const n=e._withMods||(e._withMods={}),s=t.join(".");return n[s]||(n[s]=((r,...o)=>{for(let i=0;i<t.length;i++){const l=Wc[t[i]];if(l&&l(r,t))return}return e(r,...o)}))},kc={esc:"escape",space:" ",up:"arrow-up",left:"arrow-left",right:"arrow-right",down:"arrow-down",delete:"backspace"},ff=(e,t)=>{const n=e._withKeys||(e._withKeys={}),s=t.join(".");return n[s]||(n[s]=(r=>{if(!("key"in r))return;const o=ke(r.key);if(t.some(i=>i===o||kc[i]===o))return e(r)}))},Gc=Y({patchProp:Vc},Cc);let vr;function qc(){return vr||(vr=Nl(Gc))}const uf=((...e)=>{const t=qc().createApp(...e);Yc(t),zc(t);const{mount:n}=t;return t.mount=s=>{const r=Xc(s);if(!r)return;const o=t._component;!P(o)&&!o.render&&!o.template&&(o.template=r.innerHTML),r.nodeType===1&&(r.textContent="");const i=n(r,!1,Jc(r));return r instanceof Element&&(r.removeAttribute("v-cloak"),r.setAttribute("data-v-app","")),i},t});function Jc(e){if(e instanceof SVGElement)return"svg";if(typeof MathMLElement=="function"&&e instanceof MathMLElement)return"mathml"}function Yc(e){Object.defineProperty(e.config,"isNativeTag",{value:t=>Jo(t)||Yo(t)||zo(t),writable:!1})}function zc(e){{const t=e.config.isCustomElement;Object.defineProperty(e.config,"isCustomElement",{get(){return t},set(){We("The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.")}});const n=e.config.compilerOptions,s='The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.\\n- For vue-loader: pass it via vue-loader\\'s \`compilerOptions\` loader option.\\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';Object.defineProperty(e.config,"compilerOptions",{get(){return We(s),n},set(){We(s)}})}}function Xc(e){if(q(e)){const t=document.querySelector(e);return t||We(\`Failed to mount app: mount target selector "\${e}" returned null.\`),t}return window.ShadowRoot&&e instanceof window.ShadowRoot&&e.mode==="closed"&&We('mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs'),e}/**
* vue v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Zc(){wc()}Zc();const af=(e,t)=>{const n=e.__vccOpts||e;for(const[s,r]of t)n[s]=r;return n};export{Pe as F,af as _,ll as a,Eo as b,rf as c,nf as d,of as e,gs as f,ic as g,sf as h,tf as i,ff as j,ec as k,ms as l,uf as m,Di as n,rl as o,vc as p,ef as r,Qo as t,lf as v,cf as w};
`,
    mimeType: 'application/javascript',
    size: 91159
  },
  'dashboard.html': {
    content: `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>dmux Dashboard</title>
  <script type="module" crossorigin src="/dashboard.js"></script>
  <link rel="modulepreload" crossorigin href="/chunks/_plugin-vue_export-helper-Cvoq67hi.js">
  <link rel="stylesheet" crossorigin href="/_plugin-vue_export-helper.css">
</head>
<body>
  <div id="app"></div>
</body>
</html>
`,
    mimeType: 'text/html',
    size: 479
  },
  'dashboard.js': {
    content: `import{d as fe,r as u,o as ye,a as ke,n as I,_ as _e,c as i,b as t,t as g,e as v,f as be,g as E,F as k,h as M,w as N,i as X,v as Y,j as $,k as s,l as O,m as we}from"./chunks/_plugin-vue_export-helper-Cvoq67hi.js";const Ce=fe({__name:"Dashboard",setup(ae,{expose:n}){n();const q=u("Loading..."),e=u(""),j=u(!1),V=u([]),o=u(null),m=u("Never"),A=u({}),f=u(new Set),U=u({}),D=u(localStorage.getItem("dmux-theme")||"dark"),S=u(new Set),y=u(new Set),B=u(!1),T=u(""),b=u(null),H=u(!1),L=u([]),z=u(!1),P=u("prompt"),ne=u([]),J=u({}),w=u(null),p=u(null),K=u(!1),C=u(!1);let x=null;const ie=()=>{D.value=D.value==="dark"?"light":"dark",localStorage.setItem("dmux-theme",D.value),document.documentElement.setAttribute("data-theme",D.value)},se=a=>{S.value.has(a)?S.value.delete(a):S.value.add(a),S.value=new Set(S.value)},le=()=>{B.value=!0,T.value="",b.value=null,L.value=[],z.value=!1,P.value="prompt",I(()=>{const c=document.getElementById("pane-prompt");c&&c.focus()});const a=c=>{c.key==="Escape"&&(R(),document.removeEventListener("keydown",a))};document.addEventListener("keydown",a)},R=()=>{B.value=!1,T.value="",b.value=null,L.value=[],z.value=!1,P.value="prompt"},ee=async()=>{if(!(P.value==="prompt"&&!T.value.trim())&&!(P.value==="agent"&&!b.value))try{H.value=!0;const a={prompt:T.value.trim()};b.value&&(a.agent=b.value);const l=await(await fetch("/api/panes",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(a)})).json();l.needsAgentChoice?(z.value=!0,L.value=l.availableAgents,P.value="agent"):(R(),await _())}catch(a){console.error("Failed to create pane:",a),alert("Failed to create pane")}finally{H.value=!1}},ce=a=>{b.value=a,ee()},_=async()=>{try{const c=await(await fetch("/api/panes")).json();q.value=c.projectName||"dmux",e.value=c.sessionName||"",j.value=!0,V.value=c.panes||[],o.value=new Date,m.value="Just now";for(const l of V.value)J.value[l.id]||te(l.id)}catch(a){console.error("Failed to fetch panes:",a),j.value=!1}},te=async a=>{try{const l=await(await fetch(\`/api/panes/\${a}/actions\`)).json();console.log(\`Fetched actions for pane \${a}:\`,l),J.value[a]=l.actions||[]}catch(c){console.error(\`Failed to fetch actions for pane \${a}:\`,c)}},re=a=>{w.value===a?w.value=null:w.value=a},de=async(a,c)=>{var l;try{K.value=!0,w.value=null;const d=await(await fetch(\`/api/panes/\${a.id}/actions/\${c.id}\`,{method:"POST"})).json();if(d.requiresInteraction){let h={};d.interactionType==="confirm"?h={type:"confirm",title:d.title||"Confirm",message:d.message,...d.confirmData}:d.interactionType==="choice"?h={type:"choice",title:d.title||"Choose",message:d.message,...d.choiceData}:d.interactionType==="input"&&(h={type:"input",title:d.title||"Input",message:d.message,...d.inputData,inputValue:((l=d.inputData)==null?void 0:l.defaultValue)||""},I(()=>{const G=document.querySelector(".dialog-input");G&&(G.focus(),G.select())})),h.paneId=a.id,p.value=h}else await _()}catch(r){console.error("Failed to execute action:",r),alert("Failed to execute action")}finally{K.value=!1}},F=()=>{p.value=null},ue=async a=>{var c;if(p.value)try{C.value=!0;const r=await(await fetch(\`/api/callbacks/confirm/\${p.value.callbackId}\`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({confirmed:a})})).json();if(r.requiresInteraction){let d={};r.interactionType==="confirm"?d={type:"confirm",title:r.title||"Confirm",message:r.message,...r.confirmData}:r.interactionType==="choice"?d={type:"choice",title:r.title||"Choose",message:r.message,...r.choiceData}:r.interactionType==="input"&&(d={type:"input",title:r.title||"Input",message:r.message,...r.inputData,inputValue:((c=r.inputData)==null?void 0:c.defaultValue)||""},I(()=>{const h=document.querySelector(".dialog-input");h&&(h.focus(),h.select())})),p.value=d}else await _(),F()}catch(l){console.error("Failed to confirm action:",l),alert("Failed to complete action")}finally{C.value=!1}},ge=async a=>{var c;if(p.value)try{C.value=!0;const r=await(await fetch(\`/api/callbacks/choice/\${p.value.callbackId}\`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({optionId:a})})).json();if(r.requiresInteraction){let d={};r.interactionType==="confirm"?d={type:"confirm",title:r.title||"Confirm",message:r.message,...r.confirmData}:r.interactionType==="choice"?d={type:"choice",title:r.title||"Choose",message:r.message,...r.choiceData}:r.interactionType==="input"&&(d={type:"input",title:r.title||"Input",message:r.message,...r.inputData,inputValue:((c=r.inputData)==null?void 0:c.defaultValue)||""},I(()=>{const h=document.querySelector(".dialog-input");h&&(h.focus(),h.select())})),p.value=d}else await _(),F()}catch(l){console.error("Failed to select choice:",l),alert("Failed to complete action")}finally{C.value=!1}},ve=async()=>{var a;if(p.value)try{C.value=!0;const l=await(await fetch(\`/api/callbacks/input/\${p.value.callbackId}\`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({value:p.value.inputValue})})).json();if(l.requiresInteraction){let r={};l.interactionType==="confirm"?r={type:"confirm",title:l.title||"Confirm",message:l.message,...l.confirmData}:l.interactionType==="choice"?r={type:"choice",title:l.title||"Choose",message:l.message,...l.choiceData}:l.interactionType==="input"&&(r={type:"input",title:l.title||"Input",message:l.message,...l.inputData,inputValue:((a=l.inputData)==null?void 0:a.defaultValue)||""},I(()=>{const d=document.querySelector(".dialog-input");d&&(d.focus(),d.select())})),p.value=r}else await _(),F()}catch(c){console.error("Failed to submit input:",c),alert("Failed to complete action")}finally{C.value=!1}},me=async(a,c)=>{try{y.value.add(a.id),y.value=new Set(y.value);const l=c.keys||[c.action];for(const r of l)await fetch(\`/api/keys/\${a.id}\`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({key:r})});setTimeout(()=>{y.value.delete(a.id),y.value=new Set(y.value),_()},1500)}catch(l){console.error("Failed to select option:",l),y.value.delete(a.id),y.value=new Set(y.value)}},pe=async a=>{const c=A.value[a.id];if(!(!c||!c.trim()))try{f.value.add(a.id),f.value=new Set(f.value);for(const l of c)await fetch(\`/api/keys/\${a.id}\`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({key:l})});await fetch(\`/api/keys/\${a.id}\`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({key:"Enter"})}),U.value[a.id]=c.substring(0,50)+(c.length>50?"...":""),A.value[a.id]="",setTimeout(()=>{delete U.value[a.id],f.value.delete(a.id),f.value=new Set(f.value)},3e3)}catch(l){console.error("Failed to send prompt:",l),f.value.delete(a.id),f.value=new Set(f.value)}},he=a=>{const c=a.target;c.style.height="auto",c.style.height=c.scrollHeight+"px"},Q=()=>{_(),x=setInterval(_,2e3)},W=()=>{x&&(clearInterval(x),x=null)},Z=a=>{const c=a.target;w.value&&!c.closest(".action-menu-btn")&&!c.closest(".action-menu-dropdown")&&(w.value=null)};ye(()=>{document.documentElement.setAttribute("data-theme",D.value),Q(),document.addEventListener("click",Z),document.addEventListener("visibilitychange",()=>{document.hidden?W():Q()})}),ke(()=>{W(),document.removeEventListener("click",Z)});const oe={projectName:q,sessionName:e,connected:j,panes:V,lastUpdate:o,timeSinceUpdate:m,promptInputs:A,sendingPrompts:f,queuedMessages:U,theme:D,expandedPrompts:S,loadingOptions:y,showCreateDialog:B,newPanePrompt:T,newPaneAgent:b,creatingPane:H,availableAgents:L,needsAgentChoice:z,createStep:P,actions:ne,paneActions:J,showActionMenu:w,actionDialog:p,executingAction:K,actionDialogLoading:C,get refreshInterval(){return x},set refreshInterval(a){x=a},toggleTheme:ie,togglePrompt:se,openCreateDialog:le,closeCreateDialog:R,createPane:ee,selectAgent:ce,fetchPanes:_,fetchPaneActions:te,toggleActionMenu:re,executeAction:de,closeActionDialog:F,confirmAction:ue,selectChoice:ge,submitInput:ve,selectOption:me,sendPrompt:pe,autoExpand:he,startAutoRefresh:Q,stopAutoRefresh:W,handleClickOutside:Z};return Object.defineProperty(oe,"__isScriptSetup",{enumerable:!1,value:!0}),oe}}),De={class:"session-info"},Se=["title"],Pe={key:0,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24"},xe={key:1,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24"},Ae={key:0},Te={class:"container"},Ie={class:"actions-bar"},Me=["disabled"],Ne={key:0,class:"no-panes"},Oe={key:1,class:"panes-grid"},je={class:"pane-header"},Ve={class:"pane-header-content"},Le=["href"],ze={class:"pane-title"},Fe={class:"pane-meta"},Ee={class:"pane-id"},qe=["onClick"],Ue={key:0,class:"action-menu-dropdown"},Be=["onClick","disabled"],He={class:"action-icon"},Je={class:"action-label"},Ke={class:"pane-prompt-section"},Re=["onClick"],Qe={class:"expand-icon"},We={key:0,class:"pane-prompt"},Ze={key:1,class:"agent-summary"},Ge={key:0,class:"options-dialog"},Xe={class:"options-question"},Ye={key:0,class:"options-warning"},$e={key:1,class:"analyzing-state"},et={key:2,class:"options-buttons"},tt=["onClick","disabled"],ot={class:"prompt-input-wrapper"},at=["onUpdate:modelValue","placeholder","disabled"],nt=["onClick","disabled","title"],it={key:0,class:"button-loader"},st={key:1,xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 988.44 1200.05"},lt={key:0,class:"queued-message"},ct={key:2,class:"dev-server-status"},rt=["href"],dt={class:"action-dialog"},ut={key:0},gt=["onKeydown"],vt={class:"dialog-buttons"},mt=["disabled"],pt={key:1},ht={class:"agent-choices"},ft=["onClick","disabled"],yt={key:0,class:"action-dialog"},kt={key:0,class:"dialog-loading"},_t={key:1,class:"dialog-buttons"},bt=["disabled"],wt=["disabled"],Ct={class:"action-dialog"},Dt={key:0},St={key:1,class:"dialog-loading"},Pt={key:2},xt={class:"choice-options"},At=["onClick","disabled"],Tt={class:"choice-label"},It={key:0,class:"choice-description"},Mt={class:"dialog-buttons"},Nt=["disabled"],Ot={class:"action-dialog"},jt={key:0},Vt={key:1,class:"dialog-loading"},Lt={key:2},zt=["placeholder"],Ft={class:"dialog-buttons"},Et=["disabled"],qt=["disabled"];function Ut(ae,n,q,e,j,V){return s(),i(k,null,[t("header",null,[n[7]||(n[7]=t("img",{src:"https://cdn.formk.it/dmux/dmux.png",alt:"dmux",class:"logo"},null,-1)),t("h1",null,g(e.projectName),1),t("div",De,[t("button",{onClick:e.toggleTheme,class:"theme-toggle",title:e.theme==="dark"?"Switch to light mode":"Switch to dark mode"},[e.theme==="dark"?(s(),i("svg",Pe,[...n[5]||(n[5]=[t("path",{d:"M12 2.25a.75.75 0 01.75.75v2.25a.75.75 0 01-1.5 0V3a.75.75 0 01.75-.75zM7.5 12a4.5 4.5 0 119 0 4.5 4.5 0 01-9 0zM18.894 6.166a.75.75 0 00-1.06-1.06l-1.591 1.59a.75.75 0 101.06 1.061l1.591-1.59zM21.75 12a.75.75 0 01-.75.75h-2.25a.75.75 0 010-1.5H21a.75.75 0 01.75.75zM17.834 18.894a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 10-1.061 1.06l1.59 1.591zM12 18a.75.75 0 01.75.75V21a.75.75 0 01-1.5 0v-2.25A.75.75 0 0112 18zM7.758 17.303a.75.75 0 00-1.061-1.06l-1.591 1.59a.75.75 0 001.06 1.061l1.591-1.59zM6 12a.75.75 0 01-.75.75H3a.75.75 0 010-1.5h2.25A.75.75 0 016 12zM6.697 7.757a.75.75 0 001.06-1.06l-1.59-1.591a.75.75 0 00-1.061 1.06l1.59 1.591z"},null,-1)])])):(s(),i("svg",xe,[...n[6]||(n[6]=[t("path",{d:"M9.528 1.718a.75.75 0 01.162.819A8.97 8.97 0 009 6.5a9 9 0 009 9 8.97 8.97 0 003.963-.69.75.75 0 01.981.98 10.503 10.503 0 01-9.694 6.46c-5.799 0-10.5-4.701-10.5-10.5 0-4.368 2.667-8.112 6.46-9.694a.75.75 0 01.818.162z"},null,-1)])]))],8,Se),e.sessionName?(s(),i("span",Ae,g(e.sessionName),1)):v("v-if",!0),t("span",{class:"status-indicator",style:be({color:e.connected?"#4ade80":"#f87171"})},"●",4)])]),t("div",Te,[t("main",null,[t("div",Ie,[t("button",{onClick:e.openCreateDialog,class:"create-pane-button",disabled:e.creatingPane},[...n[8]||(n[8]=[t("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 24 24",fill:"currentColor"},[t("path",{d:"M12 4.5v15m7.5-7.5h-15",stroke:"currentColor","stroke-width":"2","stroke-linecap":"round","stroke-linejoin":"round"})],-1),E(" Create New Pane ",-1)])],8,Me)]),e.panes.length===0?(s(),i("div",Ne,[...n[9]||(n[9]=[t("p",null,"No dmux panes active",-1),t("p",{class:"hint"},\`Click "Create New Pane" above or press 'n' in dmux\`,-1)])])):(s(),i("div",Oe,[(s(!0),i(k,null,M(e.panes,o=>(s(),i("div",{key:o.id,class:"pane-card"},[t("div",je,[t("div",Ve,[t("a",{href:"/panes/"+o.id,class:"pane-title-link"},[t("span",ze,g(o.slug),1),n[10]||(n[10]=t("span",{class:"pane-arrow"},"→",-1))],8,Le),t("div",Fe,[t("span",{class:O(["pane-agent",o.agent||""])},g(o.agent||"unknown"),3),t("span",Ee,g(o.paneId),1)])]),t("button",{onClick:m=>e.toggleActionMenu(o.id),class:"action-menu-btn",title:"Actions"},[...n[11]||(n[11]=[t("span",null,"⋮",-1)])],8,qe)]),v(" Action Menu Dropdown "),e.showActionMenu===o.id&&e.paneActions[o.id]?(s(),i("div",Ue,[(s(!0),i(k,null,M(e.paneActions[o.id],m=>(s(),i("button",{key:m.id,onClick:A=>e.executeAction(o,m),class:"action-menu-item",disabled:e.executingAction},[t("span",He,g(m.icon||"•"),1),t("span",Je,g(m.label),1)],8,Be))),128))])):v("v-if",!0),t("div",Ke,[t("div",{class:O(["pane-prompt-header",{expanded:e.expandedPrompts.has(o.id)}]),onClick:m=>e.togglePrompt(o.id)},[n[12]||(n[12]=t("span",{class:"prompt-label"},"Initial Prompt",-1)),t("span",Qe,g(e.expandedPrompts.has(o.id)?"▼":"▶"),1)],10,Re),e.expandedPrompts.has(o.id)?(s(),i("div",We,g(o.prompt||"No prompt"),1)):v("v-if",!0)]),v(" Show agent summary when idle "),o.agentStatus==="idle"&&o.agentSummary?(s(),i("div",Ze,g(o.agentSummary),1)):v("v-if",!0),t("div",{class:"pane-interactive",onClick:n[0]||(n[0]=N(()=>{},["prevent"]))},[v(" Options Dialog (when waiting with options) "),o.agentStatus==="waiting"&&o.options&&o.options.length>0?(s(),i("div",Ge,[t("div",Xe,g(o.optionsQuestion||"Choose an option:"),1),o.potentialHarm&&o.potentialHarm.hasRisk?(s(),i("div",Ye," ⚠️ "+g(o.potentialHarm.description),1)):v("v-if",!0),e.loadingOptions.has(o.id)?(s(),i("div",$e,[...n[13]||(n[13]=[t("div",{class:"loader-spinner"},null,-1),t("span",null,"Processing selection...",-1)])])):(s(),i("div",et,[(s(!0),i(k,null,M(o.options,m=>(s(),i("button",{key:m.action,onClick:A=>e.selectOption(o,m),class:O(["option-button",{"option-button-danger":o.potentialHarm&&o.potentialHarm.hasRisk}]),disabled:e.loadingOptions.has(o.id)},g(m.action),11,tt))),128))]))])):o.agentStatus==="analyzing"?(s(),i(k,{key:1},[v(" Analyzing (show loader) "),n[14]||(n[14]=t("div",{class:"analyzing-state"},[t("div",{class:"loader-spinner"}),t("span",null,"Analyzing...")],-1))],2112)):(s(),i(k,{key:2},[v(" Working/Idle (show prompt input) "),t("div",null,[t("div",ot,[X(t("textarea",{"onUpdate:modelValue":m=>e.promptInputs[o.id]=m,onInput:e.autoExpand,placeholder:o.agentStatus==="working"?"Queue a prompt...":"Send a prompt...",disabled:e.sendingPrompts.has(o.id),class:"prompt-textarea",rows:"1"},null,40,at),[[Y,e.promptInputs[o.id]]]),t("button",{onClick:m=>e.sendPrompt(o),disabled:!e.promptInputs[o.id]||e.sendingPrompts.has(o.id),class:"send-button",title:o.agentStatus==="working"?"Queue prompt":"Send prompt"},[e.sendingPrompts.has(o.id)?(s(),i("span",it)):(s(),i("svg",st,[...n[15]||(n[15]=[t("path",{d:"M425.13,28.37L30.09,423.41C11.19,441.37.34,466.2,0,492.27c-.34,26.07,9.86,51.17,28.29,69.61,18.43,18.45,43.52,28.67,69.59,28.35,26.07-.31,50.91-11.14,68.88-30.02l233.16-233.52v776.64c0,34.56,18.43,66.48,48.36,83.76,29.93,17.28,66.8,17.28,96.72,0,29.93-17.28,48.36-49.21,48.36-83.76V328.85l231.72,231.36c24.63,23.41,59.74,32.18,92.48,23.09,32.74-9.08,58.32-34.68,67.38-67.43,9.05-32.75.25-67.85-23.18-92.46L566.73,28.37C548.63,10.16,524-.04,498.33.05c-.8-.06-1.6-.06-2.4,0-.8-.06-1.6-.06-2.4,0-25.65,0-50.25,10.19-68.4,28.32h0Z"},null,-1)])]))],8,nt)]),e.queuedMessages[o.id]?(s(),i("div",lt," ✓ "+g(e.queuedMessages[o.id]),1)):v("v-if",!0)])],2112))]),o.devStatus&&o.devStatus!=="stopped"?(s(),i("div",ct,[n[16]||(n[16]=t("span",{class:"status-label"},"Dev Server:",-1)),t("span",{class:O(["status-badge",o.devStatus])},g(o.devStatus),3),o.devUrl?(s(),i("a",{key:0,href:o.devUrl,target:"_blank",class:"dev-link"},"↗",8,rt)):v("v-if",!0)])):v("v-if",!0)]))),128))]))]),v(" Create Pane Dialog "),e.showCreateDialog?(s(),i("div",{key:0,class:"action-dialog-overlay",onClick:N(e.closeCreateDialog,["self"])},[t("div",dt,[n[20]||(n[20]=t("h3",null,"Create New Pane",-1)),e.createStep==="prompt"?(s(),i("div",ut,[n[17]||(n[17]=t("label",{for:"pane-prompt"},"Provide an initial prompt for your agent",-1)),X(t("textarea",{id:"pane-prompt","onUpdate:modelValue":n[1]||(n[1]=o=>e.newPanePrompt=o),placeholder:"E.g., Fix the authentication bug, Add dark mode, etc.",rows:"4",onKeydown:[$(N(e.createPane,["meta"]),["enter"]),$(N(e.createPane,["ctrl"]),["enter"])]},null,40,gt),[[Y,e.newPanePrompt]]),n[18]||(n[18]=t("div",{class:"dialog-hint"},[E(" 💡 Press "),t("kbd",null,"⌘ Enter"),E(" or "),t("kbd",null,"Ctrl Enter"),E(" to create ")],-1)),t("div",vt,[t("button",{onClick:e.closeCreateDialog,class:"dialog-btn"},"Cancel"),t("button",{onClick:e.createPane,disabled:!e.newPanePrompt.trim()||e.creatingPane,class:"dialog-btn dialog-btn-primary"},g(e.creatingPane?"Creating...":"Create Pane"),9,mt)])])):e.createStep==="agent"?(s(),i("div",pt,[n[19]||(n[19]=t("p",null,"Multiple agents available. Choose one:",-1)),t("div",ht,[(s(!0),i(k,null,M(e.availableAgents,o=>(s(),i("button",{key:o,onClick:m=>e.selectAgent(o),class:"agent-choice-button",disabled:e.creatingPane},g(o),9,ft))),128))]),t("div",{class:"dialog-buttons"},[t("button",{onClick:e.closeCreateDialog,class:"dialog-btn"},"Cancel")])])):v("v-if",!0)])])):v("v-if",!0),v(" Action Dialogs "),e.actionDialog?(s(),i("div",{key:1,class:"action-dialog-overlay",onClick:N(e.closeActionDialog,["self"])},[v(" Confirm Dialog "),e.actionDialog.type==="confirm"?(s(),i("div",yt,[t("h3",null,g(e.actionDialog.title),1),t("p",null,g(e.actionDialog.message),1),e.actionDialogLoading?(s(),i("div",kt,[...n[21]||(n[21]=[t("div",{class:"loader-spinner"},null,-1),t("span",null,"Processing...",-1)])])):(s(),i("div",_t,[t("button",{onClick:n[2]||(n[2]=o=>e.confirmAction(!1)),class:"dialog-btn",disabled:e.actionDialogLoading},"Cancel",8,bt),t("button",{onClick:n[3]||(n[3]=o=>e.confirmAction(!0)),class:"dialog-btn dialog-btn-primary",disabled:e.actionDialogLoading},"Confirm",8,wt)]))])):e.actionDialog.type==="choice"?(s(),i(k,{key:1},[v(" Choice Dialog "),t("div",Ct,[t("h3",null,g(e.actionDialog.title),1),e.actionDialog.message?(s(),i("p",Dt,g(e.actionDialog.message),1)):v("v-if",!0),e.actionDialogLoading?(s(),i("div",St,[...n[22]||(n[22]=[t("div",{class:"loader-spinner"},null,-1),t("span",null,"Processing...",-1)])])):(s(),i("div",Pt,[t("div",xt,[(s(!0),i(k,null,M(e.actionDialog.options,o=>(s(),i("button",{key:o.id,onClick:m=>e.selectChoice(o.id),class:O(["choice-option-btn",{danger:o.danger}]),disabled:e.actionDialogLoading},[t("div",Tt,g(o.label),1),o.description?(s(),i("div",It,g(o.description),1)):v("v-if",!0)],10,At))),128))]),t("div",Mt,[t("button",{onClick:e.closeActionDialog,class:"dialog-btn",disabled:e.actionDialogLoading},"Cancel",8,Nt)])]))])],2112)):e.actionDialog.type==="input"?(s(),i(k,{key:2},[v(" Input Dialog "),t("div",Ot,[t("h3",null,g(e.actionDialog.title),1),e.actionDialog.message?(s(),i("p",jt,g(e.actionDialog.message),1)):v("v-if",!0),e.actionDialogLoading?(s(),i("div",Vt,[...n[23]||(n[23]=[t("div",{class:"loader-spinner"},null,-1),t("span",null,"Processing...",-1)])])):(s(),i("div",Lt,[X(t("input",{type:"text","onUpdate:modelValue":n[4]||(n[4]=o=>e.actionDialog.inputValue=o),placeholder:e.actionDialog.placeholder,class:"dialog-input",onKeydown:$(e.submitInput,["enter"])},null,40,zt),[[Y,e.actionDialog.inputValue]]),t("div",Ft,[t("button",{onClick:e.closeActionDialog,class:"dialog-btn",disabled:e.actionDialogLoading},"Cancel",8,Et),t("button",{onClick:e.submitInput,class:"dialog-btn dialog-btn-primary",disabled:e.actionDialogLoading},"Submit",8,qt)])]))])],2112)):v("v-if",!0)])):v("v-if",!0)])],64)}const Bt=_e(Ce,[["render",Ut],["__file","/Users/justinschroeder/Projects/dmux/.dmux/worktrees/analyzing-never-stops/frontend/src/components/Dashboard.vue"]]),Ht=we(Bt);Ht.mount("#app");
`,
    mimeType: 'application/javascript',
    size: 19954
  },
  'index.js': {
    content: `#!/usr/bin/env node
import { execSync } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { render } from 'ink';
import React from 'react';
import { createHash } from 'crypto';
import DmuxApp from './DmuxApp.js';
import { AutoUpdater } from './AutoUpdater.js';
import readline from 'readline';
import { DmuxServer } from './server/index.js';
import { StateManager } from './shared/StateManager.js';
const __dirname = path.dirname(fileURLToPath(import.meta.url));
class Dmux {
    panesFile;
    settingsFile;
    projectName;
    sessionName;
    projectRoot;
    autoUpdater;
    server;
    stateManager;
    static cachedProjectRoot = null;
    constructor() {
        // Get git root directory to determine project scope (cached)
        this.projectRoot = this.getProjectRoot();
        // Get project name from git root directory
        this.projectName = path.basename(this.projectRoot);
        // Create a unique identifier for this project based on its full path
        // This ensures different projects with the same folder name are kept separate
        const projectHash = createHash('md5').update(this.projectRoot).digest('hex').substring(0, 8);
        const projectIdentifier = \`\${this.projectName}-\${projectHash}\`;
        // Create unique session name for this project (sanitize for tmux compatibility)
        // tmux converts dots to underscores, so we do it explicitly to avoid mismatches
        const sanitizedProjectIdentifier = projectIdentifier.replace(/\\./g, '-');
        this.sessionName = \`dmux-\${sanitizedProjectIdentifier}\`;
        // Store config in .dmux directory inside project root
        const dmuxDir = path.join(this.projectRoot, '.dmux');
        const configFile = path.join(dmuxDir, 'dmux.config.json');
        // Always use the .dmux directory config location
        this.panesFile = configFile;
        this.settingsFile = configFile; // Same file for all config
        // Initialize auto-updater with config file
        this.autoUpdater = new AutoUpdater(configFile);
        // Initialize server and state manager
        this.server = new DmuxServer();
        this.stateManager = StateManager.getInstance();
    }
    async init() {
        // Set up global signal handlers for clean exit
        this.setupGlobalSignalHandlers();
        // Ensure .dmux directory exists and is in .gitignore
        await this.ensureDmuxDirectory();
        // Check for migration from old config location
        await this.migrateOldConfig();
        // Initialize config file if it doesn't exist
        if (!await this.fileExists(this.panesFile)) {
            const initialConfig = {
                projectName: this.projectName,
                projectRoot: this.projectRoot,
                panes: [],
                settings: {},
                lastUpdated: new Date().toISOString()
            };
            await fs.writeFile(this.panesFile, JSON.stringify(initialConfig, null, 2));
        }
        // Check for updates in background if needed
        this.checkForUpdatesBackground();
        const inTmux = process.env.TMUX !== undefined;
        if (!inTmux) {
            // Check if project-specific session already exists
            try {
                execSync(\`tmux has-session -t \${this.sessionName} 2>/dev/null\`, { stdio: 'pipe' });
                // Session exists, will attach
            }
            catch {
                // Create new session
                // Create new session first
                execSync(\`tmux new-session -d -s \${this.sessionName}\`, { stdio: 'inherit' });
                // Enable pane borders to show titles
                execSync(\`tmux set-option -t \${this.sessionName} pane-border-status top\`, { stdio: 'inherit' });
                // Set pane title for the main dmux pane
                execSync(\`tmux select-pane -t \${this.sessionName} -T "dmux-\${this.projectName}"\`, { stdio: 'inherit' });
                // Send dmux command to the new session
                execSync(\`tmux send-keys -t \${this.sessionName} "dmux" Enter\`, { stdio: 'inherit' });
            }
            execSync(\`tmux attach-session -t \${this.sessionName}\`, { stdio: 'inherit' });
            return;
        }
        // Enable pane borders to show titles
        try {
            execSync(\`tmux set-option pane-border-status top\`, { stdio: 'pipe' });
        }
        catch {
            // Ignore if it fails
        }
        // Set pane title for the current pane running dmux
        try {
            execSync(\`tmux select-pane -T "dmux-\${this.projectName}"\`, { stdio: 'pipe' });
        }
        catch {
            // Ignore if it fails (might not have permission or tmux version doesn't support it)
        }
        // Update state manager with project info
        this.stateManager.updateProjectInfo(this.projectName, this.sessionName, this.projectRoot, this.panesFile);
        // Start the HTTP server
        let serverInfo = { port: 0, url: '' };
        try {
            serverInfo = await this.server.start();
            // Update StateManager with server info
            this.stateManager.updateServerInfo(serverInfo.port, serverInfo.url);
            // Don't log the local URL - tunnel will be created on demand when "r" is pressed
        }
        catch (err) {
            console.error('Failed to start HTTP server:', err);
            // Continue without server - not critical for main functionality
        }
        // Clear screen before launching Ink to prevent artifacts
        process.stdout.write('\\x1b[2J\\x1b[H'); // Clear screen and move cursor to home
        process.stdout.write('\\x1b[3J'); // Clear scrollback buffer
        // Clear tmux history
        try {
            execSync('tmux clear-history', { stdio: 'pipe' });
        }
        catch { }
        // Small delay to let the clear take effect before Ink renders
        await new Promise(resolve => setTimeout(resolve, 50));
        // Launch the Ink app
        const app = render(React.createElement(DmuxApp, {
            panesFile: this.panesFile,
            settingsFile: this.settingsFile,
            projectName: this.projectName,
            sessionName: this.sessionName,
            projectRoot: this.projectRoot,
            autoUpdater: this.autoUpdater,
            serverPort: serverInfo.port,
            server: this.server
        }), {
            exitOnCtrlC: false // Disable automatic exit on Ctrl+C
        });
        // Clean shutdown on app exit
        app.waitUntilExit().then(async () => {
            await this.server.stop();
            process.exit(0);
        });
    }
    async fileExists(path) {
        try {
            await fs.access(path);
            return true;
        }
        catch {
            return false;
        }
    }
    getProjectRoot() {
        // Return cached value if available
        if (Dmux.cachedProjectRoot) {
            return Dmux.cachedProjectRoot;
        }
        try {
            // First, try to get the main worktree if we're in a git repository
            // This ensures we always use the main repository root, even when run from a worktree
            const worktreeList = execSync('git worktree list --porcelain', {
                encoding: 'utf-8',
                stdio: 'pipe'
            }).trim();
            // The first line contains the main worktree path
            const mainWorktreeLine = worktreeList.split('\\n')[0];
            if (mainWorktreeLine && mainWorktreeLine.startsWith('worktree ')) {
                const mainWorktreePath = mainWorktreeLine.substring(9).trim();
                Dmux.cachedProjectRoot = mainWorktreePath;
                return mainWorktreePath;
            }
            // Fallback to git rev-parse if worktree list fails
            const gitRoot = execSync('git rev-parse --show-toplevel', {
                encoding: 'utf-8',
                stdio: 'pipe'
            }).trim();
            Dmux.cachedProjectRoot = gitRoot;
            return gitRoot;
        }
        catch {
            // Fallback to current directory if not in a git repo
            const cwd = process.cwd();
            Dmux.cachedProjectRoot = cwd;
            return cwd;
        }
    }
    async ensureDmuxDirectory() {
        const dmuxDir = path.join(this.projectRoot, '.dmux');
        const worktreesDir = path.join(dmuxDir, 'worktrees');
        // Create .dmux directory if it doesn't exist
        if (!await this.fileExists(dmuxDir)) {
            await fs.mkdir(dmuxDir, { recursive: true });
        }
        // Create worktrees directory if it doesn't exist
        if (!await this.fileExists(worktreesDir)) {
            await fs.mkdir(worktreesDir, { recursive: true });
        }
        // Check if .gitignore exists and if .dmux is in it
        const gitignorePath = path.join(this.projectRoot, '.gitignore');
        if (await this.fileExists(gitignorePath)) {
            const gitignoreContent = await fs.readFile(gitignorePath, 'utf-8');
            const lines = gitignoreContent.split('\\n');
            const hasDmuxEntry = lines.some(line => line.trim() === '.dmux' ||
                line.trim() === '.dmux/' ||
                line.trim() === '/.dmux' ||
                line.trim() === '/.dmux/');
            if (!hasDmuxEntry) {
                // Prompt user to add .dmux to .gitignore
                const shouldAdd = await this.promptUser('The .dmux directory is not in .gitignore. Would you like to add it? (y/n): ');
                if (shouldAdd) {
                    // Add .dmux to .gitignore
                    const newGitignore = gitignoreContent.endsWith('\\n')
                        ? gitignoreContent + '.dmux/\\n'
                        : gitignoreContent + '\\n.dmux/\\n';
                    await fs.writeFile(gitignorePath, newGitignore);
                }
            }
        }
        else {
            // No .gitignore exists, prompt to create one
            const shouldCreate = await this.promptUser('No .gitignore file found. Would you like to create one with .dmux/ entry? (y/n): ');
            if (shouldCreate) {
                await fs.writeFile(gitignorePath, '.dmux/\\n');
            }
        }
    }
    async promptUser(question) {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout
        });
        return new Promise((resolve) => {
            rl.question(question, (answer) => {
                rl.close();
                resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
            });
        });
    }
    async migrateOldConfig() {
        // Check if we're using the new config location
        const dmuxDir = path.join(this.projectRoot, '.dmux');
        const newConfigFile = path.join(dmuxDir, 'dmux.config.json');
        const oldParentConfigFile = path.join(path.dirname(this.projectRoot), 'dmux.config.json');
        const homeDmuxDir = path.join(process.env.HOME, '.dmux');
        if (this.panesFile === newConfigFile && !await this.fileExists(newConfigFile)) {
            // Look for old config files to migrate
            const projectHash = createHash('md5').update(this.projectRoot).digest('hex').substring(0, 8);
            const projectIdentifier = \`\${this.projectName}-\${projectHash}\`;
            const oldPanesFile = path.join(homeDmuxDir, \`\${projectIdentifier}-panes.json\`);
            const oldSettingsFile = path.join(homeDmuxDir, \`\${projectIdentifier}-settings.json\`);
            const oldUpdateSettingsFile = path.join(homeDmuxDir, 'update-settings.json');
            let panes = [];
            let settings = {};
            let updateSettings = {};
            // Try to read old panes file
            if (await this.fileExists(oldPanesFile)) {
                try {
                    const oldPanesContent = await fs.readFile(oldPanesFile, 'utf-8');
                    panes = JSON.parse(oldPanesContent);
                }
                catch { }
            }
            // Try to read old settings file
            if (await this.fileExists(oldSettingsFile)) {
                try {
                    const oldSettingsContent = await fs.readFile(oldSettingsFile, 'utf-8');
                    settings = JSON.parse(oldSettingsContent);
                }
                catch { }
            }
            // Try to read old update settings file
            if (await this.fileExists(oldUpdateSettingsFile)) {
                try {
                    const oldUpdateContent = await fs.readFile(oldUpdateSettingsFile, 'utf-8');
                    updateSettings = JSON.parse(oldUpdateContent);
                }
                catch { }
            }
            // Check for config from previous parent directory location
            if (await this.fileExists(oldParentConfigFile)) {
                try {
                    const oldConfig = JSON.parse(await fs.readFile(oldParentConfigFile, 'utf-8'));
                    if (oldConfig.panes)
                        panes = oldConfig.panes;
                    if (oldConfig.settings)
                        settings = oldConfig.settings;
                    if (oldConfig.updateSettings)
                        updateSettings = oldConfig.updateSettings;
                }
                catch { }
            }
            // If we found old config, migrate it
            if (panes.length > 0 || Object.keys(settings).length > 0 || Object.keys(updateSettings).length > 0) {
                const migratedConfig = {
                    projectName: this.projectName,
                    projectRoot: this.projectRoot,
                    panes: panes,
                    settings: settings,
                    updateSettings: updateSettings,
                    lastUpdated: new Date().toISOString(),
                    migratedFrom: 'dmux-legacy'
                };
                await fs.writeFile(newConfigFile, JSON.stringify(migratedConfig, null, 2));
                // Clean up old files after successful migration
                try {
                    await fs.unlink(oldPanesFile);
                }
                catch { }
                try {
                    await fs.unlink(oldSettingsFile);
                }
                catch { }
                try {
                    await fs.unlink(oldUpdateSettingsFile);
                }
                catch { }
                try {
                    await fs.unlink(oldParentConfigFile);
                }
                catch { }
            }
        }
    }
    checkForUpdatesBackground() {
        // Run update check in background without blocking startup
        setImmediate(async () => {
            try {
                const shouldCheck = await this.autoUpdater.shouldCheckForUpdates();
                if (shouldCheck) {
                    // Check for updates asynchronously
                    this.autoUpdater.checkForUpdates().catch(() => {
                        // Silently ignore update check failures
                    });
                }
            }
            catch {
                // Silently ignore errors in background update check
            }
        });
    }
    async getUpdateInfo() {
        return await this.autoUpdater.checkForUpdates();
    }
    async performUpdate() {
        const updateInfo = await this.autoUpdater.checkForUpdates();
        return await this.autoUpdater.performUpdate(updateInfo);
    }
    async skipUpdate(version) {
        return await this.autoUpdater.skipVersion(version);
    }
    getAutoUpdater() {
        return this.autoUpdater;
    }
    setupGlobalSignalHandlers() {
        const cleanTerminalExit = () => {
            // Clear screen multiple times to ensure no artifacts
            process.stdout.write('\\x1b[2J\\x1b[H'); // Clear screen and move to home
            process.stdout.write('\\x1b[3J'); // Clear scrollback buffer
            process.stdout.write('\\n'.repeat(100)); // Push any remaining content off screen
            // Clear tmux pane if we're in tmux
            if (process.env.TMUX) {
                try {
                    execSync('tmux clear-history', { stdio: 'pipe' });
                    execSync('tmux send-keys C-l', { stdio: 'pipe' });
                }
                catch { }
            }
            // Wait a moment for clearing to settle, then show goodbye message
            setTimeout(() => {
                process.stdout.write('\\x1b[2J\\x1b[H');
                process.stdout.write('\\n\\n  dmux session ended.\\n\\n');
                process.exit(0);
            }, 100);
        };
        // Handle Ctrl+C and SIGTERM
        process.on('SIGINT', cleanTerminalExit);
        process.on('SIGTERM', cleanTerminalExit);
        // Handle uncaught exceptions and unhandled rejections
        process.on('uncaughtException', (error) => {
            console.error('Uncaught exception:', error);
            cleanTerminalExit();
        });
        process.on('unhandledRejection', (reason) => {
            console.error('Unhandled rejection:', reason);
            cleanTerminalExit();
        });
    }
}
const dmux = new Dmux();
dmux.init().catch(() => process.exit(1));
//# sourceMappingURL=index.js.map`,
    mimeType: 'application/javascript',
    size: 17288
  },
  'terminal.html': {
    content: `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Terminal Viewer - dmux</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <script type="module" crossorigin src="/terminal.js"></script>
  <link rel="modulepreload" crossorigin href="/chunks/_plugin-vue_export-helper-Cvoq67hi.js">
  <link rel="stylesheet" crossorigin href="/_plugin-vue_export-helper.css">
</head>
<body>
  <div id="app"></div>
</body>
</html>
`,
    mimeType: 'text/html',
    size: 738
  },
  'terminal.js': {
    content: `import{d as ue,r as g,p as de,o as ce,n as he,_ as ge,c as x,k as R,b as c,e as N,i as ve,t as j,f as $,l as O,v as be,F as me,h as ye,m as pe}from"./chunks/_plugin-vue_export-helper-Cvoq67hi.js";const ke=ue({__name:"Terminal",setup(ee,{expose:u}){u();const k=window.location.pathname.split("/").pop()||"",n=g([]),s=g({width:80,height:24}),w=g(!1),i=g(0),o=g(0),V=g("Loading..."),P=g(!1),b=g(!1),m=g(!1),C=g(!1),M=g(""),D=g(null),A=g("");let r={};const K=["#000000","#800000","#008000","#808000","#000080","#800080","#008080","#c0c0c0","#808080","#ff0000","#00ff00","#ffff00","#0000ff","#ff00ff","#00ffff","#ffffff","#000000","#00005f","#000087","#0000af","#0000d7","#0000ff","#005f00","#005f5f","#005f87","#005faf","#005fd7","#005fff","#008700","#00875f","#008787","#0087af","#0087d7","#0087ff","#00af00","#00af5f","#00af87","#00afaf","#00afd7","#00afff","#00d700","#00d75f","#00d787","#00d7af","#00d7d7","#00d7ff","#00ff00","#00ff5f","#00ff87","#00ffaf","#00ffd7","#00ffff","#5f0000","#5f005f","#5f0087","#5f00af","#5f00d7","#5f00ff","#5f5f00","#5f5f5f","#5f5f87","#5f5faf","#5f5fd7","#5f5fff","#5f8700","#5f875f","#5f8787","#5f87af","#5f87d7","#5f87ff","#5faf00","#5faf5f","#5faf87","#5fafaf","#5fafd7","#5fafff","#5fd700","#5fd75f","#5fd787","#5fd7af","#5fd7d7","#5fd7ff","#5fff00","#5fff5f","#5fff87","#5fffaf","#5fffd7","#5fffff","#870000","#87005f","#870087","#8700af","#8700d7","#8700ff","#875f00","#875f5f","#875f87","#875faf","#875fd7","#875fff","#878700","#87875f","#878787","#8787af","#8787d7","#8787ff","#87af00","#87af5f","#87af87","#87afaf","#87afd7","#87afff","#87d700","#87d75f","#87d787","#87d7af","#87d7d7","#87d7ff","#87ff00","#87ff5f","#87ff87","#87ffaf","#87ffd7","#87ffff","#af0000","#af005f","#af0087","#af00af","#af00d7","#af00ff","#af5f00","#af5f5f","#af5f87","#af5faf","#af5fd7","#af5fff","#af8700","#af875f","#af8787","#af87af","#af87d7","#af87ff","#afaf00","#afaf5f","#afaf87","#afafaf","#afafd7","#afafff","#afd700","#afd75f","#afd787","#afd7af","#afd7d7","#afd7ff","#afff00","#afff5f","#afff87","#afffaf","#afffd7","#afffff","#d70000","#d7005f","#d70087","#d700af","#d700d7","#d700ff","#d75f00","#d75f5f","#d75f87","#d75faf","#d75fd7","#d75fff","#d78700","#d7875f","#d78787","#d787af","#d787d7","#d787ff","#d7af00","#d7af5f","#d7af87","#d7afaf","#d7afd7","#d7afff","#d7d700","#d7d75f","#d7d787","#d7d7af","#d7d7d7","#d7d7ff","#d7ff00","#d7ff5f","#d7ff87","#d7ffaf","#d7ffd7","#d7ffff","#ff0000","#ff005f","#ff0087","#ff00af","#ff00d7","#ff00ff","#ff5f00","#ff5f5f","#ff5f87","#ff5faf","#ff5fd7","#ff5fff","#ff8700","#ff875f","#ff8787","#ff87af","#ff87d7","#ff87ff","#ffaf00","#ffaf5f","#ffaf87","#ffafaf","#ffafd7","#ffafff","#ffd700","#ffd75f","#ffd787","#ffd7af","#ffd7d7","#ffd7ff","#ffff00","#ffff5f","#ffff87","#ffffaf","#ffffd7","#ffffff","#080808","#121212","#1c1c1c","#262626","#303030","#3a3a3a","#444444","#4e4e4e","#585858","#626262","#6c6c6c","#767676","#808080","#8a8a8a","#949494","#9e9e9e","#a8a8a8","#b2b2b2","#bcbcbc","#c6c6c6","#d0d0d0","#dadada","#e4e4e4","#eeeeee"];function T(){n.value=Array(s.value.height).fill(null).map(()=>Array(s.value.width).fill(null).map(()=>({char:" ",fg:null,bg:null,bold:!1,dim:!1,italic:!1,underline:!1,strikethrough:!1})))}function E(e,f=!1,a=!0){let t=0;for(;t<e.length;){const l=e.charCodeAt(t);if(l===27){const d=H(e,t);if(d>t){const p=e.substring(t,d);L(p),t=d;continue}}if(l===8){o.value>0&&o.value--,t++;continue}U(e[t],a),t++}}function H(e,f){if(f+1>=e.length)return f+1;const a=e[f+1];if(a==="[")for(let t=f+2;t<e.length;t++){const l=e[t];if(l>="@"&&l<="~")return t+1}if(a==="]")for(let t=f+2;t<e.length;t++){const l=e.charCodeAt(t);if(l===7)return t+1;if(l===27&&t+1<e.length&&e[t+1]==="\\\\")return t+2}return f+2}function L(e){if(!(e.length<2)&&e[1]==="["){const f=e.substring(2,e.length-1),a=e[e.length-1];W(f,a)}}function W(e,f){const a=e.split(";").map(t=>parseInt(t)||0);switch(f){case"H":case"f":i.value=Math.min(Math.max((a[0]||1)-1,0),s.value.height-1),o.value=Math.min(Math.max((a[1]||1)-1,0),s.value.width-1);break;case"A":i.value=Math.max(i.value-(a[0]||1),0);break;case"B":i.value=Math.min(i.value+(a[0]||1),s.value.height-1);break;case"C":o.value=Math.min(o.value+(a[0]||1),s.value.width-1);break;case"D":o.value=Math.max(o.value-(a[0]||1),0);break;case"G":o.value=Math.min(Math.max((a[0]||1)-1,0),s.value.width-1);break;case"J":J(a[0]||0);break;case"K":F(a[0]||0);break;case"m":z(a);break}}function z(e){if(e.length===0||e[0]===0){r={};return}let f=0;for(;f<e.length;){const a=e[f];a===0?r={}:a===1?r.bold=!0:a===2?r.dim=!0:a===3?r.italic=!0:a===4?r.underline=!0:a===9?r.strikethrough=!0:a===22?(r.bold=!1,r.dim=!1):a===23?r.italic=!1:a===24?r.underline=!1:a===29?r.strikethrough=!1:a>=30&&a<=37?r.fg=["black","red","green","yellow","blue","magenta","cyan","white"][a-30]:a===38?f+1<e.length&&(e[f+1]===5&&f+2<e.length?(r.fg="c"+e[f+2],f+=2):e[f+1]===2&&f+4<e.length&&(r.fg=\`rgb(\${e[f+2]},\${e[f+3]},\${e[f+4]})\`,f+=4)):a===39?r.fg=null:a>=40&&a<=47?r.bg=["black","red","green","yellow","blue","magenta","cyan","white"][a-40]:a===48?f+1<e.length&&(e[f+1]===5&&f+2<e.length?(r.bg="c"+e[f+2],f+=2):e[f+1]===2&&f+4<e.length&&(r.bg=\`rgb(\${e[f+2]},\${e[f+3]},\${e[f+4]})\`,f+=4)):a===49?r.bg=null:a>=90&&a<=97?r.fg="bright-"+["black","red","green","yellow","blue","magenta","cyan","white"][a-90]:a>=100&&a<=107&&(r.bg="bright-"+["black","red","green","yellow","blue","magenta","cyan","white"][a-100]),f++}}function U(e,f=!0){if(e===\`
\`){i.value++,o.value=0,i.value>=s.value.height&&(f&&(n.value.shift(),n.value.push(Array(s.value.width).fill(null).map(()=>({char:" ",fg:null,bg:null,bold:!1,dim:!1,italic:!1,underline:!1,strikethrough:!1})))),i.value=s.value.height-1);return}if(e==="\\r"){o.value=0;return}if(e==="	"){o.value=Math.min(Math.floor((o.value+8)/8)*8,s.value.width-1);return}o.value>=s.value.width&&(o.value=0,i.value++,i.value>=s.value.height&&(f&&(n.value.shift(),n.value.push(Array(s.value.width).fill(null).map(()=>({char:" ",fg:null,bg:null,bold:!1,dim:!1,italic:!1,underline:!1,strikethrough:!1})))),i.value=s.value.height-1)),i.value<s.value.height&&o.value<s.value.width&&(n.value[i.value][o.value]={char:e,...r},o.value++)}function J(e){e===2&&T()}function F(e){if(e===0)for(let f=o.value;f<s.value.width;f++)n.value[i.value][f]={char:" ",fg:null,bg:null,bold:!1,dim:!1,italic:!1,underline:!1,strikethrough:!1};else if(e===2)for(let f=0;f<s.value.width;f++)n.value[i.value][f]={char:" ",fg:null,bg:null,bold:!1,dim:!1,italic:!1,underline:!1,strikethrough:!1}}function _(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")}function G(e,f){return e.fg===f.fg&&e.bg===f.bg&&e.bold===f.bold&&e.dim===f.dim&&e.italic===f.italic&&e.underline===f.underline&&e.strikethrough===f.strikethrough}function X(e){const f=[],a=[];if(e.fg)if(e.fg.startsWith("rgb("))a.push(\`color: \${e.fg}\`);else if(e.fg.startsWith("c")){const t=parseInt(e.fg.substring(1));t>=0&&t<K.length&&a.push(\`color: \${K[t]}\`)}else f.push("term-fg-"+e.fg);if(e.bg)if(e.bg.startsWith("rgb("))a.push(\`background-color: \${e.bg}\`);else if(e.bg.startsWith("c")){const t=parseInt(e.bg.substring(1));t>=0&&t<K.length&&a.push(\`background-color: \${K[t]}\`)}else f.push("term-bg-"+e.bg);return e.bold&&f.push("term-bold"),e.dim&&f.push("term-dim"),e.italic&&f.push("term-italic"),e.underline&&f.push("term-underline"),e.strikethrough&&f.push("term-strikethrough"),{classes:f,styles:a}}function B(){const f=\`/api/stream/\${A.value||k}\`;fetch(f).then(a=>{if(!a.ok)throw new Error("Failed to connect");if(!a.body)throw new Error("No response body");const t=a.body.getReader(),l=new TextDecoder;let d="";w.value=!0,(async()=>{try{for(;;){const{done:v,value:h}=await t.read();if(v)break;d+=l.decode(h,{stream:!0});let y;for(;(y=d.indexOf(\`
\`))!==-1;){const I=d.substring(0,y);d=d.substring(y+1),I&&Z(I)}}}catch{w.value=!1}})()}).catch(a=>{w.value=!1})}function Z(e){const f=e.indexOf(":");if(f===-1)return;const a=e.substring(0,f),t=e.substring(f+1);try{const l=JSON.parse(t);switch(a){case"INIT":s.value={width:l.width,height:l.height},T(),i.value=0,o.value=0,E(l.content||"",!1,!1),l.cursorRow!==void 0&&l.cursorCol!==void 0&&(i.value=l.cursorRow,o.value=l.cursorCol);break;case"PATCH":const d=l.cursorRow,p=l.cursorCol;l.changes.forEach(v=>{E(v.text,!1,!1)}),d!==void 0&&p!==void 0&&(i.value=d,o.value=p);break;case"RESIZE":s.value={width:l.width,height:l.height},T(),E(l.content||"");break;case"HEARTBEAT":break}}catch{}}const fe=de(()=>({width:\`\${s.value.width}ch\`,maxWidth:"100vw",fontSize:\`clamp(11px, calc(100vw / \${s.value.width} / 0.6), 20px)\`}));function ae(e,f){let a="",t=0;for(;t<e.length;){const l=e[t],d=f===i.value&&t===o.value;if(l.fg||l.bg||l.bold||l.dim||l.italic||l.underline||l.strikethrough||d){const{classes:v,styles:h}=X(l);d&&v.push("term-cursor");let y=l.char;for(t++;t<e.length;){const Y=e[t];if(f===i.value&&t===o.value||!G(l,Y))break;y+=Y.char,t++}const I=v.length?' class="'+v.join(" ")+'"':"",re=h.length?' style="'+h.join("; ")+'"':"";a+="<span"+I+re+">"+_(y)+"</span>"}else{let v="";for(;t<e.length;){const h=e[t],y=f===i.value&&t===o.value;if(h.fg||h.bg||h.bold||h.dim||h.italic||h.underline||h.strikethrough||y)break;v+=h.char,t++}a+=_(v)}}return a}function te(){b.value=!b.value,b.value&&m.value&&(m.value=!1)}function le(){m.value=!m.value,m.value&&b.value&&(b.value=!1)}function ne(){C.value=!C.value}async function S(e){const f={key:e,ctrlKey:b.value,altKey:m.value,shiftKey:C.value,metaKey:!1};b.value=!1,m.value=!1,C.value=!1;try{await fetch(\`/api/keys/\${A.value}\`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(f)})}catch{}}function ie(){P.value&&D.value&&D.value.focus()}function oe(e){const a=e.target.value,t=M.value;if(a.length>t.length){const l=a.substring(t.length);for(const d of l)S(d)}else if(a.length<t.length){const l=t.length-a.length;for(let d=0;d<l;d++)S("Backspace")}he(()=>{M.value=""})}function se(e){e.key==="Enter"?(e.preventDefault(),S("Enter")):e.key==="Backspace"&&M.value===""&&(e.preventDefault(),S("Backspace"))}function q(e){const f=document.activeElement;if(f&&(f.tagName==="INPUT"||f.tagName==="TEXTAREA")||["Shift","Control","Alt","Meta"].includes(e.key))return;(!e.metaKey&&!e.ctrlKey||e.key==="c"||e.key==="d")&&e.preventDefault();const t={key:e.key,ctrlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey,metaKey:e.metaKey};fetch(\`/api/keys/\${A.value}\`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)}).catch(l=>{})}ce(()=>{P.value="ontouchstart"in window||navigator.maxTouchPoints>0||window.innerWidth<768,fetch("/api/panes").then(e=>e.json()).then(e=>{let f=e.panes.find(a=>a.id===k);f||(f=e.panes.find(a=>a.slug===k)),f&&(V.value=f.slug,A.value=f.id),B()}).catch(e=>{B()}),document.addEventListener("keydown",q)});const Q={paneId:k,terminalBuffer:n,dimensions:s,connected:w,cursorRow:i,cursorCol:o,paneTitle:V,isMobile:P,ctrlActive:b,altActive:m,shiftActive:C,mobileInputValue:M,mobileInputRef:D,actualPaneId:A,get currentAttrs(){return r},set currentAttrs(e){r=e},colorPalette:K,initTerminal:T,parseAnsiAndUpdate:E,findEscapeSequenceEnd:H,handleEscapeSequence:L,handleCSI:W,handleSGR:z,handleCharacter:U,handleEraseDisplay:J,handleEraseLine:F,escapeHtml:_,hasSameStyle:G,buildStyleAttrs:X,connectToStream:B,processMessage:Z,terminalContainerStyle:fe,renderRow:ae,toggleCtrl:te,toggleAlt:le,toggleShift:ne,sendKey:S,focusMobileInput:ie,handleMobileInput:oe,handleMobileKeydown:se,handleGlobalKeydown:q};return Object.defineProperty(Q,"__isScriptSetup",{enumerable:!1,value:!0}),Q}}),we={class:"terminal-page"},Ce={class:"session-info"},Ae={class:"mobile-toolbar"},Ke=["data-row","innerHTML"];function Se(ee,u,k,n,s,w){return R(),x("div",we,[c("header",null,[u[8]||(u[8]=c("a",{href:"/",class:"back-button"},"← dmux",-1)),c("h1",null,j(n.paneTitle),1),c("div",Ce,[c("span",null,j(n.dimensions.width)+"×"+j(n.dimensions.height),1),c("span",{class:"status-indicator",style:$({color:n.connected?"#4ade80":"#f87171"})},"●",4)])]),N(" Keyboard toolbar (always visible for easier terminal control) "),c("div",Ae,[c("button",{onClick:n.toggleCtrl,class:O([{active:n.ctrlActive},"toolbar-key"])},"Ctrl",2),c("button",{onClick:n.toggleAlt,class:O([{active:n.altActive},"toolbar-key"])},"Alt",2),c("button",{onClick:n.toggleShift,class:O([{active:n.shiftActive},"toolbar-key"])},"Shift",2),c("button",{onClick:u[0]||(u[0]=i=>n.sendKey("Escape")),class:"toolbar-key"},"Esc"),c("button",{onClick:u[1]||(u[1]=i=>n.sendKey("Tab")),class:"toolbar-key"},"Tab"),c("button",{onClick:u[2]||(u[2]=i=>n.sendKey("Enter")),class:"toolbar-key"},"Enter"),c("button",{onClick:u[3]||(u[3]=i=>n.sendKey("ArrowUp")),class:"toolbar-key"},"↑"),c("button",{onClick:u[4]||(u[4]=i=>n.sendKey("ArrowDown")),class:"toolbar-key"},"↓"),c("button",{onClick:u[5]||(u[5]=i=>n.sendKey("ArrowLeft")),class:"toolbar-key"},"←"),c("button",{onClick:u[6]||(u[6]=i=>n.sendKey("ArrowRight")),class:"toolbar-key"},"→")]),N(" Hidden input for mobile keyboard "),n.isMobile?ve((R(),x("input",{key:0,ref:"mobileInputRef",type:"text",class:"mobile-input","onUpdate:modelValue":u[7]||(u[7]=i=>n.mobileInputValue=i),onInput:n.handleMobileInput,onKeydown:n.handleMobileKeydown,autocomplete:"off",autocapitalize:"off",autocorrect:"off"},null,544)),[[be,n.mobileInputValue]]):N("v-if",!0),c("div",{class:"terminal-content",onClick:n.focusMobileInput},[c("div",{class:"terminal-output",style:$(n.terminalContainerStyle)},[(R(!0),x(me,null,ye(n.terminalBuffer,(i,o)=>(R(),x("div",{key:o,class:"terminal-row","data-row":o,innerHTML:n.renderRow(i,o)},null,8,Ke))),128))],4)])])}const Me=ge(ke,[["render",Se],["__file","/Users/justinschroeder/Projects/dmux/.dmux/worktrees/analyzing-never-stops/frontend/src/components/Terminal.vue"]]),Te=pe(Me);Te.mount("#app");
`,
    mimeType: 'application/javascript',
    size: 13765
  },
  'types.js': {
    content: `export {};
//# sourceMappingURL=types.js.map`,
    mimeType: 'application/javascript',
    size: 44
  }
};

export function getEmbeddedAsset(path: string): EmbeddedAsset | null {
  // Remove leading slash if present
  const normalizedPath = path.startsWith('/') ? path.substring(1) : path;
  return embeddedAssets[normalizedPath] || null;
}

export function hasEmbeddedAsset(path: string): boolean {
  const normalizedPath = path.startsWith('/') ? path.substring(1) : path;
  return normalizedPath in embeddedAssets;
}
