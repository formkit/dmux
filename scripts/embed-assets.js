#!/usr/bin/env node

/**
 * Embeds frontend/dist assets as TypeScript modules
 * This allows the server to serve them without file system access
 */

import { readFileSync, writeFileSync, readdirSync, statSync } from 'fs';
import { join, dirname, extname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const frontendDistPath = join(__dirname, '../dist');
const outputPath = join(__dirname, '../src/server/embedded-assets.ts');

// Read all files from dist (only frontend assets, not compiled TS)
function getAllFiles(dirPath, arrayOfFiles = []) {
  const files = readdirSync(dirPath);

  files.forEach(file => {
    const filePath = join(dirPath, file);
    const stat = statSync(filePath);

    if (stat.isDirectory()) {
      // Only recurse into chunks/ directory
      if (file === 'chunks') {
        arrayOfFiles = getAllFiles(filePath, arrayOfFiles);
      }
    } else {
      // Only include frontend assets (HTML, CSS, JS from root of dist)
      const ext = extname(file).toLowerCase();
      if (['.html', '.css', '.js'].includes(ext)) {
        arrayOfFiles.push(filePath);
      }
    }
  });

  return arrayOfFiles;
}

// Convert file path to asset key
function getAssetKey(filePath) {
  return filePath
    .replace(frontendDistPath, '')
    .replace(/^\//, '')
    .replace(/\\/g, '/');
}

// Escape backticks and backslashes in content
function escapeContent(content) {
  return content
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$\{/g, '\\${');
}

// Get MIME type from file extension
function getMimeType(filePath) {
  const ext = extname(filePath).toLowerCase();
  const mimeTypes = {
    '.html': 'text/html',
    '.css': 'text/css',
    '.js': 'application/javascript',
    '.json': 'application/json',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.gif': 'image/gif',
    '.svg': 'image/svg+xml',
    '.ico': 'image/x-icon',
  };
  return mimeTypes[ext] || 'application/octet-stream';
}

console.log('ðŸ“¦ Embedding frontend assets...\n');

// Get all files
const files = getAllFiles(frontendDistPath);

// Build the assets map
const assets = {};
files.forEach(filePath => {
  const key = getAssetKey(filePath);
  const content = readFileSync(filePath, 'utf-8');
  const mimeType = getMimeType(filePath);

  assets[key] = {
    content: escapeContent(content),
    mimeType,
    size: content.length
  };

  console.log(`  âœ“ ${key} (${mimeType}, ${(content.length / 1024).toFixed(1)}KB)`);
});

// Generate TypeScript file
const tsContent = `/**
 * Auto-generated embedded assets from frontend/dist
 * DO NOT EDIT MANUALLY - Generated by scripts/embed-assets.js
 */

export interface EmbeddedAsset {
  content: string;
  mimeType: string;
  size: number;
}

export const embeddedAssets: Record<string, EmbeddedAsset> = {
${Object.entries(assets).map(([key, asset]) => {
  return `  '${key}': {
    content: \`${asset.content}\`,
    mimeType: '${asset.mimeType}',
    size: ${asset.size}
  }`;
}).join(',\n')}
};

export function getEmbeddedAsset(path: string): EmbeddedAsset | null {
  // Remove leading slash if present
  const normalizedPath = path.startsWith('/') ? path.substring(1) : path;
  return embeddedAssets[normalizedPath] || null;
}

export function hasEmbeddedAsset(path: string): boolean {
  const normalizedPath = path.startsWith('/') ? path.substring(1) : path;
  return normalizedPath in embeddedAssets;
}
`;

writeFileSync(outputPath, tsContent, 'utf-8');

console.log(`\nâœ… Generated ${outputPath}`);
console.log(`ðŸ“Š Embedded ${files.length} files, total ${(Object.values(assets).reduce((sum, a) => sum + a.size, 0) / 1024).toFixed(1)}KB`);
